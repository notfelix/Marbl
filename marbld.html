<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MarbLD - Level Designer</title>
  <style>
    :root {
      --bg: #0a0f1a;
      --panel-bg: #111827;
      --border: #1f2937;
      --text: #e5e7eb;
      --text-dim: #9ca3af;
      --accent: #3b82f6;
      --accent-hover: #2563eb;
      --success: #22c55e;
      --warning: #f59e0b;
      --danger: #ef4444;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: var(--bg);
      color: var(--text);
      height: 100vh;
      display: grid;
      grid-template-columns: 1fr 480px;
      grid-template-rows: auto 1fr;
      gap: 1px;
      overflow: hidden;
    }

    /* Header */
    header {
      grid-column: 1 / -1;
      background: var(--panel-bg);
      padding: 10px 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      border-bottom: 1px solid var(--border);
    }
    header h1 {
      font-size: 16px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    header h1 span { color: var(--accent); }
    .header-actions {
      display: flex;
      gap: 6px;
    }
    .btn {
      padding: 6px 12px;
      border: none;
      border-radius: 4px;
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.15s;
    }
    .btn-primary {
      background: var(--accent);
      color: white;
    }
    .btn-primary:hover { background: var(--accent-hover); }
    .btn-secondary {
      background: var(--border);
      color: var(--text);
    }
    .btn-secondary:hover { background: #374151; }
    .btn-success { background: var(--success); color: white; }
    .btn-success:hover { background: #16a34a; }

    /* Level List Panel */
    .level-list-panel {
      background: var(--panel-bg);
      border-bottom: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      max-height: 200px;
      flex-shrink: 0;
    }
    .panel-header {
      padding: 8px 12px;
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-shrink: 0;
    }
    .panel-header h2 {
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--text-dim);
    }
    .level-list {
      flex: 1;
      overflow-y: auto;
      padding: 6px;
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      align-content: flex-start;
    }
    .level-item {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.15s;
      border: 2px solid transparent;
      flex-shrink: 0;
    }
    .level-item:hover { background: rgba(255,255,255,0.05); }
    .level-item.selected {
      background: rgba(59, 130, 246, 0.15);
      border-color: var(--accent);
    }
    .level-item.dragging {
      opacity: 0.5;
      background: rgba(59, 130, 246, 0.1);
    }
    .level-color {
      width: 18px;
      height: 18px;
      border-radius: 4px;
      flex-shrink: 0;
    }
    .level-info {
      flex: 1;
      min-width: 0;
    }
    .level-name {
      font-size: 12px;
      font-weight: 500;
      white-space: nowrap;
    }
    .level-meta {
      display: none;
    }
    .level-drag-handle {
      cursor: grab;
      color: var(--text-dim);
      padding: 2px;
      font-size: 12px;
    }
    .level-drag-handle:active { cursor: grabbing; }
    .add-level-btn {
      margin: 6px;
      padding: 6px 12px;
      border: 1px dashed var(--border);
      border-radius: 6px;
      background: transparent;
      color: var(--text-dim);
      cursor: pointer;
      font-size: 12px;
      transition: all 0.15s;
      flex-shrink: 0;
    }
    .add-level-btn:hover {
      border-color: var(--accent);
      color: var(--accent);
    }

    /* Editor Panel */
    .editor-panel {
      background: var(--panel-bg);
      display: flex;
      flex-direction: column;
      overflow: hidden;
      flex: 1;
      border-bottom: 1px solid var(--border);
    }
    .editor-content {
      flex: 1;
      overflow-y: auto;
      padding: 12px;
    }
    .editor-section {
      margin-bottom: 16px;
    }
    .editor-section h3 {
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--text-dim);
      margin-bottom: 8px;
      padding-bottom: 6px;
      border-bottom: 1px solid var(--border);
    }

    /* Form Controls */
    .form-row {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
    }
    .form-row label {
      font-size: 12px;
      color: var(--text);
      min-width: 80px;
    }
    .form-row input[type="number"],
    .form-row input[type="text"] {
      flex: 1;
      padding: 6px 10px;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text);
      font-size: 12px;
    }
    .form-row input:focus {
      outline: none;
      border-color: var(--accent);
    }
    .checkbox-row {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 8px;
    }
    .checkbox-row input[type="checkbox"] {
      width: 16px;
      height: 16px;
      accent-color: var(--accent);
    }
    .checkbox-row label {
      font-size: 12px;
    }

    /* Pedestal Grid */
    .pedestal-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 6px;
      max-width: 140px;
      margin: 0 auto;
    }
    .pedestal-cell {
      aspect-ratio: 1;
      background: var(--bg);
      border: 2px solid var(--border);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.15s;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      color: var(--text-dim);
    }
    .pedestal-cell:hover { border-color: var(--accent); }
    .pedestal-cell.active {
      background: var(--accent);
      border-color: var(--accent);
      color: white;
    }

    /* Color Picker */
    .color-row {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 6px;
    }
    .color-row label {
      font-size: 11px;
      min-width: 60px;
    }
    .color-input-wrapper {
      display: flex;
      align-items: center;
      gap: 6px;
      flex: 1;
    }
    .color-swatch {
      width: 24px;
      height: 24px;
      border-radius: 4px;
      border: 2px solid var(--border);
      cursor: pointer;
      flex-shrink: 0;
    }
    .color-hex {
      flex: 1;
      padding: 4px 8px;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text);
      font-size: 11px;
      font-family: monospace;
      min-width: 0;
    }
    .color-suggestion {
      font-size: 10px;
      color: var(--text-dim);
      margin-top: 2px;
    }

    /* Orb List */
    .orb-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .orb-item {
      padding: 8px;
      background: var(--bg);
      border-radius: 6px;
      border: 1px solid var(--border);
    }
    .orb-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 6px;
    }
    .orb-title {
      font-size: 11px;
      font-weight: 600;
      color: var(--text);
    }
    .orb-delete {
      background: none;
      border: none;
      color: var(--text-dim);
      cursor: pointer;
      font-size: 14px;
      padding: 2px 6px;
    }
    .orb-delete:hover { color: #ef4444; }
    .orb-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }
    .orb-type-toggle {
      display: flex;
      gap: 4px;
    }
    .orb-type-btn {
      padding: 3px 8px;
      border: 1px solid var(--border);
      background: var(--bg);
      color: var(--text-dim);
      font-size: 10px;
      cursor: pointer;
      border-radius: 3px;
    }
    .orb-type-btn.active {
      background: var(--accent);
      border-color: var(--accent);
      color: white;
    }
    .orb-coord {
      display: flex;
      align-items: center;
      gap: 4px;
    }
    .orb-coord label {
      font-size: 10px;
      color: var(--text-dim);
    }
    .orb-coord input {
      width: 50px;
      padding: 3px 6px;
      background: var(--panel-bg);
      border: 1px solid var(--border);
      border-radius: 3px;
      color: var(--text);
      font-size: 11px;
    }
    .orb-wild {
      display: flex;
      align-items: center;
      gap: 4px;
    }
    .orb-wild input {
      width: 14px;
      height: 14px;
      accent-color: #fbbf24;
    }
    .orb-wild label {
      font-size: 10px;
      color: #fbbf24;
    }
    .add-orb-btn {
      margin-top: 8px;
      padding: 6px 12px;
      border: 1px dashed var(--border);
      border-radius: 6px;
      background: transparent;
      color: var(--text-dim);
      cursor: pointer;
      font-size: 11px;
      width: 100%;
    }
    .add-orb-btn:hover {
      border-color: var(--accent);
      color: var(--accent);
    }

    /* Wall Grid Editor */
    .wall-grid-container {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .wall-grid-wrapper {
      position: relative;
      aspect-ratio: 1;
      max-width: 280px;
      margin: 0 auto;
      background: var(--bg);
      border: 2px solid var(--border);
      border-radius: 6px;
      overflow: hidden;
    }
    #wall-grid-canvas {
      width: 100%;
      height: 100%;
      cursor: crosshair;
    }
    .wall-grid-controls {
      display: flex;
      gap: 8px;
      justify-content: center;
      flex-wrap: wrap;
    }
    .wall-grid-controls .btn {
      padding: 4px 10px;
      font-size: 11px;
    }
    .wall-height-row {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 4px;
    }
    .wall-height-row label {
      font-size: 11px;
      color: var(--text-dim);
    }
    .wall-height-row input {
      flex: 1;
      padding: 4px 8px;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text);
      font-size: 11px;
    }

    /* Game Preview (Left side) */
    .game-preview {
      background: #050915;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    .game-preview-header {
      padding: 8px 16px;
      background: var(--panel-bg);
      display: flex;
      align-items: center;
      justify-content: space-between;
      border-bottom: 1px solid var(--border);
      flex-shrink: 0;
    }
    .game-preview-header h3 {
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--text-dim);
    }
    .game-iframe-container {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #050915;
      overflow: hidden;
    }
    #game-iframe {
      border: none;
      width: 100%;
      height: 100%;
      max-width: 100%;
      max-height: 100%;
    }

    /* Right Panel (Editor) */
    .right-panel {
      display: flex;
      flex-direction: column;
      background: var(--panel-bg);
      border-left: 1px solid var(--border);
      overflow: hidden;
    }

    /* Status indicator */
    .status {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      color: var(--text-dim);
    }
    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--warning);
    }
    .status-dot.connected { background: var(--success); }

    /* Empty state */
    .empty-state {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
      color: var(--text-dim);
      text-align: center;
      padding: 20px;
    }
    .empty-state p {
      font-size: 12px;
      margin-top: 4px;
    }
  </style>
</head>
<body>
  <header>
    <h1><span>MarbLD</span> Level Designer</h1>
    <div class="header-actions">
      <button class="btn btn-secondary" id="import-btn">Import JSON</button>
      <button class="btn btn-secondary" id="export-btn">Export JSON</button>
      <button class="btn btn-success" id="apply-btn">Apply to Game</button>
    </div>
  </header>

  <!-- Left: Game Preview -->
  <section class="game-preview">
    <div class="game-preview-header">
      <h3>Game Preview</h3>
      <div class="status">
        <span class="status-dot" id="status-dot"></span>
        <span id="status-text">Connecting...</span>
      </div>
    </div>
    <div class="game-iframe-container">
      <iframe id="game-iframe" src="marbl.html"></iframe>
    </div>
  </section>

  <!-- Right: Level List + Editor + 2D Preview -->
  <div class="right-panel">
    <div class="level-list-panel">
      <div class="panel-header">
        <h2>Levels</h2>
        <button class="btn btn-secondary" id="delete-level-btn" style="padding: 4px 8px; font-size: 11px;">Delete</button>
      </div>
      <div class="level-list" id="level-list"></div>
      <button class="add-level-btn" id="add-level-btn">+ Add Level</button>
    </div>

    <div class="editor-panel">
      <div class="panel-header">
        <h2>Editor</h2>
      </div>
      <div class="editor-content" id="editor-content">
        <div class="empty-state">
          <p>Select a level to edit</p>
        </div>
      </div>
    </div>

  </div>

  <input type="file" id="import-file" accept=".json,.js" style="display: none;">
  <input type="color" id="color-picker-hidden" style="display: none;">

  <script>
    /*
     * MarbLD - Level Designer for MARBL
     *
     * OVERVIEW:
     * Visual editor for creating and editing MARBL game levels. Embeds the game
     * in an iframe for live preview with hot reload (changes apply without resetting
     * the marble position or game state).
     *
     * COMMUNICATION:
     * - Editor → Game: postMessage with 'marbl-load-levels' (hot reload) or 'marbl-preview-level' (jump to level)
     * - Game → Editor: 'marbl-ready' (connection established), 'marbl-reloaded' (reload complete)
     * - Uses game's marblAPI.getLevelConfigs() to sync initial state
     *
     * LEVEL CONFIGURATION (per level):
     * - pedestals: Array of indices [0-8] into 3x3 grid (pedestalReferencePositions in game)
     *   Grid layout: 0=top-left, 4=center, 8=bottom-right (row-major order)
     * - orbs: Array of {type: 'random'|'fixed', x?, z?, wild: boolean}
     * - walls: Array of {x, z} grid coordinates (16x16 grid, cell size = 57.5 units)
     * - wallHeight: Height of walls (default: 33.33, same as pedestal height)
     * - colors: {floor, wall, pedestal, pedestalHole} - each an [r,g,b] array (0-1 range)
     * - wild: Boolean - if true, level persists through time rewind
     * - exactOrbs: Boolean - if true, requires exact orb count (no more, no less)
     *
     * WALL GRID:
     * - 16x16 cells covering the 920x920 unit floor
     * - Cell (0,0) is top-left in editor view
     * - World coords: -(cell.x - 8 + 0.5) * 57.5 for X, same formula for Z
     * - Pedestal spacing aligned to 5 cells (287.5 units) for symmetric wall contouring
     *
     * KEY FEATURES:
     * - Pedestal picker with visual 3x3 grid toggle
     * - Wall painter with click-drag to add, right-click-drag to erase
     * - Color editor with harmonious color generation
     * - Orb management (random/fixed position, wild toggle)
     * - Import/Export as JSON
     */

    // ===========================================
    // MarbLD Level Designer
    // ===========================================

    // Wall grid configuration
    const WALL_GRID_SIZE = 16; // 16x16 grid
    const FLOOR_SIZE = 920;    // Game floor size in units
    const CELL_SIZE = FLOOR_SIZE / WALL_GRID_SIZE; // ~57.5 units per cell
    const DEFAULT_WALL_HEIGHT = 33.33; // Same as pedestal height (marble.r * 4/3)

    // Default level configuration template
    const defaultLevelTemplate = {
      pedestals: [4], // center (hole is derived from having pedestals)
      colors: {
        floor: [0.3, 0.3, 0.6],
        wall: [0.25, 0.25, 0.5],
        pedestal: [0.4, 0.4, 0.7],
        pedestalHole: [0.2, 0.2, 0.4]
      },
      // Each orb: { type: 'random' | 'fixed', x?: number, z?: number, wild: boolean }
      orbs: [{ type: 'random', wild: false }],
      wild: false, // Wild pedestals (persists through rewind)
      walls: [], // Array of {x, z} grid coordinates
      wallHeight: DEFAULT_WALL_HEIGHT
    };

    // State
    let levels = [];
    let selectedLevelIndex = -1;
    let gameConnected = false;
    let isWallPainting = false;
    let wallPaintMode = 'add'; // 'add' or 'remove'

    // Throttle utility for performance-sensitive operations
    function throttle(fn, delay) {
      let lastCall = 0;
      return function(...args) {
        const now = Date.now();
        if (now - lastCall >= delay) {
          lastCall = now;
          fn.apply(this, args);
        }
      };
    }

    // Migrate old level format to new format
    function migrateLevelFormat(level) {
      // Migrate orbs (orbCount/fixedOrb → orbs array)
      if (!level.orbs) {
        const orbs = [];
        if (level.fixedOrb) {
          orbs.push({ type: 'fixed', x: level.fixedOrb.x, z: level.fixedOrb.z, wild: level.fixedOrb.wild || false });
        }
        const randomCount = level.orbCount || 0;
        for (let i = 0; i < randomCount; i++) {
          orbs.push({ type: 'random', wild: false });
        }
        delete level.orbCount;
        delete level.fixedOrb;
        level.orbs = orbs;
      }

      // Migrate innerWall → walls array
      if (level.innerWall && !level.walls) {
        const walls = [];
        if (level.innerWall.enabled) {
          // Convert position-based inner wall to grid cells
          // Old format: cross pattern at ±position from center
          const pos = level.innerWall.position ?? 155;
          const halfWidth = level.innerWall.halfWidth ?? 33;
          // Convert to grid coordinates (0-15, center is 7.5)
          const centerCell = WALL_GRID_SIZE / 2;
          const posCell = Math.round(pos / CELL_SIZE);

          // Create cross pattern: 4 lines from edge to near-center
          // Top/Bottom horizontal lines and Left/Right vertical lines
          for (let i = 0; i < WALL_GRID_SIZE; i++) {
            // Top horizontal line (at row centerCell - posCell)
            const topRow = Math.round(centerCell - posCell);
            if (topRow >= 0 && topRow < WALL_GRID_SIZE) {
              walls.push({ x: i, z: topRow });
            }
            // Bottom horizontal line (at row centerCell + posCell - 1)
            const bottomRow = Math.round(centerCell + posCell - 1);
            if (bottomRow >= 0 && bottomRow < WALL_GRID_SIZE) {
              walls.push({ x: i, z: bottomRow });
            }
            // Left vertical line (at col centerCell - posCell)
            const leftCol = Math.round(centerCell - posCell);
            if (leftCol >= 0 && leftCol < WALL_GRID_SIZE) {
              walls.push({ x: leftCol, z: i });
            }
            // Right vertical line (at col centerCell + posCell - 1)
            const rightCol = Math.round(centerCell + posCell - 1);
            if (rightCol >= 0 && rightCol < WALL_GRID_SIZE) {
              walls.push({ x: rightCol, z: i });
            }
          }
          // Remove duplicates
          const seen = new Set();
          level.walls = walls.filter(w => {
            const key = `${w.x},${w.z}`;
            if (seen.has(key)) return false;
            seen.add(key);
            return true;
          });
          level.wallHeight = level.innerWall.height ?? DEFAULT_WALL_HEIGHT;
        } else {
          level.walls = [];
          level.wallHeight = DEFAULT_WALL_HEIGHT;
        }
        delete level.innerWall;
      }

      // Ensure walls array exists
      if (!level.walls) {
        level.walls = [];
        level.wallHeight = level.wallHeight ?? DEFAULT_WALL_HEIGHT;
      }

      return level;
    }

    // DOM elements
    const levelListEl = document.getElementById('level-list');
    const editorContentEl = document.getElementById('editor-content');
    const gameIframe = document.getElementById('game-iframe');
    const statusDot = document.getElementById('status-dot');
    const statusText = document.getElementById('status-text');

    // ===========================================
    // Color Utilities
    // ===========================================
    function rgbToHex(r, g, b) {
      return '#' + [r, g, b].map(x => {
        const hex = Math.round(x * 255).toString(16);
        return hex.length === 1 ? '0' + hex : hex;
      }).join('');
    }

    function hexToRgb(hex) {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result ? [
        parseInt(result[1], 16) / 255,
        parseInt(result[2], 16) / 255,
        parseInt(result[3], 16) / 255
      ] : [0.5, 0.5, 0.5];
    }

    function generateHarmoniousColors(baseHue) {
      // Generate floor, wall, pedestal, pedestalHole colors from a base hue
      const hslToRgb = (h, s, l) => {
        let r, g, b;
        if (s === 0) {
          r = g = b = l;
        } else {
          const hue2rgb = (p, q, t) => {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1/6) return p + (q - p) * 6 * t;
            if (t < 1/2) return q;
            if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
            return p;
          };
          const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          const p = 2 * l - q;
          r = hue2rgb(p, q, h + 1/3);
          g = hue2rgb(p, q, h);
          b = hue2rgb(p, q, h - 1/3);
        }
        return [r, g, b];
      };

      return {
        floor: hslToRgb(baseHue, 0.6, 0.4),
        wall: hslToRgb(baseHue, 0.55, 0.35),
        pedestal: hslToRgb(baseHue, 0.65, 0.5),
        pedestalHole: hslToRgb(baseHue, 0.5, 0.28)
      };
    }

    function rgbToHue(r, g, b) {
      const max = Math.max(r, g, b);
      const min = Math.min(r, g, b);
      if (max === min) return 0;
      let h;
      if (max === r) h = (g - b) / (max - min);
      else if (max === g) h = 2 + (b - r) / (max - min);
      else h = 4 + (r - g) / (max - min);
      h = h / 6;
      if (h < 0) h += 1;
      return h;
    }

    function suggestNextColor(existingLevels) {
      // Suggest a hue that's different from existing levels
      const usedHues = existingLevels.map(l => rgbToHue(...l.colors.floor));

      // Find the largest gap in used hues
      if (usedHues.length === 0) return 0.6; // Start with blue
      usedHues.sort((a, b) => a - b);

      let maxGap = 0;
      let bestHue = 0;
      for (let i = 0; i < usedHues.length; i++) {
        const next = i === usedHues.length - 1 ? usedHues[0] + 1 : usedHues[i + 1];
        const gap = next - usedHues[i];
        if (gap > maxGap) {
          maxGap = gap;
          bestHue = (usedHues[i] + gap / 2) % 1;
        }
      }
      return bestHue;
    }

    // ===========================================
    // Level List Rendering
    // ===========================================
    function renderLevelList() {
      levelListEl.innerHTML = '';
      levels.forEach((level, index) => {
        const item = document.createElement('div');
        item.className = 'level-item' + (index === selectedLevelIndex ? ' selected' : '');
        item.draggable = true;
        item.dataset.index = index;

        const color = level.colors.floor;
        const hexColor = rgbToHex(color[0], color[1], color[2]);

        const pedestalCount = level.pedestals.length;
        const orbCount = level.orbs?.length || 0;
        const meta = `${pedestalCount} pedestal${pedestalCount !== 1 ? 's' : ''}, ${orbCount} orb${orbCount !== 1 ? 's' : ''}`;

        item.innerHTML = `
          <div class="level-drag-handle">&#9776;</div>
          <div class="level-color" style="background: ${hexColor}"></div>
          <div class="level-info">
            <div class="level-name">Level ${index}${level.pedestals.length === 0 ? ' (Final)' : ''}</div>
            <div class="level-meta">${meta}</div>
          </div>
        `;

        item.addEventListener('click', () => selectLevel(index));
        item.addEventListener('dragstart', handleDragStart);
        item.addEventListener('dragover', handleDragOver);
        item.addEventListener('drop', handleDrop);
        item.addEventListener('dragend', handleDragEnd);

        levelListEl.appendChild(item);
      });
    }

    // ===========================================
    // Drag & Drop Reordering
    // ===========================================
    let draggedIndex = null;

    function handleDragStart(e) {
      draggedIndex = parseInt(e.target.closest('.level-item').dataset.index);
      e.target.closest('.level-item').classList.add('dragging');
      e.dataTransfer.effectAllowed = 'move';
    }

    function handleDragOver(e) {
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';
    }

    function handleDrop(e) {
      e.preventDefault();
      const targetIndex = parseInt(e.target.closest('.level-item').dataset.index);
      if (draggedIndex !== null && draggedIndex !== targetIndex) {
        const [moved] = levels.splice(draggedIndex, 1);
        levels.splice(targetIndex, 0, moved);
        if (selectedLevelIndex === draggedIndex) {
          selectedLevelIndex = targetIndex;
        } else if (selectedLevelIndex > draggedIndex && selectedLevelIndex <= targetIndex) {
          selectedLevelIndex--;
        } else if (selectedLevelIndex < draggedIndex && selectedLevelIndex >= targetIndex) {
          selectedLevelIndex++;
        }
        renderLevelList();
        renderEditor();
      }
    }

    function handleDragEnd(e) {
      e.target.closest('.level-item')?.classList.remove('dragging');
      draggedIndex = null;
    }

    // ===========================================
    // Editor Rendering
    // ===========================================
    function selectLevel(index) {
      selectedLevelIndex = index;
      renderLevelList();
      renderEditor();

      // Jump to level in game preview
      if (gameConnected) {
        gameIframe.contentWindow.postMessage({
          type: 'marbl-preview-level',
          levelIndex: index
        }, '*');
      }
    }

    function renderEditor() {
      if (selectedLevelIndex < 0 || selectedLevelIndex >= levels.length) {
        editorContentEl.innerHTML = '<div class="empty-state"><p>Select a level to edit</p></div>';
        return;
      }

      const level = levels[selectedLevelIndex];

      editorContentEl.innerHTML = `
        <!-- Basic Settings -->
        <div class="editor-section">
          <h3>Basic Settings</h3>
          <div class="checkbox-row">
            <input type="checkbox" id="wild" ${level.wild ? 'checked' : ''}>
            <label for="wild">Wild (persists through rewind)</label>
          </div>
        </div>

        <!-- Pedestals -->
        <div class="editor-section">
          <h3>Pedestals (3x3 Grid)</h3>
          <div class="pedestal-grid">
            ${[8,7,6,5,4,3,2,1,0].map(i => `
              <div class="pedestal-cell ${level.pedestals.includes(i) ? 'active' : ''}" data-index="${i}">
                ${i === 4 ? 'C' : ''}
              </div>
            `).join('')}
          </div>
          <p style="font-size: 11px; color: var(--text-dim); text-align: center; margin-top: 8px;">
            Click cells to toggle pedestals. C = Center
          </p>
        </div>

        <!-- Orbs -->
        <div class="editor-section">
          <h3>Orbs</h3>
          <div class="orb-list">
            ${(level.orbs || []).map((orb, i) => `
              <div class="orb-item" data-orb-index="${i}">
                <div class="orb-header">
                  <span class="orb-title">Orb ${i + 1}</span>
                  <button class="orb-delete" data-orb-index="${i}">&times;</button>
                </div>
                <div class="orb-controls">
                  <div class="orb-type-toggle">
                    <button class="orb-type-btn ${orb.type === 'random' ? 'active' : ''}" data-orb-index="${i}" data-type="random">Random</button>
                    <button class="orb-type-btn ${orb.type === 'fixed' ? 'active' : ''}" data-orb-index="${i}" data-type="fixed">Fixed</button>
                  </div>
                  ${orb.type === 'fixed' ? `
                    <div class="orb-coord">
                      <label>X</label>
                      <input type="number" class="orb-x" data-orb-index="${i}" value="${orb.x ?? 250}" step="10">
                    </div>
                    <div class="orb-coord">
                      <label>Z</label>
                      <input type="number" class="orb-z" data-orb-index="${i}" value="${orb.z ?? 0}" step="10">
                    </div>
                  ` : ''}
                  <div class="orb-wild">
                    <input type="checkbox" class="orb-wild-check" data-orb-index="${i}" ${orb.wild ? 'checked' : ''}>
                    <label>Wild</label>
                  </div>
                </div>
              </div>
            `).join('')}
          </div>
          <button class="add-orb-btn" id="add-orb-btn">+ Add Orb</button>
        </div>

        <!-- Colors -->
        <div class="editor-section">
          <h3>Colors</h3>
          <button class="btn btn-secondary" id="auto-colors-btn" style="margin-bottom: 12px; width: 100%;">
            Auto-generate harmonious colors
          </button>
          ${['floor', 'wall', 'pedestal', 'pedestalHole'].map(key => {
            const color = level.colors[key];
            const hex = rgbToHex(color[0], color[1], color[2]);
            const label = key === 'pedestalHole' ? 'Ped. Hole' : key.charAt(0).toUpperCase() + key.slice(1);
            return `
              <div class="color-row">
                <label>${label}</label>
                <div class="color-input-wrapper">
                  <div class="color-swatch" style="background: ${hex}" data-color-key="${key}"></div>
                  <input type="text" class="color-hex" value="${hex}" data-color-key="${key}">
                </div>
              </div>
            `;
          }).join('')}
        </div>

        <!-- Wall Grid -->
        <div class="editor-section">
          <h3>Walls (${WALL_GRID_SIZE}x${WALL_GRID_SIZE} Grid)</h3>
          <div class="wall-grid-container">
            <div class="wall-grid-wrapper">
              <canvas id="wall-grid-canvas"></canvas>
            </div>
            <div class="wall-grid-controls">
              <button class="btn btn-secondary" id="clear-walls-btn">Clear All</button>
              <button class="btn btn-secondary" id="fill-border-btn">Fill Border</button>
            </div>
            <div class="wall-height-row">
              <label>Height:</label>
              <input type="number" id="wall-height" value="${level.wallHeight ?? DEFAULT_WALL_HEIGHT}" step="5" min="10" max="200">
            </div>
            <p style="font-size: 10px; color: var(--text-dim); text-align: center; margin-top: 4px;">
              Click and drag to paint walls. Right-click to erase.
            </p>
          </div>
        </div>
      `;

      // Attach event listeners
      attachEditorListeners();
    }

    function attachEditorListeners() {
      const level = levels[selectedLevelIndex];

      // Basic settings
      document.getElementById('wild')?.addEventListener('change', (e) => {
        level.wild = e.target.checked;
        applyToGame();
      });

      // Pedestals
      document.querySelectorAll('.pedestal-cell').forEach(cell => {
        cell.addEventListener('click', () => {
          const idx = parseInt(cell.dataset.index);
          const pos = level.pedestals.indexOf(idx);
          if (pos >= 0) {
            level.pedestals.splice(pos, 1);
          } else {
            level.pedestals.push(idx);
            level.pedestals.sort((a, b) => a - b);
          }
          renderEditor();
          renderLevelList();
          applyToGame();
        });
      });

      // Orbs - Add orb button
      document.getElementById('add-orb-btn')?.addEventListener('click', () => {
        if (!level.orbs) level.orbs = [];
        level.orbs.push({ type: 'random', wild: false });
        renderEditor();
        renderLevelList();
        applyToGame();
      });

      // Orbs - Delete buttons
      document.querySelectorAll('.orb-delete').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const idx = parseInt(btn.dataset.orbIndex);
          level.orbs.splice(idx, 1);
          renderEditor();
          renderLevelList();
          applyToGame();
        });
      });

      // Orbs - Type toggle buttons
      document.querySelectorAll('.orb-type-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const idx = parseInt(btn.dataset.orbIndex);
          const newType = btn.dataset.type;
          level.orbs[idx].type = newType;
          if (newType === 'fixed') {
            // Default to position outside center (minCenterDistance is 220)
            level.orbs[idx].x = level.orbs[idx].x ?? 250;
            level.orbs[idx].z = level.orbs[idx].z ?? 0;
          }
          renderEditor();
          applyToGame();
        });
      });

      // Orbs - X coordinate inputs
      document.querySelectorAll('.orb-x').forEach(input => {
        input.addEventListener('change', () => {
          const idx = parseInt(input.dataset.orbIndex);
          level.orbs[idx].x = parseFloat(input.value) || 0;
          applyToGame();
        });
      });

      // Orbs - Z coordinate inputs
      document.querySelectorAll('.orb-z').forEach(input => {
        input.addEventListener('change', () => {
          const idx = parseInt(input.dataset.orbIndex);
          level.orbs[idx].z = parseFloat(input.value) || 0;
          applyToGame();
        });
      });

      // Orbs - Wild checkboxes
      document.querySelectorAll('.orb-wild-check').forEach(checkbox => {
        checkbox.addEventListener('change', () => {
          const idx = parseInt(checkbox.dataset.orbIndex);
          level.orbs[idx].wild = checkbox.checked;
          applyToGame();
        });
      });

      // Colors
      document.getElementById('auto-colors-btn')?.addEventListener('click', () => {
        const hue = suggestNextColor(levels.filter((_, i) => i !== selectedLevelIndex));
        level.colors = generateHarmoniousColors(hue);
        renderEditor();
        renderLevelList();
        applyToGame();
      });

      document.querySelectorAll('.color-swatch').forEach(swatch => {
        swatch.addEventListener('click', () => {
          const key = swatch.dataset.colorKey;
          const picker = document.getElementById('color-picker-hidden');
          const currentHex = rgbToHex(...level.colors[key]);
          picker.value = currentHex;
          picker.onchange = () => {
            const rgb = hexToRgb(picker.value);
            if (key === 'floor') {
              // Auto-generate all colors from floor hue
              const hue = rgbToHue(...rgb);
              level.colors = generateHarmoniousColors(hue);
            } else {
              level.colors[key] = rgb;
            }
            renderEditor();
            renderLevelList();
            applyToGame();
          };
          picker.click();
        });
      });

      document.querySelectorAll('.color-hex').forEach(input => {
        input.addEventListener('change', () => {
          const key = input.dataset.colorKey;
          const rgb = hexToRgb(input.value);
          if (key === 'floor') {
            // Auto-generate all colors from floor hue
            const hue = rgbToHue(...rgb);
            level.colors = generateHarmoniousColors(hue);
          } else {
            level.colors[key] = rgb;
          }
          renderEditor();
          renderLevelList();
          applyToGame();
        });
      });

      // Wall grid
      setupWallGridCanvas(level);

      document.getElementById('clear-walls-btn')?.addEventListener('click', () => {
        level.walls = [];
        renderWallGrid(level);
        applyToGame();
      });

      document.getElementById('fill-border-btn')?.addEventListener('click', () => {
        // Add border cells
        for (let i = 0; i < WALL_GRID_SIZE; i++) {
          // Top and bottom edges
          addWallCell(level, i, 0);
          addWallCell(level, i, WALL_GRID_SIZE - 1);
          // Left and right edges
          addWallCell(level, 0, i);
          addWallCell(level, WALL_GRID_SIZE - 1, i);
        }
        renderWallGrid(level);
        applyToGame();
      });

      document.getElementById('wall-height')?.addEventListener('change', (e) => {
        level.wallHeight = parseFloat(e.target.value) || DEFAULT_WALL_HEIGHT;
        applyToGame();
      });
    }

    // ===========================================
    // Wall Grid Canvas
    // ===========================================
    function hasWallCell(level, x, z) {
      return level.walls.some(w => w.x === x && w.z === z);
    }

    function addWallCell(level, x, z) {
      if (!hasWallCell(level, x, z)) {
        level.walls.push({ x, z });
      }
    }

    function removeWallCell(level, x, z) {
      level.walls = level.walls.filter(w => !(w.x === x && w.z === z));
    }

    function setupWallGridCanvas(level) {
      const canvas = document.getElementById('wall-grid-canvas');
      if (!canvas) return;

      const rect = canvas.parentElement.getBoundingClientRect();
      const size = Math.min(rect.width, rect.height) || 280;
      canvas.width = size * window.devicePixelRatio;
      canvas.height = size * window.devicePixelRatio;
      canvas.style.width = size + 'px';
      canvas.style.height = size + 'px';

      renderWallGrid(level);

      // Prevent context menu on right-click
      canvas.oncontextmenu = (e) => e.preventDefault();

      // Get cell from mouse position
      function getCellFromEvent(e) {
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) / rect.width;
        const z = (e.clientY - rect.top) / rect.height;
        return {
          x: Math.floor(x * WALL_GRID_SIZE),
          z: Math.floor(z * WALL_GRID_SIZE)
        };
      }

      // Mouse down - start painting
      canvas.onmousedown = (e) => {
        isWallPainting = true;
        const cell = getCellFromEvent(e);
        if (cell.x < 0 || cell.x >= WALL_GRID_SIZE || cell.z < 0 || cell.z >= WALL_GRID_SIZE) return;

        // Right click = erase, left click = add
        wallPaintMode = e.button === 2 ? 'remove' : 'add';

        if (wallPaintMode === 'add') {
          addWallCell(level, cell.x, cell.z);
        } else {
          removeWallCell(level, cell.x, cell.z);
        }
        renderWallGrid(level);
        applyToGame();
      };

      // Mouse move - continue painting (throttle game updates for performance)
      const throttledApply = throttle(() => applyToGame(), 50);
      canvas.onmousemove = (e) => {
        if (!isWallPainting) return;
        const cell = getCellFromEvent(e);
        if (cell.x < 0 || cell.x >= WALL_GRID_SIZE || cell.z < 0 || cell.z >= WALL_GRID_SIZE) return;

        if (wallPaintMode === 'add') {
          addWallCell(level, cell.x, cell.z);
        } else {
          removeWallCell(level, cell.x, cell.z);
        }
        renderWallGrid(level);
        throttledApply();
      };

      // Mouse up - stop painting and ensure final state is synced
      canvas.onmouseup = () => {
        if (isWallPainting) applyToGame();
        isWallPainting = false;
      };

      canvas.onmouseleave = () => {
        if (isWallPainting) applyToGame();
        isWallPainting = false;
      };
    }

    function renderWallGrid(level) {
      const canvas = document.getElementById('wall-grid-canvas');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      const w = canvas.width;
      const h = canvas.height;
      const cellW = w / WALL_GRID_SIZE;
      const cellH = h / WALL_GRID_SIZE;

      // Clear
      ctx.fillStyle = '#0a0f1a';
      ctx.fillRect(0, 0, w, h);

      // Draw grid lines
      ctx.strokeStyle = '#1f2937';
      ctx.lineWidth = 1;
      for (let i = 0; i <= WALL_GRID_SIZE; i++) {
        ctx.beginPath();
        ctx.moveTo(i * cellW, 0);
        ctx.lineTo(i * cellW, h);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(0, i * cellH);
        ctx.lineTo(w, i * cellH);
        ctx.stroke();
      }

      // Draw wall cells
      const wallColor = rgbToHex(...(level.colors?.wall || [0.25, 0.25, 0.5]));
      ctx.fillStyle = wallColor;
      for (const cell of level.walls || []) {
        ctx.fillRect(cell.x * cellW + 1, cell.z * cellH + 1, cellW - 2, cellH - 2);
      }

      // Draw center marker
      const centerX = w / 2;
      const centerY = h / 2;
      ctx.strokeStyle = 'rgba(255,255,255,0.3)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(centerX, centerY, 8, 0, Math.PI * 2);
      ctx.stroke();
    }

    // ===========================================
    // Game Communication
    // ===========================================
    function applyToGame() {
      if (!gameConnected) return;
      gameIframe.contentWindow.postMessage({
        type: 'marbl-load-levels',
        levels: structuredClone(levels),
        hotReload: true // Preserve game state (marble position, orbs, etc.)
      }, '*');
    }

    window.addEventListener('message', (e) => {
      if (e.data?.type === 'marbl-ready') {
        gameConnected = true;
        statusDot.classList.add('connected');
        statusText.textContent = 'Connected';
        // Load initial levels from game
        loadLevelsFromGame();
      }
    });

    function loadLevelsFromGame() {
      // Try to get levels from game's API
      try {
        const gameLevels = gameIframe.contentWindow.marblAPI?.getLevelConfigs();
        if (gameLevels && gameLevels.length > 0) {
          levels = structuredClone(gameLevels);
          // Migrate old format (orbCount/fixedOrb) to new format (orbs array)
          levels.forEach(migrateLevelFormat);
          renderLevelList();
          if (levels.length > 0) {
            selectLevel(0);
          }
        }
      } catch (err) {
        console.warn('Could not load levels from game:', err);
        // Use default if can't load
        levels = [structuredClone(defaultLevelTemplate)];
        renderLevelList();
        selectLevel(0);
      }
    }

    // ===========================================
    // Level Management
    // ===========================================
    document.getElementById('add-level-btn').addEventListener('click', () => {
      const hue = suggestNextColor(levels);
      const newLevel = structuredClone(defaultLevelTemplate);
      newLevel.colors = generateHarmoniousColors(hue);
      levels.push(newLevel);
      renderLevelList();
      selectLevel(levels.length - 1);
      applyToGame();
    });

    document.getElementById('delete-level-btn').addEventListener('click', () => {
      if (selectedLevelIndex < 0 || levels.length <= 1) return;
      if (!confirm(`Delete Level ${selectedLevelIndex}?`)) return;
      levels.splice(selectedLevelIndex, 1);
      selectedLevelIndex = Math.min(selectedLevelIndex, levels.length - 1);
      renderLevelList();
      renderEditor();
      applyToGame();
    });

    // ===========================================
    // Import/Export
    // ===========================================
    let savedFileHandle = null;
    document.getElementById('export-btn').addEventListener('click', async () => {
      const js = 'window.marblLevels = ' + JSON.stringify(levels, null, 2) + ';';

      // Try File System Access API (Chrome/Edge) for direct save
      if ('showSaveFilePicker' in window) {
        try {
          const handle = await window.showSaveFilePicker({
            suggestedName: 'marbl-levels.js',
            types: [{ description: 'JavaScript', accept: { 'application/javascript': ['.js'] } }],
            startIn: savedFileHandle ?? 'downloads'
          });
          savedFileHandle = handle;
          const writable = await handle.createWritable();
          await writable.write(js);
          await writable.close();
          return;
        } catch (e) {
          if (e.name === 'AbortError') return; // User cancelled
        }
      }

      // Fallback to download
      const blob = new Blob([js], { type: 'application/javascript' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'marbl-levels.js';
      a.click();
      URL.revokeObjectURL(url);
    });

    document.getElementById('import-btn').addEventListener('click', () => {
      document.getElementById('import-file').click();
    });

    document.getElementById('import-file').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (event) => {
        try {
          let content = event.target.result;
          // Handle .js format (window.marblLevels = [...];)
          if (content.trim().startsWith('window.marblLevels')) {
            content = content.replace(/^window\.marblLevels\s*=\s*/, '').replace(/;\s*$/, '');
          }
          const imported = JSON.parse(content);
          if (Array.isArray(imported) && imported.length > 0) {
            levels = imported;
            renderLevelList();
            selectLevel(0);
            applyToGame();
          }
        } catch (err) {
          alert('Failed to parse levels: ' + err.message);
        }
      };
      reader.readAsText(file);
      e.target.value = '';
    });

    document.getElementById('apply-btn').addEventListener('click', () => {
      applyToGame();
    });

    // ===========================================
    // Initialization
    // Initial render with empty state
    renderLevelList();

    // Wait a bit for iframe to load, then try to connect
    setTimeout(() => {
      if (!gameConnected) {
        statusText.textContent = 'Waiting for game...';
      }
    }, 2000);
  </script>
</body>
</html>
