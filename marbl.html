<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Marbl (WebGL)</title>
  <script src="marbl-levels.js" onerror=""></script>
  <style>
    :root {
      --bg: #050915;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      display: grid;
      place-items: center;
      position: relative;
      overflow: hidden;
      background: radial-gradient(circle at 30% 20%, #0c1224 0%, var(--bg) 55%);
      color: #e5ecff;
      font-family: "Inter", system-ui, -apple-system, sans-serif;
      height: 100vh;
      -webkit-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
      -webkit-tap-highlight-color: transparent;
    }
    #stars {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      display: block;
      pointer-events: none;
      z-index: 0;
    }
    #c {
      width: 1024px;
      height: 1024px;
      background: transparent;
      display: block;
      position: relative;
      z-index: 1;
      -webkit-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
    }
    #game-container {
      position: relative;
      display: flex;
      align-items: center;
    }
    #rewind-bar-container {
      position: absolute;
      left: calc(1024px + 1024px * 2 / 15);
      top: 5%;
      width: calc(1024px / 15);
      height: calc(1024px * 0.9);
      background: rgba(255, 255, 255, 0.08);
      border-radius: 4px;
      overflow: hidden;
    }
    #rewind-bar-container .segment {
      position: absolute;
      left: 0;
      right: 0;
      border-radius: 2px;
    }
    .hud {
      position: absolute;
      top: 16px;
      left: 50%;
      transform: translateX(-50%);
      letter-spacing: 0.08em;
      font-size: 12px;
      text-transform: uppercase;
      text-align: center;
      color: rgba(229, 236, 255, 0.6);
      pointer-events: none;
      text-shadow: 0 1px 8px rgba(0,0,0,0.35);
      z-index: 2;
      -webkit-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
    }
    /* Embedded mode (MarbLD) - scale down to show canvas + rewind bar */
    body.embedded {
      place-items: start center;
      padding-top: 10px;
    }
    body.embedded .hud,
    body.embedded #stars {
      display: none;
    }
    body.embedded #game-container {
      transform: scale(0.7);
      transform-origin: top center;
    }
    /* Level picker overlay */
    #level-picker {
      position: fixed;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
      background: radial-gradient(circle at 30% 20%, rgba(12, 18, 36, 0.95) 0%, rgba(5, 9, 21, 0.98) 55%);
    }
    #level-picker.hidden {
      display: none;
    }
    #level-picker h1 {
      font-size: 2.5rem;
      font-weight: 300;
      letter-spacing: 0.2em;
      margin-bottom: 0.5rem;
      background: linear-gradient(135deg, #6ea8fe 0%, #a78bfa 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    #level-picker p {
      font-size: 0.95rem;
      color: rgba(229, 236, 255, 0.6);
      margin-bottom: 2rem;
      text-align: center;
      max-width: 400px;
      line-height: 1.6;
    }
    #level-picker .picker-box {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
      padding: 2rem 3rem;
      border: 2px dashed rgba(110, 168, 254, 0.3);
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.02);
      transition: all 0.2s ease;
    }
    #level-picker .picker-box:hover,
    #level-picker .picker-box.dragover {
      border-color: rgba(110, 168, 254, 0.6);
      background: rgba(110, 168, 254, 0.05);
    }
    #level-picker .picker-box svg {
      width: 48px;
      height: 48px;
      stroke: rgba(110, 168, 254, 0.5);
    }
    #level-picker .picker-box span {
      color: rgba(229, 236, 255, 0.5);
      font-size: 0.9rem;
    }
    #level-picker button {
      padding: 0.75rem 2rem;
      font-size: 1rem;
      font-weight: 500;
      color: #e5ecff;
      background: linear-gradient(135deg, rgba(110, 168, 254, 0.2) 0%, rgba(167, 139, 250, 0.2) 100%);
      border: 1px solid rgba(110, 168, 254, 0.3);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    #level-picker button:hover {
      background: linear-gradient(135deg, rgba(110, 168, 254, 0.3) 0%, rgba(167, 139, 250, 0.3) 100%);
      border-color: rgba(110, 168, 254, 0.5);
    }
    #level-picker input[type="file"] {
      display: none;
    }
    #level-picker .error {
      color: #f87171;
      font-size: 0.85rem;
      margin-top: 1rem;
    }
    /* Mobile support */
    #c {
      touch-action: none;
    }
    body {
      overscroll-behavior: none;
    }
    @media (max-width: 1100px) {
      #c {
        width: 100vw !important;
        height: 100vw !important;
        max-height: 100dvh !important;
        max-width: 100dvh !important;
      }
      #rewind-bar-container {
        display: none !important;
      }
      #game-container {
        width: 100vw;
        max-width: 100dvh;
        margin: 0 auto;
      }
      body {
        height: 100dvh;
        overflow: hidden;
        place-items: center;
      }
    }
    /* Mobile start overlay for gyro permission */
    #mobile-start-overlay {
      position: fixed;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 99;
      background: radial-gradient(circle at 30% 20%, rgba(12, 18, 36, 0.98) 0%, rgba(5, 9, 21, 0.99) 55%);
    }
    #mobile-start-overlay.hidden {
      display: none;
    }
    #mobile-start-overlay h2 {
      font-size: 1.8rem;
      font-weight: 300;
      letter-spacing: 0.15em;
      margin-bottom: 1rem;
      background: linear-gradient(135deg, #6ea8fe 0%, #a78bfa 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    #mobile-start-overlay p {
      font-size: 0.9rem;
      color: rgba(229, 236, 255, 0.6);
      margin-bottom: 2rem;
      text-align: center;
      max-width: 300px;
      line-height: 1.6;
    }
    #mobile-start-btn {
      padding: 1rem 3rem;
      font-size: 1.2rem;
      font-weight: 500;
      color: #e5ecff;
      background: linear-gradient(135deg, rgba(110, 168, 254, 0.3) 0%, rgba(167, 139, 250, 0.3) 100%);
      border: 2px solid rgba(110, 168, 254, 0.5);
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    #mobile-start-btn:active {
      background: linear-gradient(135deg, rgba(110, 168, 254, 0.5) 0%, rgba(167, 139, 250, 0.5) 100%);
      transform: scale(0.98);
    }
  </style>
</head>
<body>
  <canvas id="stars"></canvas>
  <div class="hud" id="hud">WASD to tilt<br>SPACE to rewind</div>
  <div id="mobile-start-overlay" class="hidden">
    <h2>MARBL</h2>
    <p>Tilt your device to roll the marble.<br>Tap anywhere to rewind time.</p>
    <button id="mobile-start-btn">Start Game</button>
  </div>
  <div id="game-container">
    <canvas id="c" width="1024" height="1024"></canvas>
    <div id="rewind-bar-container"></div>
  </div>
  <div id="level-picker">
    <h1>MARBL</h1>
    <p>No levels found. Load a level file to start playing, or place <code>marbl-levels.js</code> in the same directory.</p>
    <div class="picker-box">
      <svg viewBox="0 0 24 24" fill="none" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
        <polyline points="17 8 12 3 7 8"/>
        <line x1="12" y1="3" x2="12" y2="15"/>
      </svg>
      <span>Drag &amp; drop a .js level file here</span>
      <span>or</span>
      <button id="level-picker-btn">Choose File</button>
      <input type="file" id="level-file-input" accept=".js">
    </div>
    <div id="level-picker-error" class="error"></div>
  </div>
  <script>
    /*
     * MARBL - A marble rolling puzzle game with multi-level progression
     *
     * GAME CONCEPT:
     * Roll a marble through levels by tilting the board (WASD/arrows) and rewind time (spacebar).
     * Collect orbs to collapse pedestals and reveal holes to the next level. Some orbs and pedestals
     * are "wild" and persist through time rewind.
     *
     * LEVEL LOADING:
     * Levels are loaded externally - no built-in levels included.
     * - Auto-loads marbl-levels.js if present in the same directory
     * - Otherwise shows a file picker to load a .js level file
     * - Can also receive levels via postMessage (embedded in MarbLD editor)
     *
     * KEY SYSTEMS:
     * - Physics: Tilt-based acceleration, gravity, friction, wall/pedestal collision
     * - Support system: findSupportSurface/calculateSupport determine what surface the marble is on
     * - Collapse system: Pedestals collapse when orb requirements met (exactOrbs = no more, no less)
     * - Rendering: WebGL2 with per-level fade transitions, hole masking in shaders
     * - History/Rewind: Full state snapshots allow time reversal (wild orbs exempt)
     *
     * GEOMETRY:
     * - Levels are 920 units apart vertically (levelDrop)
     * - Pedestals: frustum shapes with ramps, arranged in 3x3 grid
     * - Walls: Hollow frame meshes (createWallFrame) for clean transparency
     * - Orbs: Spheres with orbiting satellites, follow marble when collected
     *
     * COORDINATES: Y is up, levels stack downward (negative Y), camera looks from above
     */

    const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
    const starCanvas = document.getElementById('stars');
    const canvas = document.getElementById('c');
    const starCtx = starCanvas.getContext('2d');
    const gl = canvas.getContext('webgl2', { antialias: true, alpha: true });
    if (!gl) {
      alert('WebGL2 not supported');
      throw new Error('WebGL2 not supported');
    }

    // Handle WebGL context loss and restoration
    canvas.addEventListener('webglcontextlost', (e) => {
      e.preventDefault();
      console.warn('WebGL context lost');
    });
    canvas.addEventListener('webglcontextrestored', () => {
      console.log('WebGL context restored, reloading...');
      location.reload();
    });

    // ===========================================
    // MarbLD INTEGRATION - External level editor API
    // ===========================================
    let externalLevelConfigs = null;
    const isEmbedded = window.parent !== window;

    // Notify parent when ready and apply embedded styling
    if (isEmbedded) {
      document.body.classList.add('embedded');
      window.parent.postMessage({ type: 'marbl-ready' }, '*');
    }

    // Listen for level config updates from MarbLD editor
    window.addEventListener('message', (e) => {
      if (e.data?.type === 'marbl-load-levels') {
        externalLevelConfigs = e.data.levels;
        if (typeof reloadWithConfigs === 'function') {
          reloadWithConfigs(externalLevelConfigs, e.data.preserveLevel, e.data.hotReload);
        }
        // Ensure animation loop is running after reload
        if (typeof resumeLoop === 'function') {
          resumeLoop();
        }
      }
      if (e.data?.type === 'marbl-preview-level') {
        // Jump to a specific level for preview
        if (typeof jumpToLevel === 'function') {
          jumpToLevel(e.data.levelIndex);
        }
        // Ensure animation loop is running
        if (typeof resumeLoop === 'function') {
          resumeLoop();
        }
      }
    });

    const rewindBarContainer = document.getElementById('rewind-bar-container');
    let levelColorsCSS = []; // Populated from level configs in rebuildDerivedArrays()

    function updateRewindBar() {
      // Compute segments from history, tracking fall frames (transition > 0)
      const segments = [];
      const fallThreshold = 0.05; // ignore small dips when marble is on the edge
      for (let i = 0; i < history.length; i++) {
        const lvl = history[i].levelIndex ?? 0;
        const trans = history[i].levelTransition ?? 0;
        const isFalling = trans > fallThreshold;
        if (segments.length === 0 || segments[segments.length - 1].level !== lvl) {
          segments.push({ level: lvl, count: 1, fallFrames: isFalling ? 1 : 0 });
        } else {
          const seg = segments[segments.length - 1];
          seg.count++;
          if (isFalling) seg.fallFrames++;
        }
      }

      // Update DOM - reuse existing segment divs where possible
      while (rewindBarContainer.children.length > segments.length) {
        rewindBarContainer.removeChild(rewindBarContainer.lastChild);
      }
      while (rewindBarContainer.children.length < segments.length) {
        const div = document.createElement('div');
        div.className = 'segment';
        rewindBarContainer.appendChild(div);
      }

      // Position segments from bottom to top
      const totalFrames = maxHistoryFrames;
      let bottomOffset = 0;
      for (let i = 0; i < segments.length; i++) {
        const seg = segments[i];
        const segmentHeight = (seg.count / totalFrames) * 100;
        const div = rewindBarContainer.children[i];
        div.style.bottom = bottomOffset + '%';
        div.style.height = segmentHeight + '%';
        const currentColor = levelColorsCSS[seg.level] || levelColorsCSS[0];

        // Apply gradient only to the falling portion at the top of the segment
        const nextLevel = seg.level + 1;
        if (seg.fallFrames > 0 && nextLevel < levelColorsCSS.length) {
          const nextColor = levelColorsCSS[nextLevel];
          // Solid portion is the non-falling frames at the bottom
          const solidPortion = ((seg.count - seg.fallFrames) / seg.count) * 100;
          div.style.background = `linear-gradient(to top, ${currentColor} ${solidPortion}%, ${nextColor})`;
        } else {
          div.style.background = currentColor;
        }
        bottomOffset += segmentHeight;
      }
    }

    const starConfig = {
      density: 0.00014,
      minSpeed: 8,
      maxSpeed: 18,
      minSize: 0.6,
      maxSize: 1.6,
      margin: 32
    };
    const stars = [];
    let starTargetCount = 0;
    let starAreaWidth = 0;
    let starAreaHeight = 0;

    function resetStar(star, anywhere=false) {
      const w = starAreaWidth || window.innerWidth;
      const h = starAreaHeight || window.innerHeight;
      const margin = starConfig.margin;
      const speed = starConfig.minSpeed + Math.random() * (starConfig.maxSpeed - starConfig.minSpeed);
      star.size = starConfig.minSize + Math.random() * (starConfig.maxSize - starConfig.minSize);
      star.alpha = 0.25 + Math.random() * 0.45;
      let angle = Math.random() * Math.PI * 2;
      if (!anywhere) {
        const side = Math.floor(Math.random() * 4);
        const spread = Math.PI / 3;
        switch (side) {
          case 0: star.x = -margin; star.y = Math.random() * h; angle = 0; break;
          case 1: star.x = w + margin; star.y = Math.random() * h; angle = Math.PI; break;
          case 2: star.x = Math.random() * w; star.y = -margin; angle = Math.PI / 2; break;
          default: star.x = Math.random() * w; star.y = h + margin; angle = -Math.PI / 2; break;
        }
        angle += (Math.random() - 0.5) * spread;
      } else {
        star.x = Math.random() * w;
        star.y = Math.random() * h;
      }
      star.vx = Math.cos(angle) * speed;
      star.vy = Math.sin(angle) * speed;
    }

    function makeStar(fillArea=false) {
      const s = { x: 0, y: 0, vx: 0, vy: 0, size: 1, alpha: 1 };
      resetStar(s, fillArea);
      return s;
    }

    function adjustStarCount(fillArea=false) {
      if (stars.length > starTargetCount) {
        stars.length = starTargetCount;
      } else {
        while (stars.length < starTargetCount) stars.push(makeStar(fillArea));
      }
    }

    function resizeStars() {
      const dpr = window.devicePixelRatio || 1;
      starAreaWidth = window.innerWidth;
      starAreaHeight = window.innerHeight;
      starCanvas.style.width = `${starAreaWidth}px`;
      starCanvas.style.height = `${starAreaHeight}px`;
      starCanvas.width = Math.round(starAreaWidth * dpr);
      starCanvas.height = Math.round(starAreaHeight * dpr);
      starCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
      starTargetCount = Math.max(80, Math.floor(starAreaWidth * starAreaHeight * starConfig.density));
      adjustStarCount(true);
    }

    function updateStars(dt) {
      const w = starAreaWidth;
      const h = starAreaHeight;
      const margin = starConfig.margin;
      for (const s of stars) {
        s.x += s.vx * dt;
        s.y += s.vy * dt;
        if (s.x < -margin || s.x > w + margin || s.y < -margin || s.y > h + margin) {
          resetStar(s);
        }
      }
    }

    function drawStars() {
      starCtx.clearRect(0, 0, starAreaWidth, starAreaHeight);
      starCtx.fillStyle = '#d7e1ff';
      for (const s of stars) {
        starCtx.globalAlpha = s.alpha;
        starCtx.beginPath();
        starCtx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
        starCtx.fill();
      }
      starCtx.globalAlpha = 1;
    }

    // HiDPI handling
    function resize() {
      const dpr = window.devicePixelRatio || 1;
      let displayW, displayH;
      if (isMobile) {
        // Square canvas filling the smaller screen dimension
        const size = Math.min(window.innerWidth, window.innerHeight);
        displayW = size;
        displayH = size;
      } else {
        displayW = 1024;
        displayH = 1024;
      }
      canvas.style.width = `${displayW}px`;
      canvas.style.height = `${displayH}px`;
      canvas.width = displayW * dpr;
      canvas.height = displayH * dpr;
      gl.viewport(0, 0, canvas.width, canvas.height);
      resizeStars();
    }
    resize();
    window.addEventListener('resize', resize);

    // Math helpers
    function normalize3(v) {
      const len = Math.hypot(v.x, v.y, v.z || 0) || 1;
      return { x: v.x / len, y: v.y / len, z: (v.z || 0) / len };
    }
    function clamp01(v) {
      return Math.max(0, Math.min(1, v));
    }
    function smoothstep01(t) {
      const x = clamp01(t);
      return x * x * (3 - 2 * x);
    }
    function mat4Identity() {
      const out = new Float32Array(16);
      out[0]=1; out[5]=1; out[10]=1; out[15]=1;
      return out;
    }
    function mat4Multiply(a,b){
      const out=new Float32Array(16);
      const a00=a[0], a01=a[1], a02=a[2], a03=a[3];
      const a10=a[4], a11=a[5], a12=a[6], a13=a[7];
      const a20=a[8], a21=a[9], a22=a[10],a23=a[11];
      const a30=a[12],a31=a[13],a32=a[14],a33=a[15];

      const b00=b[0], b01=b[1], b02=b[2], b03=b[3];
      const b10=b[4], b11=b[5], b12=b[6], b13=b[7];
      const b20=b[8], b21=b[9], b22=b[10],b23=b[11];
      const b30=b[12],b31=b[13],b32=b[14],b33=b[15];

      out[0]=a00*b00 + a10*b01 + a20*b02 + a30*b03;
      out[1]=a01*b00 + a11*b01 + a21*b02 + a31*b03;
      out[2]=a02*b00 + a12*b01 + a22*b02 + a32*b03;
      out[3]=a03*b00 + a13*b01 + a23*b02 + a33*b03;

      out[4]=a00*b10 + a10*b11 + a20*b12 + a30*b13;
      out[5]=a01*b10 + a11*b11 + a21*b12 + a31*b13;
      out[6]=a02*b10 + a12*b11 + a22*b12 + a32*b13;
      out[7]=a03*b10 + a13*b11 + a23*b12 + a33*b13;

      out[8]=a00*b20 + a10*b21 + a20*b22 + a30*b23;
      out[9]=a01*b20 + a11*b21 + a21*b22 + a31*b23;
      out[10]=a02*b20 + a12*b21 + a22*b22 + a32*b23;
      out[11]=a03*b20 + a13*b21 + a23*b22 + a33*b23;

      out[12]=a00*b30 + a10*b31 + a20*b32 + a30*b33;
      out[13]=a01*b30 + a11*b31 + a21*b32 + a31*b33;
      out[14]=a02*b30 + a12*b31 + a22*b32 + a32*b33;
      out[15]=a03*b30 + a13*b31 + a23*b32 + a33*b33;
      return out;
    }
    function mat4Translate(m,[x,y,z]){
      const out = mat4Identity();
      out[12]=x; out[13]=y; out[14]=z;
      return mat4Multiply(m,out);
    }
    function mat4Scale(m,[x,y,z]){
      const out = mat4Identity();
      out[0]=x; out[5]=y; out[10]=z;
      return mat4Multiply(m,out);
    }
    function mat4RotateX(m,rad){
      const c=Math.cos(rad),s=Math.sin(rad);
      const r=mat4Identity();
      r[5]=c; r[9]=-s; r[6]=s; r[10]=c;
      return mat4Multiply(m,r);
    }
    function mat4RotateZ(m,rad){
      const c=Math.cos(rad),s=Math.sin(rad);
      const r=mat4Identity();
      r[0]=c; r[4]=-s; r[1]=s; r[5]=c;
      return mat4Multiply(m,r);
    }
    function rotateAroundAxis(v, axis, angle){
      const {x:ax,y:ay,z:az}=normalize3(axis);
      const cos=Math.cos(angle), sin=Math.sin(angle);
      return {
        x: v.x*cos + (ay*v.z - az*v.y)*sin + ax*(ax*v.x + ay*v.y + az*v.z)*(1-cos),
        y: v.y*cos + (az*v.x - ax*v.z)*sin + ay*(ax*v.x + ay*v.y + az*v.z)*(1-cos),
        z: v.z*cos + (ax*v.y - ay*v.x)*sin + az*(ax*v.x + ay*v.y + az*v.z)*(1-cos)
      };
    }
    function satelliteOffset(sat, time, index=0){
      if (!sat) return { x: 0, y: 0, z: 0 };
      const angle = time * sat.speed + sat.phase;
      const dir = rotateAroundAxis(sat.base, sat.axis, angle);
      return {
        x: dir.x,
        y: dir.y * 0.3 + 2 * Math.sin(time * 3 + index),
        z: dir.z
      };
    }
    function orbGlowPulse(orb, time){
      // Mild breathing so flashes start from current glow
      return 1 + 0.12 * Math.sin(time * 3 + (orb.seed || 0));
    }
    function orbFlashEnvelope(flashNorm=0){
      const t = clamp01(1 - clamp01(flashNorm)); // 0 at start, 1 at end
      return Math.sin(Math.PI * t); // smooth attack/decay bell
    }
    function mat4Perspective(fov,aspect,near,far){
      const f=1/Math.tan(fov/2);
      const nf=1/(near-far);
      const out=new Float32Array(16);
      out[0]=f/aspect;
      out[5]=f;
      out[10]=(far+near)*nf;
      out[11]=-1;
      out[14]=(2*far*near)*nf;
      out[15]=0;
      out[1]=out[2]=out[3]=out[4]=out[6]=out[7]=out[8]=out[9]=out[12]=out[13]=0;
      return out;
    }
    function mat4FromNormal(n){
      // Build a basis where Y aligns with the surface normal
      let tangent = { x: n.z, y: 0, z: -n.x };
      let len = Math.hypot(tangent.x, tangent.y, tangent.z);
      if (len < 1e-3) tangent = { x: 1, y: 0, z: 0 };
      else tangent = { x: tangent.x/len, y: tangent.y/len, z: tangent.z/len };
      const bitangent = normalize3({
        x: n.y * tangent.z - n.z * tangent.y,
        y: n.z * tangent.x - n.x * tangent.z,
        z: n.x * tangent.y - n.y * tangent.x
      });
      const out = mat4Identity();
      out[0]=tangent.x; out[1]=tangent.y; out[2]=tangent.z;
      out[4]=n.x; out[5]=n.y; out[6]=n.z;
      out[8]=bitangent.x; out[9]=bitangent.y; out[10]=bitangent.z;
      return out;
    }
    function mat4LookAt(eye, target, up){
      // Forward from eye toward target (camera look direction)
      let zx=eye.x-target.x, zy=eye.y-target.y, zz=eye.z-target.z;
      let len=Math.hypot(zx,zy,zz);
      if(len===0){zz=1; len=1;}
      zx/=len; zy/=len; zz/=len;
      // Right = forward x up
      let xx=up.y*zz-up.z*zy;
      let xy=up.z*zx-up.x*zz;
      let xz=up.x*zy-up.y*zx;
      len=Math.hypot(xx,xy,xz)||1;
      xx/=len; xy/=len; xz/=len;
      // Recomputed up = right x forward
      const yx=zy*xz-zz*xy;
      const yy=zz*xx-zx*xz;
      const yz=zx*xy-zy*xx;
      const out=mat4Identity();
      out[0]=xx; out[1]=xy; out[2]=xz;
      out[4]=yx; out[5]=yy; out[6]=yz;
      out[8]=zx; out[9]=zy; out[10]=zz;
      out[12]=-(xx*eye.x + xy*eye.y + xz*eye.z);
      out[13]=-(yx*eye.x + yy*eye.y + yz*eye.z);
      out[14]=-(zx*eye.x + zy*eye.y + zz*eye.z);
      return out;
    }
    function mat4TransformVec4(m, v){
      return [
        m[0]*v[0] + m[4]*v[1] + m[8]*v[2] + m[12]*v[3],
        m[1]*v[0] + m[5]*v[1] + m[9]*v[2] + m[13]*v[3],
        m[2]*v[0] + m[6]*v[1] + m[10]*v[2] + m[14]*v[3],
        m[3]*v[0] + m[7]*v[1] + m[11]*v[2] + m[15]*v[3]
      ];
    }
    function transformDirection(m, v){
      return normalize3({
        x: m[0]*v.x + m[4]*v.y + m[8]*v.z,
        y: m[1]*v.x + m[5]*v.y + m[9]*v.z,
        z: m[2]*v.x + m[6]*v.y + m[10]*v.z
      });
    }
    function mat4Invert(a){
      const out=new Float32Array(16);
      const a00=a[0], a01=a[1], a02=a[2], a03=a[3];
      const a10=a[4], a11=a[5], a12=a[6], a13=a[7];
      const a20=a[8], a21=a[9], a22=a[10], a23=a[11];
      const a30=a[12], a31=a[13], a32=a[14], a33=a[15];

      const b00 = a00 * a11 - a01 * a10;
      const b01 = a00 * a12 - a02 * a10;
      const b02 = a00 * a13 - a03 * a10;
      const b03 = a01 * a12 - a02 * a11;
      const b04 = a01 * a13 - a03 * a11;
      const b05 = a02 * a13 - a03 * a12;
      const b06 = a20 * a31 - a21 * a30;
      const b07 = a20 * a32 - a22 * a30;
      const b08 = a20 * a33 - a23 * a30;
      const b09 = a21 * a32 - a22 * a31;
      const b10 = a21 * a33 - a23 * a31;
      const b11 = a22 * a33 - a23 * a32;

      let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
      if (!det) return mat4Identity();
      det = 1.0 / det;

      out[0] = ( a11 * b11 - a12 * b10 + a13 * b09) * det;
      out[1] = (-a01 * b11 + a02 * b10 - a03 * b09) * det;
      out[2] = ( a31 * b05 - a32 * b04 + a33 * b03) * det;
      out[3] = (-a21 * b05 + a22 * b04 - a23 * b03) * det;
      out[4] = (-a10 * b11 + a12 * b08 - a13 * b07) * det;
      out[5] = ( a00 * b11 - a02 * b08 + a03 * b07) * det;
      out[6] = (-a30 * b05 + a32 * b02 - a33 * b01) * det;
      out[7] = ( a20 * b05 - a22 * b02 + a23 * b01) * det;
      out[8] = ( a10 * b10 - a11 * b08 + a13 * b06) * det;
      out[9] = (-a00 * b10 + a01 * b08 - a03 * b06) * det;
      out[10]= ( a30 * b04 - a31 * b02 + a33 * b00) * det;
      out[11]= (-a20 * b04 + a21 * b02 - a23 * b00) * det;
      out[12]= (-a10 * b09 + a11 * b07 - a12 * b06) * det;
      out[13]= ( a00 * b09 - a01 * b07 + a02 * b06) * det;
      out[14]= (-a30 * b03 + a31 * b01 - a32 * b00) * det;
      out[15]= ( a20 * b03 - a21 * b01 + a22 * b00) * det;
      return out;
    }
    function mat4Transpose(m){
      const out=new Float32Array(16);
      out[0]=m[0]; out[1]=m[4]; out[2]=m[8]; out[3]=m[12];
      out[4]=m[1]; out[5]=m[5]; out[6]=m[9]; out[7]=m[13];
      out[8]=m[2]; out[9]=m[6]; out[10]=m[10]; out[11]=m[14];
      out[12]=m[3]; out[13]=m[7]; out[14]=m[11]; out[15]=m[15];
      return out;
    }

    // Geometry
    function createBox(minX,maxX,minY,maxY,minZ,maxZ){
      const positions=[
        minX,minY,maxZ,  maxX,minY,maxZ,  maxX,maxY,maxZ,  minX,maxY,maxZ, // front
        maxX,minY,minZ,  minX,minY,minZ,  minX,maxY,minZ,  maxX,maxY,minZ, // back
        minX,minY,minZ,  minX,minY,maxZ,  minX,maxY,maxZ,  minX,maxY,minZ, // left
        maxX,minY,maxZ,  maxX,minY,minZ,  maxX,maxY,minZ,  maxX,maxY,maxZ, // right
        minX,maxY,maxZ,  maxX,maxY,maxZ,  maxX,maxY,minZ,  minX,maxY,minZ, // top
        minX,minY,minZ,  maxX,minY,minZ,  maxX,minY,maxZ,  minX,minY,maxZ  // bottom
      ];
      const normals=[
        0,0,1,0,0,1,0,0,1,0,0,1,
        0,0,-1,0,0,-1,0,0,-1,0,0,-1,
        -1,0,0,-1,0,0,-1,0,0,-1,0,0,
        1,0,0,1,0,0,1,0,0,1,0,0,
        0,1,0,0,1,0,0,1,0,0,1,0,
        0,-1,0,0,-1,0,0,-1,0,0,-1,0
      ];
      const indices=[];
      for(let i=0;i<6;i++){
        const o=i*4;
        indices.push(o,o+1,o+2, o,o+2,o+3);
      }
      return {positions,normals,indices};
    }

    function createFrustum(base, top, height, includeBottom=true){
      const hb=base/2, ht=top/2;
      const y0=0, y1=height;
      const positions=[
        -hb,y0,hb,  hb,y0,hb,  ht,y1,ht,  -ht,y1,ht, // front
        hb,y0,hb,  hb,y0,-hb,  ht,y1,-ht,  ht,y1,ht, // right
        hb,y0,-hb, -hb,y0,-hb, -ht,y1,-ht, ht,y1,-ht, // back
        -hb,y0,-hb, -hb,y0,hb, -ht,y1,ht, -ht,y1,-ht, // left
        -ht,y1,ht,  ht,y1,ht,  ht,y1,-ht, -ht,y1,-ht, // top
        -hb,y0,-hb, hb,y0,-hb, hb,y0,hb, -hb,y0,hb    // bottom
      ];
      const normals=[];
      const faceNormals=[
        normalize3({x:0,y:0.6,z:1}),
        normalize3({x:1,y:0.6,z:0}),
        normalize3({x:0,y:0.6,z:-1}),
        normalize3({x:-1,y:0.6,z:0}),
        {x:0,y:1,z:0},
        {x:0,y:-1,z:0}
      ];
      for(const n of faceNormals){
        for(let i=0;i<4;i++) normals.push(n.x,n.y,n.z);
      }
      const indices=[];
      const faceCount = includeBottom ? 6 : 5;
      for(let i=0;i<faceCount;i++){
        const o=i*4;
        indices.push(o,o+1,o+2, o,o+2,o+3);
      }
      return {positions,normals,indices};
    }

    function createSphere(radius, latBands=18, lonBands=18){
      const positions=[], normals=[], indices=[];
      for(let lat=0;lat<=latBands;lat++){
        const theta=lat*Math.PI/latBands;
        const sinT=Math.sin(theta), cosT=Math.cos(theta);
        for(let lon=0;lon<=lonBands;lon++){
          const phi=lon*2*Math.PI/lonBands;
          const sinP=Math.sin(phi), cosP=Math.cos(phi);
          const x=cosP*sinT, y=cosT, z=sinP*sinT;
          positions.push(radius*x, radius*y, radius*z);
          normals.push(x,y,z);
        }
      }
      for(let lat=0;lat<latBands;lat++){
        for(let lon=0;lon<lonBands;lon++){
          const first=lat*(lonBands+1)+lon;
          const second=first+lonBands+1;
          indices.push(first,second,first+1, second,second+1,first+1);
        }
      }
      return {positions,normals,indices};
    }

    // Shaders
    const vsSource=`
    attribute vec3 aPosition;
    attribute vec3 aNormal;
    uniform mat4 uMVP;
    uniform mat4 uModel;
    uniform mat4 uNormalMatrix;
    uniform mat4 uLightSpaceMatrix;
    varying vec3 vNormal;
    varying vec3 vWorldPos;
    varying vec4 vLightSpacePos;
    void main(){
      vNormal = mat3(uNormalMatrix) * aNormal;
      vec4 worldPos = uModel * vec4(aPosition,1.0);
      vWorldPos = worldPos.xyz;
      vLightSpacePos = uLightSpaceMatrix * worldPos;
      gl_Position = uMVP * vec4(aPosition,1.0);
    }`;
    const fsSource=`
    precision highp float;
    varying vec3 vNormal;
    varying vec3 vWorldPos;
    varying vec4 vLightSpacePos;
    uniform vec3 uLightDir;
    uniform vec3 uColor;
    uniform vec3 uAmbient;
    uniform float uAlpha;
    uniform sampler2D uShadowMap;
    uniform float uShadowEnabled;
    const int MAX_POINTS = 12;
    const int MAX_HOLES = 4;
    uniform int uPointCount;
    uniform vec3 uPointPos[MAX_POINTS];
    uniform float uPointIntensity[MAX_POINTS];
    uniform vec3 uPointColor[MAX_POINTS];
    uniform int uHoleCount;
    uniform vec3 uHoleCenters[MAX_HOLES];
    uniform float uHoleRadii[MAX_HOLES];
    uniform float uHoleSoftness[MAX_HOLES];
    uniform vec3 uMarbleCenter;
    uniform float uMarbleRadius;

    // Calculate shadow from a point light blocked by the marble sphere
    // Uses angular geometry for proper circular shadows
    float calcOrbShadow(vec3 lightPos, vec3 fragPos, vec3 sphereCenter, float sphereRadius) {
      vec3 lightToSphere = sphereCenter - lightPos;
      vec3 lightToFrag = fragPos - lightPos;

      float distToSphere = length(lightToSphere);
      float distToFrag = length(lightToFrag);

      // Light too close to or inside sphere - no meaningful shadow
      if (distToSphere < sphereRadius * 1.1) return 1.0;

      // Normalize directions
      vec3 dirToSphere = lightToSphere / distToSphere;
      vec3 dirToFrag = lightToFrag / distToFrag;

      // Check if fragment is in front of the sphere (between light and sphere)
      float projF = dot(lightToFrag, dirToSphere);
      if (projF < distToSphere - sphereRadius) return 1.0;

      // Calculate the angular size of the shadow cone from the light's perspective
      // sin(theta) = radius / distance, where theta is the half-angle of the shadow cone
      float sinTheta = sphereRadius / distToSphere;
      float cosTheta = sqrt(1.0 - sinTheta * sinTheta);

      // Calculate cosine of angle between light-to-sphere and light-to-fragment directions
      float cosAngle = dot(dirToSphere, dirToFrag);

      // Fragment is in shadow cone if cosAngle > cosTheta (angle smaller than cone half-angle)
      // Use smoothstep for soft penumbra edges
      float penumbraWidth = (1.0 - cosTheta) * 0.35;
      float shadow = smoothstep(cosTheta - penumbraWidth, cosTheta + penumbraWidth, cosAngle);

      // Fade shadow for very close orbs (prevents harsh shadows when orb is right next to marble)
      float proximityFade = smoothstep(sphereRadius * 1.2, sphereRadius * 2.5, distToSphere);

      // shadow=1 means in cone, we want to return 0 for shadowed areas
      return 1.0 - shadow * proximityFade;
    }

    float sampleShadow(vec2 uv, float compareDepth) {
      if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) return 1.0;
      float closestDepth = texture2D(uShadowMap, uv).r;
      return compareDepth > closestDepth ? 0.0 : 1.0;
    }

    float calculateShadow() {
      if (uShadowEnabled < 0.5) return 1.0;

      // Perspective divide and transform to [0,1] range
      vec3 projCoords = vLightSpacePos.xyz / vLightSpacePos.w;
      projCoords = projCoords * 0.5 + 0.5;

      // Outside shadow map bounds - no shadow
      if (projCoords.x < 0.0 || projCoords.x > 1.0 ||
          projCoords.y < 0.0 || projCoords.y > 1.0 ||
          projCoords.z > 1.0) {
        return 1.0;
      }

      vec3 n = normalize(vNormal);
      vec3 lightDir = normalize(uLightDir);
      // Bias based on surface angle to light (reduces shadow acne)
      float bias = max(0.003 * (1.0 - dot(n, lightDir)), 0.001);
      float compareDepth = projCoords.z - bias;

      // PCSS-style contact hardening: find average blocker depth
      float texelSize = 1.0 / 2048.0;
      float blockerSum = 0.0;
      float blockerCount = 0.0;
      float searchRadius = 8.0 * texelSize;

      for (int x = -3; x <= 3; x++) {
        for (int y = -3; y <= 3; y++) {
          vec2 offset = vec2(float(x), float(y)) * searchRadius / 3.0;
          float sampleDepth = texture2D(uShadowMap, projCoords.xy + offset).r;
          if (sampleDepth < compareDepth) {
            blockerSum += sampleDepth;
            blockerCount += 1.0;
          }
        }
      }

      // No blockers found - fully lit
      if (blockerCount < 0.5) return 1.0;

      // Calculate penumbra size based on blocker distance
      float avgBlockerDepth = blockerSum / blockerCount;
      float blockerDistance = projCoords.z - avgBlockerDepth;

      // Contact hardening: shadow gets tighter as blocker is closer to receiver
      // penumbraWidth is proportional to distance between blocker and receiver
      float penumbraWidth = max(0.5, blockerDistance * 80.0);
      float filterRadius = penumbraWidth * texelSize;

      // PCF with variable kernel size for soft shadows
      float shadow = 0.0;
      float samples = 0.0;
      for (int x = -3; x <= 3; x++) {
        for (int y = -3; y <= 3; y++) {
          vec2 offset = vec2(float(x), float(y)) * filterRadius / 3.0;
          shadow += sampleShadow(projCoords.xy + offset, compareDepth);
          samples += 1.0;
        }
      }
      shadow /= samples;

      // Smooth shadow strength based on surface facing
      float facingLight = max(0.0, dot(n, lightDir));
      shadow = mix(1.0, shadow, facingLight * 0.85 + 0.15);

      return shadow;
    }

    void main(){
      vec3 n = normalize(vNormal);
      float diff = max(dot(n, normalize(uLightDir)), 0.0);

      // Apply shadow to directional light
      float shadow = calculateShadow();
      vec3 color = uAmbient + uColor * diff * shadow;

      float holeMask = 1.0;
      for (int i=0; i<MAX_HOLES; ++i) {
        if (i >= uHoleCount) break;
        float radius = uHoleRadii[i];
        if (radius <= 0.0) continue;
        vec3 center = uHoleCenters[i];
        vec2 d = abs(vWorldPos.xz - center.xz);
        float dist = max(d.x, d.y);
        float feather = max(uHoleSoftness[i], 0.0001);
        float mask = smoothstep(radius - feather, radius, dist);
        if (dist < radius) discard;
        holeMask = min(holeMask, mask);
      }
      color *= holeMask;
      // Point lights from orbs
      for (int i=0; i<MAX_POINTS; ++i) {
        if (i >= uPointCount) break;
        vec3 L = uPointPos[i] - vWorldPos;
        float dist = length(L) + 1e-4;
        vec3 ld = L / dist;
        float halfLambert = dot(n, ld) * 0.5 + 0.5;
        float diffP = halfLambert * halfLambert;
        float ambient = 0.25;  // Minimum glow regardless of angle
        float lighting = ambient + (1.0 - ambient) * diffP;
        float atten = uPointIntensity[i] / (1.0 + dist * dist * 0.0008);
        // Calculate shadow from marble blocking this orb's light
        float orbShadow = calcOrbShadow(uPointPos[i], vWorldPos, uMarbleCenter, uMarbleRadius);
        color += uPointColor[i] * lighting * atten * orbShadow;
      }
      color = clamp(color, 0.0, 2.5);
      gl_FragColor = vec4(color, uAlpha);
    }`;

    function createShader(type, source){
      const s=gl.createShader(type);
      gl.shaderSource(s, source);
      gl.compileShader(s);
      if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){
        console.error(gl.getShaderInfoLog(s));
      }
      return s;
    }
    const vs=createShader(gl.VERTEX_SHADER, vsSource);
    const fs=createShader(gl.FRAGMENT_SHADER, fsSource);
    const program=gl.createProgram();
    gl.attachShader(program, vs);
    gl.attachShader(program, fs);
    gl.linkProgram(program);
    if(!gl.getProgramParameter(program, gl.LINK_STATUS)){
      console.error(gl.getProgramInfoLog(program));
    }
    gl.useProgram(program);
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

    const attribs={
      position: gl.getAttribLocation(program, 'aPosition'),
      normal: gl.getAttribLocation(program, 'aNormal')
    };
    const uniforms={
      mvp: gl.getUniformLocation(program, 'uMVP'),
      model: gl.getUniformLocation(program, 'uModel'),
      normalMatrix: gl.getUniformLocation(program, 'uNormalMatrix'),
      lightSpaceMatrix: gl.getUniformLocation(program, 'uLightSpaceMatrix'),
      lightDir: gl.getUniformLocation(program, 'uLightDir'),
      color: gl.getUniformLocation(program, 'uColor'),
      ambient: gl.getUniformLocation(program, 'uAmbient'),
      alpha: gl.getUniformLocation(program, 'uAlpha'),
      shadowMap: gl.getUniformLocation(program, 'uShadowMap'),
      shadowEnabled: gl.getUniformLocation(program, 'uShadowEnabled'),
      pointCount: gl.getUniformLocation(program, 'uPointCount'),
      pointPos: gl.getUniformLocation(program, 'uPointPos'),
      pointIntensity: gl.getUniformLocation(program, 'uPointIntensity'),
      pointColor: gl.getUniformLocation(program, 'uPointColor'),
      holeCount: gl.getUniformLocation(program, 'uHoleCount'),
      holeCenters: gl.getUniformLocation(program, 'uHoleCenters[0]'),
      holeRadii: gl.getUniformLocation(program, 'uHoleRadii[0]'),
      holeSoftness: gl.getUniformLocation(program, 'uHoleSoftness[0]'),
      marbleCenter: gl.getUniformLocation(program, 'uMarbleCenter'),
      marbleRadius: gl.getUniformLocation(program, 'uMarbleRadius')
    };
    const MAX_HOLES = 4;
    const MAX_POINT_LIGHTS = 12;
    const holeCentersArr = new Float32Array(MAX_HOLES * 3);
    const holeRadiiArr = new Float32Array(MAX_HOLES);
    const holeSoftnessArr = new Float32Array(MAX_HOLES);

    // ========================================
    // SHADOW MAPPING SETUP
    // ========================================
    const SHADOW_MAP_SIZE = isMobile ? 1024 : 2048;

    // Shadow depth shaders (render from light's perspective)
    const shadowVsSource = `
    attribute vec3 aPosition;
    uniform mat4 uLightMVP;
    void main() {
      gl_Position = uLightMVP * vec4(aPosition, 1.0);
    }`;
    const shadowFsSource = `
    precision mediump float;
    void main() {
      // Depth is written automatically
    }`;

    const shadowVs = createShader(gl.VERTEX_SHADER, shadowVsSource);
    const shadowFs = createShader(gl.FRAGMENT_SHADER, shadowFsSource);
    const shadowProgram = gl.createProgram();
    gl.attachShader(shadowProgram, shadowVs);
    gl.attachShader(shadowProgram, shadowFs);
    gl.linkProgram(shadowProgram);
    if (!gl.getProgramParameter(shadowProgram, gl.LINK_STATUS)) {
      console.error('Shadow program link error:', gl.getProgramInfoLog(shadowProgram));
    }

    const shadowAttribs = {
      position: gl.getAttribLocation(shadowProgram, 'aPosition')
    };
    const shadowUniforms = {
      lightMVP: gl.getUniformLocation(shadowProgram, 'uLightMVP')
    };

    // Create shadow map framebuffer and depth texture
    const shadowFramebuffer = gl.createFramebuffer();
    const shadowDepthTexture = gl.createTexture();

    gl.bindTexture(gl.TEXTURE_2D, shadowDepthTexture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.DEPTH_COMPONENT24, SHADOW_MAP_SIZE, SHADOW_MAP_SIZE, 0, gl.DEPTH_COMPONENT, gl.UNSIGNED_INT, null);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

    gl.bindFramebuffer(gl.FRAMEBUFFER, shadowFramebuffer);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, shadowDepthTexture, 0);

    // Check framebuffer completeness
    const fbStatus = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
    if (fbStatus !== gl.FRAMEBUFFER_COMPLETE) {
      console.error('Shadow framebuffer incomplete:', fbStatus);
    }

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.bindTexture(gl.TEXTURE_2D, null);

    // Light space matrix storage
    let lightSpaceMatrix = mat4Identity();

    // Switch back to main program
    gl.useProgram(program);

    function createMesh(geo){
      const vao=gl.createVertexArray();
      gl.bindVertexArray(vao);

      const pos=gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, pos);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(geo.positions), gl.STATIC_DRAW);
      gl.enableVertexAttribArray(attribs.position);
      gl.vertexAttribPointer(attribs.position,3,gl.FLOAT,false,0,0);

      const nor=gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, nor);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(geo.normals), gl.STATIC_DRAW);
      gl.enableVertexAttribArray(attribs.normal);
      gl.vertexAttribPointer(attribs.normal,3,gl.FLOAT,false,0,0);

      const idx=gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, idx);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(geo.indices), gl.STATIC_DRAW);

      return {vao, count: geo.indices.length};
    }

    // Scene params
    const plane = {
      w: 920,
      h: 920,
      tilt: { x: 0, y: 0 },
      targetTilt: { x: 0, y: 0 },
      maxTilt: 0.8,
      wallHeight: 35,
      wallThickness: 14
    };

    // Wall grid configuration (must match MarbLD)
    const WALL_GRID_SIZE = 16;
    const WALL_CELL_SIZE = plane.w / WALL_GRID_SIZE; // ~57.5 units per cell

    const marble = {
      r: 25,
      pos: { x: 0, z: 0 },
      vel: { x: 0, z: 0 },
      y: 0,
      vy: 0
    };
    const pedestal = {
      topSize: marble.r * (8 / 3),
      ramp: marble.r * (8 / 3),
      height: marble.r * (4 / 3),
      slopeGravity: 420
    };
    const pedestalFootprint = pedestal.topSize * 0.5 + pedestal.ramp;
    const pedestalGridCount = 3;
    // Align pedestal spacing to wall grid for symmetric wall contouring
    const pedestalGridSpacing = WALL_CELL_SIZE * 5; // 287.5 - pedestals at cell boundaries
    const pedestalGrid = {
      count: pedestalGridCount,
      spacing: pedestalGridSpacing
    };
    const pedestalReferencePositions = (() => {
      const arr=[];
      const offset = (pedestalGrid.count - 1) * 0.5;
      for(let i=0;i<pedestalGrid.count;i++){
        for(let j=0;j<pedestalGrid.count;j++){
          arr.push({
            x: (i - offset) * pedestalGrid.spacing,
            z: (j - offset) * pedestalGrid.spacing
          });
        }
      }
      return arr;
    })();
    const levelDrop = plane.w;
    const collapseConfig = { speed: 0.5 };
    const approachFadeDepth = levelDrop * 0.65;
    const centralHoleRadius = pedestalFootprint * 1.05;
    const centralHoleSoftness = pedestal.ramp * 0.35;

    // ===========================================
    // LEVEL CONFIGURATION - Loaded from external JS file
    // ===========================================
    let levelConfigs = [];

    // Default inner wall dimensions (calculated from game geometry)
    const defaultInnerWall = {
      position: pedestalGrid.spacing - pedestalFootprint - pedestal.topSize / 2,
      halfWidth: pedestal.topSize / 2,
      height: pedestal.height
    };

    // Derived arrays (for compatibility with existing code)
    let levels = levelConfigs.map((cfg, i) => {
      const layout = cfg.pedestals.filter(idx => idx >= 0);

      // Handle walls - new grid format or legacy innerWall format
      let walls = null;
      let wallHeight = pedestal.height;
      let wallMeshes = null;

      if (cfg.walls && cfg.walls.length > 0) {
        // New wall grid format
        walls = cfg.walls;
        wallHeight = cfg.wallHeight ?? pedestal.height;
        try {
          wallMeshes = createWallGridMeshes(walls, wallHeight);
        } catch (e) {
          console.error('Error creating wall meshes for level', i, e);
          wallMeshes = [];
        }
      } else if (cfg.innerWall?.enabled) {
        // Legacy innerWall format
        const innerWall = {
          position: cfg.innerWall.position ?? defaultInnerWall.position,
          halfWidth: cfg.innerWall.halfWidth ?? defaultInnerWall.halfWidth,
          height: cfg.innerWall.height ?? defaultInnerWall.height
        };
        wallHeight = innerWall.height;
        wallMeshes = createInnerWallMeshes(innerWall);
        // Convert to walls array for collision
        walls = [];
        const pos = innerWall.position;
        const centerCell = WALL_GRID_SIZE / 2;
        const posCell = Math.round(pos / WALL_CELL_SIZE);
        for (let j = 0; j < WALL_GRID_SIZE; j++) {
          const topRow = Math.round(centerCell - posCell);
          const bottomRow = Math.round(centerCell + posCell - 1);
          if (topRow >= 0 && topRow < WALL_GRID_SIZE) walls.push({ x: j, z: topRow });
          if (bottomRow >= 0 && bottomRow < WALL_GRID_SIZE) walls.push({ x: j, z: bottomRow });
          if (topRow >= 0 && topRow < WALL_GRID_SIZE) walls.push({ x: topRow, z: j });
          if (bottomRow >= 0 && bottomRow < WALL_GRID_SIZE) walls.push({ x: bottomRow, z: j });
        }
      }

      return {
        y: -levelDrop * i,
        hasHole: layout.length > 0,
        index: i,
        pedestalIndices: layout,
        pedestals: layout.map(idx => pedestalReferencePositions[idx]).filter(Boolean),
        walls,
        wallHeight,
        wallMeshes
      };
    });
    let pedestalLayouts = levelConfigs.map(cfg => cfg.pedestals.filter(idx => idx >= 0));
    // Default colors for levels missing color data
    const defaultBoardColors = {
      floor: [0.3, 0.3, 0.6],
      wall: [0.25, 0.25, 0.5],
      pedestal: [0.4, 0.4, 0.7],
      pedestalHole: [0.2, 0.2, 0.4]
    };
    // Ensure each color property exists with fallback to defaults
    function ensureColors(colors) {
      if (!colors) return defaultBoardColors;
      return {
        floor: colors.floor || defaultBoardColors.floor,
        wall: colors.wall || defaultBoardColors.wall,
        pedestal: colors.pedestal || defaultBoardColors.pedestal,
        pedestalHole: colors.pedestalHole || defaultBoardColors.pedestalHole
      };
    }
    let boardColors = levelConfigs.map(cfg => ensureColors(cfg.colors));
    // A level collapses if it has pedestals; orbs needed = number of pedestals
    let pedestalCollapses = levelConfigs
      .map((cfg, i) => pedestalLayouts[i].length > 0 ? {
        levelIndex: i,
        pedestals: pedestalLayouts[i],
        started: false,
        progress: 0,
        wild: cfg.wild,
        exactOrbs: cfg.exactOrbs ?? !cfg.wild
      } : null)
      .filter(Boolean);
    let orbsRequiredForCollapse = pedestalLayouts
      .filter(layout => layout.length > 0)
      .map(layout => layout.length);

    const mouseAttractor = {
      active: false,
      target: { x: 0, z: 0 },
      strength: 480
    };
    const orbConfig = {
      r: 12,
      minCenterDistance: 220,
      touchRadius: 22,
      satelliteCount: 1
    };
    const orbFollowTransition = 0.75;
    const orbCollectFlashDuration = 0.35;
    const followingOrbLift = orbConfig.r * 0.5;
    const orbs = [];
    const keys = new Set();
    // Mobile/gyro state
    let gyroEnabled = false;
    const gyroTilt = { x: 0, y: 0 };
    const gyroSensitivity = 35; // degrees to reach full tilt
    const gyroDeadzone = 2; // degrees
    const history = [];
    const maxHistoryFrames = isMobile ? 600 : 3600; // ~10s mobile, ~60s desktop
    const starHistory = [];
    const maxStarHistoryFrames = 180; // ~3s at 60fps for accurate star reversal
    let starsReversed = false;
    const rewindSpeed = isMobile ? 2.0 : 1.5;
    let historyFrameCounter = 0;
    let rewindAccumulator = 0;
    const orbCollectionDim = { maxCount: 4, minBrightness: 0.3 }; // adjust minBrightness to change how dim orbs get at full collection
    let orbAnimTime = 0;
    let currentSupport = null;
    let lastGroundedLevel = null;
    let lastGroundSurfaceHeight = null;
    let smoothedSupportTilt = 1; // Smoothed support tilt for input to prevent plane wobble
    let smoothedMarbleTilt = 1; // Smoothed marble tilt for rendering
    let paused = false;
    let rafId = null;

    function captureState() {
      return {
        marble: {
          pos: { x: marble.pos.x, z: marble.pos.z },
          vel: { x: marble.vel.x, z: marble.vel.z },
          y: marble.y,
          vy: marble.vy
        },
        plane: {
          tilt: { x: plane.tilt.x, y: plane.tilt.y },
          target: { x: plane.targetTilt.x, y: plane.targetTilt.y }
        },
        mouseAttractor: {
          active: mouseAttractor.active,
          target: { x: mouseAttractor.target.x, z: mouseAttractor.target.z }
        },
        orbs: orbs.map(o => ({
          pos: { x: o.pos.x, y: o.pos.y, z: o.pos.z },
          level: o.level,
          renderLevel: o.renderLevel ?? o.level,
          collected: o.collected,
          collectFlash: o.collectFlash || 0,
          dissolve: o.dissolve,
          following: !!o.following,
          followProgress: o.followProgress ?? 1,
          followStart: o.followStart ? { x: o.followStart.x, y: o.followStart.y, z: o.followStart.z } : null,
          vel: { x: o.vel?.x || 0, y: o.vel?.y || 0, z: o.vel?.z || 0 },
          orbitPhase: o.orbitPhase,
          orbitRadius: o.orbitRadius,
          orbitHeight: o.orbitHeight,
          orbitSpeed: o.orbitSpeed
        })),
        collapses: pedestalCollapses.map(c => ({ started: c.started, progress: c.progress })),
        orbAnimTime,
        levelIndex: getActiveLevel()?.index ?? 0,
        levelTransition: (() => {
          const currentLevel = getActiveLevel();
          const currentIndex = currentLevel?.index ?? 0;
          const nextIndex = currentIndex + 1;
          if (nextIndex >= levels.length) return 0;
          const currentY = currentLevel?.y ?? 0;
          const nextY = levels[nextIndex].y;
          const progress = (currentY - marble.y) / (currentY - nextY);
          return clamp01(progress);
        })()
      };
    }

    function applyState(state) {
      marble.pos.x = state.marble.pos.x;
      marble.pos.z = state.marble.pos.z;
      marble.vel.x = state.marble.vel.x;
      marble.vel.z = state.marble.vel.z;
      marble.y = state.marble.y;
      marble.vy = state.marble.vy;
      plane.tilt.x = state.plane.tilt.x;
      plane.tilt.y = state.plane.tilt.y;
      plane.targetTilt.x = state.plane.target.x;
      plane.targetTilt.y = state.plane.target.y;
      if (state.mouseAttractor) {
        mouseAttractor.active = !!state.mouseAttractor.active;
        mouseAttractor.target.x = state.mouseAttractor.target?.x ?? mouseAttractor.target.x;
        mouseAttractor.target.z = state.mouseAttractor.target?.z ?? mouseAttractor.target.z;
      }
      orbAnimTime = state.orbAnimTime ?? orbAnimTime;
      state.orbs.forEach((o,i) => {
        if (orbs[i]) {
          // Wild orbs stay collected once collected, but still update position for smooth rewind
          if (orbs[i].wild) {
            if (orbs[i].collected) {
              // Always update orbit parameters
              orbs[i].orbitRadius = o.orbitRadius ?? orbs[i].orbitRadius ?? 40;
              orbs[i].orbitHeight = o.orbitHeight ?? orbs[i].orbitHeight ?? 12;
              orbs[i].orbitSpeed = o.orbitSpeed ?? orbs[i].orbitSpeed ?? 1.2;

              if (o.collected) {
                // Historical state also collected - restore position and orbitPhase from history
                orbs[i].pos.x = o.pos.x;
                orbs[i].pos.y = o.pos.y;
                orbs[i].pos.z = o.pos.z;
                orbs[i].orbitPhase = o.orbitPhase ?? orbs[i].orbitPhase ?? 0;
                orbs[i]._rewindPastCollection = false;
                if (o.followStart) {
                  orbs[i].followStart = {
                    x: o.followStart.x ?? orbs[i].pos.x,
                    y: o.followStart.y ?? orbs[i].pos.y,
                    z: o.followStart.z ?? orbs[i].pos.z
                  };
                }
              } else {
                // Rewinding past collection - flag for updateWildOrbs to calculate position
                // Start lerp if this is the first frame past collection
                if (!orbs[i]._rewindPastCollection) {
                  orbs[i]._rewindLerpStart = { x: orbs[i].pos.x, y: orbs[i].pos.y, z: orbs[i].pos.z };
                  orbs[i]._rewindLerpProgress = 0;
                }
                orbs[i]._rewindPastCollection = true;
              }
              orbs[i].vel = { x: 0, y: 0, z: 0 };
            }
            return;
          }
          orbs[i].pos.x = o.pos.x;
          orbs[i].pos.y = o.pos.y;
          orbs[i].pos.z = o.pos.z;
          orbs[i].collected = o.collected;
          orbs[i].collectFlash = o.collectFlash || 0;
          orbs[i].dissolve = o.dissolve || 0;
          orbs[i].level = o.level ?? orbs[i].level;
          orbs[i].renderLevel = o.renderLevel ?? orbs[i].renderLevel ?? orbs[i].level;
          orbs[i].following = !!o.following;
          orbs[i].followProgress = o.followProgress ?? orbs[i].followProgress ?? 1;
          if (o.followStart) {
            orbs[i].followStart = {
              x: o.followStart.x ?? orbs[i].pos.x,
              y: o.followStart.y ?? orbs[i].pos.y,
              z: o.followStart.z ?? orbs[i].pos.z
            };
          } else if (!orbs[i].followStart && o.collected) {
            orbs[i].followStart = { x: orbs[i].pos.x, y: orbs[i].pos.y, z: orbs[i].pos.z };
          }
          const vx = o.vel?.x ?? orbs[i].vel?.x ?? 0;
          const vy = o.vel?.y ?? orbs[i].vel?.y ?? 0;
          const vz = o.vel?.z ?? orbs[i].vel?.z ?? 0;
          orbs[i].vel = { x: vx, y: vy, z: vz };
          orbs[i].orbitPhase = o.orbitPhase ?? orbs[i].orbitPhase ?? 0;
          orbs[i].orbitRadius = o.orbitRadius ?? orbs[i].orbitRadius ?? 40;
          orbs[i].orbitHeight = o.orbitHeight ?? orbs[i].orbitHeight ?? 12;
          orbs[i].orbitSpeed = o.orbitSpeed ?? orbs[i].orbitSpeed ?? 1.2;
        }
      });
      if (Array.isArray(state.collapses)) {
        // Calculate orb count after rewind (wild orbs stay collected, regular orbs restored from history)
        const totalCollectedAfterRewind = orbs.filter(o => o.collected).length;

        state.collapses.forEach((c, i) => {
          if (pedestalCollapses[i]) {
            // Wild pedestals never revert their collapse - once collapsed, stay collapsed
            if (pedestalCollapses[i].wild && pedestalCollapses[i].started) {
              return;
            }

            // During rewind, don't reopen pedestals if orb count doesn't meet requirement
            const collapse = pedestalCollapses[i];
            const required = orbsRequiredForCollapse[collapse.levelIndex] ?? Infinity;
            const meetsRequirement = collapse.exactOrbs
              ? totalCollectedAfterRewind === required
              : totalCollectedAfterRewind >= required;

            // For exactOrbs pedestals, never restore progress directly during rewind.
            // Let updateCollapses handle smooth animation based on orb count.
            // This prevents "popping" when rewinding causes orb count to change.
            if (collapse.exactOrbs) {
              // Ensure started is true if there's any progress, so updateCollapses can animate
              if (collapse.progress > 0 || meetsRequirement) {
                pedestalCollapses[i].started = true;
              }
              return;
            }

            // For non-exactOrbs pedestals, restore progress directly (they don't reverse)
            pedestalCollapses[i].started = !!c.started;
            pedestalCollapses[i].progress = c.progress ?? pedestalCollapses[i].progress;
          }
        });
      }
    }

    function captureStarState() {
      return stars.map(s => ({ x: s.x, y: s.y, vx: s.vx, vy: s.vy, size: s.size, alpha: s.alpha }));
    }

    function applyStarState(starState) {
      stars.length = starState.length;
      for (let i = 0; i < starState.length; i++) {
        const src = starState[i];
        let dst = stars[i];
        if (!dst) dst = stars[i] = { x: 0, y: 0, vx: 0, vy: 0, size: 1, alpha: 1 };
        dst.x = src.x;
        dst.y = src.y;
        dst.vx = src.vx;
        dst.vy = src.vy;
        dst.size = src.size;
        dst.alpha = src.alpha;
      }
    }

    function reverseStarVelocities() {
      for (const star of stars) {
        star.vx = -star.vx;
        star.vy = -star.vy;
      }
    }

    function pushHistory() {
      // On mobile, only record every 2nd frame to reduce memory pressure
      if (isMobile) {
        historyFrameCounter++;
        if (historyFrameCounter % 2 !== 0) return;
      }
      history.push(captureState());
      if (history.length > maxHistoryFrames) history.shift();
      // Separate star history with shorter duration
      starHistory.push(captureStarState());
      if (starHistory.length > maxStarHistoryFrames) starHistory.shift();
    }

    function wouldCrossClosedPedestal(nextState) {
      const nextY = nextState.marble.y;
      const currentY = marble.y;

      // Only check if rewinding upward
      if (nextY <= currentY) return false;

      // Calculate orb count after applying orb state (wild orbs stay collected)
      const totalCollectedAfterRewind = orbs.reduce((count, orb, i) => {
        if (orb.wild && orb.collected) return count + 1;
        return count + (nextState.orbs[i]?.collected ? 1 : 0);
      }, 0);

      // Check if crossing any level boundary going upward
      for (let i = 0; i < levels.length; i++) {
        const level = levels[i];
        const collapse = collapseStateFor(i);
        if (!collapse) continue;

        // Wild pedestals, once opened, always allow passage
        if (collapse.wild && collapse.started) continue;

        const levelY = level.y;
        // Block about a marble's diameter below the hole
        const blockingY = levelY - marble.r * 2;

        // Check if crossing from below to above this level's floor
        if (currentY < blockingY && nextY >= blockingY) {
          const required = orbsRequiredForCollapse[collapse.levelIndex] ?? Infinity;
          const meetsRequirement = collapse.exactOrbs
            ? totalCollectedAfterRewind === required
            : totalCollectedAfterRewind >= required;

          if (!meetsRequirement) {
            return true;
          }
        }
      }

      return false;
    }

    function rewindStep() {
      if (history.length > 1) {
        const nextState = history[history.length - 2];

        // Block rewind if it would cross a closed pedestal opening
        if (nextState && wouldCrossClosedPedestal(nextState)) {
          return true; // blocked
        }

        history.pop(); // discard current
        const restoredState = history[history.length - 1];
        applyState(restoredState);

        // Update lastGroundedLevel to match the restored state's level
        // This prevents stale level references after rewinding mid-fall
        const levelIdx = restoredState.levelIndex ?? 0;
        if (levels[levelIdx]) {
          lastGroundedLevel = levels[levelIdx];
        }
      }
      // Handle star rewind separately
      if (starHistory.length > 1) {
        starHistory.pop();
        applyStarState(starHistory[starHistory.length - 1]);
        starsReversed = false;
      } else if (!starsReversed) {
        // Star history exhausted - reverse velocities for approximate rewind effect
        reverseStarVelocities();
        starsReversed = true;
      }
      return false; // not blocked
    }

    function stopLoop() {
      if (rafId !== null) {
        cancelAnimationFrame(rafId);
        rafId = null;
      }
    }

    function resumeLoop(resetClock=false) {
      if (resetClock) frame.last = performance.now() * 0.001;
      if (rafId === null && !paused) {
        rafId = requestAnimationFrame(frame);
      }
    }

    function setPaused(state) {
      if (state === paused) return;
      paused = state;
      if (paused) {
        stopLoop();
        frame.last = null;
      } else {
        resumeLoop(true);
      }
    }

    function togglePause() {
      setPaused(!paused);
    }

    function checkOrbCollisions() {
      const currentLevelIndex = getActiveLevel()?.index ?? 0;
      for (const orb of orbs) {
        if (orb.level !== currentLevelIndex) continue;
        if (orb.collected) continue;
        const dx = marble.pos.x - orb.pos.x;
        const dz = marble.pos.z - orb.pos.z;
        const dist = Math.hypot(dx, dz);
        const touch = orbConfig.touchRadius || orbConfig.r;
        if (dist <= marble.r + touch) {
          orb.collected = true;
          orb.collectFlash = orbCollectFlashDuration;
          orb.dissolve = 0;
          orb.following = true;
          orb.followProgress = 0;
          orb.followStart = { x: orb.pos.x, y: orb.pos.y, z: orb.pos.z };
          const activeLevel = getActiveLevel();
          orb.renderLevel = activeLevel?.index ?? orb.level;
          const angleToMarble = Math.atan2(orb.pos.z - marble.pos.z, orb.pos.x - marble.pos.x);
          if (!Number.isFinite(orb.orbitPhase)) {
            orb.orbitPhase = Number.isFinite(angleToMarble) ? angleToMarble : Math.random() * Math.PI * 2;
          }
          if (!Number.isFinite(orb.orbitRadius)) orb.orbitRadius = 36 + Math.random() * 12;
          if (!Number.isFinite(orb.orbitHeight)) orb.orbitHeight = 10 + Math.random() * 5;
          if (!Number.isFinite(orb.orbitSpeed)) orb.orbitSpeed = 1 + Math.random() * 0.8;
          if (!orb.vel) orb.vel = { x: 0, y: 0, z: 0 };
        }
      }
    }

    function applyOrbFloorClamp(orb, renderLevelIndex) {
      const level = levels[renderLevelIndex];
      if (!level) return;
      const ground = levelHeightAt(level, orb.pos.x, orb.pos.z);
      if (!Number.isFinite(ground)) return; // let orbs fall through holes
      const levelY = level.y || 0;
      const clearance = (orbConfig.r || 12) * 0.6;
      const floorLocal = (ground - levelY) + clearance;
      const distAbove = orb.pos.y - floorLocal;
      const approachZone = clearance * 3;
      // Feather the downward speed as we approach the floor to avoid hard stops
      if (distAbove < approachZone && orb.vel.y < 0) {
        const t = Math.max(0, Math.min(1, 1 - distAbove / approachZone));
        const damp = 1 - 0.5 * t;
        orb.vel.y *= damp;
      }
      if (distAbove < 0) {
        // Nudge back to the safe band and kill downward velocity
        orb.pos.y = floorLocal;
        if (orb.vel.y < 0) orb.vel.y = 0;
      }
    }

    function updateOrbs(dt) {
      const activeLevel = getActiveLevel() || levels[0];
      const renderLevelIndex = activeLevel?.index ?? 0;
      const renderLevelY = activeLevel?.y || 0;
      for (const orb of orbs) {
        if (!orb.collected) continue;
        orb.following = true;
        orb.dissolve = 0;
        if (orb.collectFlash > 0) {
          orb.collectFlash = Math.max(0, orb.collectFlash - dt);
        }
        const prevRenderLevel = orb.renderLevel ?? renderLevelIndex;
        const prevLevelY = levels[prevRenderLevel]?.y || 0;
        if (prevRenderLevel !== renderLevelIndex) {
          // Preserve world-space height when re-parenting to a new level frame
          const worldY = orb.pos.y + prevLevelY;
          orb.pos.y = worldY - renderLevelY;
        }
        orb.renderLevel = renderLevelIndex;
        const rawProgress = orb.followProgress ?? 1;
        const nextProgress = clamp01(rawProgress + dt / orbFollowTransition);
        orb.followProgress = nextProgress;
        const followEase = smoothstep01(nextProgress);
        if (!orb.vel) orb.vel = { x: 0, y: 0, z: 0 };
        const radius = orb.orbitRadius || 40;
        const speed = orb.orbitSpeed || 1.2;
        const height = orb.orbitHeight || 12;
        orb.orbitPhase = (orb.orbitPhase ?? 0) + dt * speed;
        const angle = orb.orbitPhase;
        const bob = Math.sin(orbAnimTime * 2 + (orb.seed || 0)) * 2;
        const targetX = marble.pos.x + Math.cos(angle) * radius;
        const targetZ = marble.pos.z + Math.sin(angle) * radius;
        const targetY = (marble.y - renderLevelY) + height + bob;
        const anchor = orb.followStart || orb.pos;
        const blendedTargetX = anchor.x + (targetX - anchor.x) * followEase;
        const blendedTargetY = anchor.y + (targetY - anchor.y) * followEase;
        const blendedTargetZ = anchor.z + (targetZ - anchor.z) * followEase;
        const dx = blendedTargetX - orb.pos.x;
        const dy = blendedTargetY - orb.pos.y;
        const dz = blendedTargetZ - orb.pos.z;
        const dist = Math.hypot(dx, dy, dz) || 1;
        const pull = 2000;
        const accel = pull * Math.min(1, dist / 220);
        orb.vel.x += (dx / dist) * accel * dt;
        orb.vel.y += (dy / dist) * accel * dt;
        orb.vel.z += (dz / dist) * accel * dt;
        const drag = Math.exp(-dt * 4);
        orb.vel.x *= drag;
        orb.vel.y *= drag;
        orb.vel.z *= drag;
        orb.pos.x += orb.vel.x * dt;
        orb.pos.y += orb.vel.y * dt;
        orb.pos.z += orb.vel.z * dt;
        applyOrbFloorClamp(orb, renderLevelIndex);
      }
    }

    // Update only wild orbs during rewind - calculates position relative to marble
    function updateWildOrbs(dt) {
      const activeLevel = getActiveLevel() || levels[0];
      const renderLevelIndex = activeLevel?.index ?? 0;
      const renderLevelY = activeLevel?.y || 0;
      for (const orb of orbs) {
        if (!orb.wild || !orb.collected) continue;
        orb.following = true;
        orb.dissolve = 0;
        orb.renderLevel = renderLevelIndex;
        orb.followProgress = 1;
        if (orb.collectFlash > 0) {
          orb.collectFlash = Math.max(0, orb.collectFlash - dt);
        }

        // If rewinding past collection, calculate position relative to marble
        // Otherwise position was restored from history in applyState
        if (orb._rewindPastCollection) {
          const speed = orb.orbitSpeed || 1.2;
          orb.orbitPhase = (orb.orbitPhase ?? 0) - dt * speed;

          const radius = orb.orbitRadius || 40;
          const height = orb.orbitHeight || 12;
          const angle = orb.orbitPhase ?? 0;
          const bob = Math.sin(orbAnimTime * 2 + (orb.seed || 0)) * 2;

          // Target position (where the orb should be relative to marble)
          const targetX = marble.pos.x + Math.cos(angle) * radius;
          const targetZ = marble.pos.z + Math.sin(angle) * radius;
          const targetY = (marble.y - renderLevelY) + height + bob;

          // Lerp from saved start position to target
          const lerpSpeed = 1; // Adjust for faster/slower transition
          orb._rewindLerpProgress = Math.min(1, (orb._rewindLerpProgress ?? 0) + dt * lerpSpeed);
          const t = smoothstep01(orb._rewindLerpProgress);

          if (orb._rewindLerpStart && t < 1) {
            orb.pos.x = orb._rewindLerpStart.x + (targetX - orb._rewindLerpStart.x) * t;
            orb.pos.y = orb._rewindLerpStart.y + (targetY - orb._rewindLerpStart.y) * t;
            orb.pos.z = orb._rewindLerpStart.z + (targetZ - orb._rewindLerpStart.z) * t;
          } else {
            orb.pos.x = targetX;
            orb.pos.y = targetY;
            orb.pos.z = targetZ;
          }
          orb.followStart = { x: orb.pos.x, y: orb.pos.y, z: orb.pos.z };
        }

        orb.vel = { x: 0, y: 0, z: 0 };
      }
    }

    function skipNextOrbBatch() {
      const orb = orbs.find(o => !o.collected);
      if (!orb) return;
      orb.collected = true;
      orb.dissolve = 1;
      console.log(`Debug: skipped orb`);
    }

    function collapseEase(t) {
      const clamped = Math.min(1, Math.max(0, t));
      return clamped * clamped * (3 - 2 * clamped);
    }

    function collapseStateFor(levelIndex=-1, pedestalIdx=null) {
      return pedestalCollapses.find(c => c.levelIndex === levelIndex && (pedestalIdx === null || c.pedestals.includes(pedestalIdx)));
    }

    function collapseProgressFor(levelIndex=-1, pedestalIdx=null) {
      const state = collapseStateFor(levelIndex, pedestalIdx);
      return state && state.started ? collapseEase(state.progress) : 0;
    }

    function pedestalCollapseAlpha(progress) {
      const fadeStart = 0.18; // keep visible while it starts folding, then fade out
      if (progress <= fadeStart) return 1;
      const t = (progress - fadeStart) / (1 - fadeStart);
      return Math.max(0, 1 - t);
    }

    function isWildPedestal(levelIndex) {
      const collapse = pedestalCollapses.find(c => c.levelIndex === levelIndex);
      return collapse?.wild ?? false;
    }

    function pedestalsForLevel(level=null) {
      const positions = level?.pedestals ?? pedestalReferencePositions;
      const indices = level?.pedestalIndices ?? positions.map((_, idx) => idx);
      const count = Math.min(positions.length, indices.length);
      const list = [];
      for (let i=0;i<count;i++) {
        list.push({ pos: positions[i], idx: indices[i] });
      }
      return list;
    }

    function pedestalHeightForIndex(idx, level=null) {
      const levelIndex = level?.index ?? 0;
      const collapseProgress = collapseProgressFor(levelIndex, idx);
      if (collapseProgress > 0) return pedestal.height * (1 - collapseProgress);
      return pedestal.height;
    }

    function pedestalHeightAtLocal(x, z, height=pedestal.height) {
      const halfTop = pedestal.topSize / 2;
      const ramp = pedestal.ramp;
      const maxHalf = halfTop + ramp;
      const dx = Math.abs(x);
      const dz = Math.abs(z);
      if (dx > maxHalf || dz > maxHalf) return -Infinity;
      if (dx <= halfTop && dz <= halfTop) return height;
      const t = Math.max(dx - halfTop, dz - halfTop);
      const ratio = 1 - Math.min(1, t / ramp);
      return height * ratio;
    }
    function pedestalHeightAt(x, z, level=null) {
      const pedestals = pedestalsForLevel(level);
      let maxH = -Infinity;
      for (const { pos, idx } of pedestals) {
        const h = pedestalHeightAtLocal(x - pos.x, z - pos.z, pedestalHeightForIndex(idx, level));
        if (h > maxH) maxH = h;
      }
      return maxH === -Infinity ? 0 : maxH;
    }
    function pedestalNormalAt(x, z, level=null) {
      const eps = 2;
      const h = pedestalHeightAt(x, z, level);
      const hx = pedestalHeightAt(x + eps, z, level) - pedestalHeightAt(x - eps, z, level);
      const hz = pedestalHeightAt(x, z + eps, level) - pedestalHeightAt(x, z - eps, level);
      return normalize3({ x: -hx, y: eps * 2, z: -hz });
    }

    function holesForLevel(level=null) {
      const levelIndex = level?.index ?? -1;
      const state = collapseStateFor(levelIndex);
      if (!state || !state.started) return [];
      const progress = collapseEase(state.progress);
      if (progress <= 0) return [];
      return state.pedestals
        .map(idx => {
          const center = pedestalReferencePositions[idx];
          if (!center) return null;
          return {
            center,
            radius: centralHoleRadius * progress,
            softness: centralHoleSoftness
          };
        })
        .filter(Boolean);
    }

    // Returns hole coverage (0-1) accounting for marble radius for smooth transitions
    function holeOverlapAt(level, x, z) {
      const holes = holesForLevel(level);
      if (!holes.length) return 0;
      let maxOverlap = 0;
      for (const hole of holes) {
        const openRadius = hole.radius - (hole.softness ?? 0) * 0.35;
        if (openRadius <= 0) continue;
        const dx = Math.abs(x - hole.center.x);
        const dz = Math.abs(z - hole.center.z);
        const dist = Math.max(dx, dz);
        // Transition zone: starts when marble center reaches hole edge, longer transition
        const innerEdge = openRadius - marble.r * 0.7;
        const outerEdge = openRadius;
        if (dist <= innerEdge) {
          maxOverlap = 1; // Fully in hole
        } else if (dist < outerEdge) {
          // Gradual transition as marble tips over edge
          const overlap = 1 - (dist - innerEdge) / (outerEdge - innerEdge);
          maxOverlap = Math.max(maxOverlap, overlap);
        }
      }
      return maxOverlap;
    }

    function isPointInHole(level, x, z) {
      return holeOverlapAt(level, x, z) > 0.99;
    }

    function wallHeightAt(level, x, z) {
      const t = plane.wallThickness;
      const h = plane.wallHeight;
      const w = plane.w / 2;
      const hl = plane.h / 2;
      const m = marble.r * 0.6; // margin for stable landing

      // Outer walls - check if on top of any wall (with margin for stability)
      // Back wall: z from hl-m to hl+t
      if (z >= hl - m && z <= hl + t && x >= -w - t && x <= w + t) return h;
      // Front wall: z from -hl-t to -hl+m
      if (z >= -hl - t && z <= -hl + m && x >= -w - t && x <= w + t) return h;
      // Left wall: x from -w-t to -w+m
      if (x >= -w - t && x <= -w + m && z >= -hl + m && z <= hl - m) return h;
      // Right wall: x from w-m to w+t
      if (x >= w - m && x <= w + t && z >= -hl + m && z <= hl - m) return h;

      // Wall grid collision
      if (level.walls && level.walls.length > 0) {
        const cellSize = WALL_CELL_SIZE;
        const halfCell = cellSize / 2;
        const margin = marble.r * 0.5;

        for (const cell of level.walls) {
          // Convert grid coords to world coords (must match createWallGridMeshes)
          const worldX = -(cell.x - WALL_GRID_SIZE / 2 + 0.5) * cellSize;
          const worldZ = -(cell.z - WALL_GRID_SIZE / 2 + 0.5) * cellSize;

          // Check if marble is within this wall cell (with margin for collision)
          if (x >= worldX - halfCell - margin && x <= worldX + halfCell + margin &&
              z >= worldZ - halfCell - margin && z <= worldZ + halfCell + margin) {
            return level.wallHeight;
          }
        }
      }

      return 0; // Not on a wall
    }

    function levelHeightAt(level, x, z) {
      if (level.hasHole && isPointInHole(level, x, z)) return -Infinity;
      const pedestalH = pedestalHeightAt(x, z, level);
      const wallH = wallHeightAt(level, x, z);
      const h = Math.max(pedestalH, wallH);
      return h + level.y;
    }

    function levelNormalAt(level, x, z) {
      const eps = 2;
      const h = levelHeightAt(level, x, z);
      if (!Number.isFinite(h)) return { x: 0, y: 1, z: 0 };
      const hx = levelHeightAt(level, x + eps, z) - levelHeightAt(level, x - eps, z);
      const hz = levelHeightAt(level, x, z + eps) - levelHeightAt(level, x, z - eps);
      return normalize3({ x: -hx, y: eps * 2, z: -hz });
    }

    function findSupportSurface(x, z, y) {
      let best = null;
      const maxRise = marble.r * 1.5;
      for (const level of levels) {
        const surface = levelHeightAt(level, x, z);
        if (!Number.isFinite(surface)) continue;
        if (surface > y + maxRise) continue; // ignore surfaces too far above current height
        if (!best || surface > best.height) {
          best = { level, height: surface };
        }
      }
      return best;
    }

    function calculateSupport(x, z, y) {
      const surface = findSupportSurface(x, z, y);
      const surfaceHeight = surface ? surface.height : -Infinity;
      const groundHeight = Number.isFinite(surfaceHeight) ? surfaceHeight + marble.r : -Infinity;
      const altitude = Number.isFinite(surfaceHeight) ? y - groundHeight : Infinity;
      const support = Number.isFinite(surfaceHeight) ? Math.max(0, Math.min(1, 1 - altitude / (marble.r * 1.5))) : 0;
      return {
        level: surface?.level || levels[0],
        surfaceHeight,
        groundHeight,
        altitude,
        support
      };
    }

    function refreshSupport() {
      currentSupport = calculateSupport(marble.pos.x, marble.pos.z, marble.y);
      if ((currentSupport?.support ?? 0) > 0.01 && Number.isFinite(currentSupport.surfaceHeight)) {
        lastGroundedLevel = currentSupport.level || lastGroundedLevel || levels[0];
        lastGroundSurfaceHeight = currentSupport.surfaceHeight;
      }
      return currentSupport;
    }

    function isAirborne() {
      const support = currentSupport?.support ?? 0;
      return !Number.isFinite(currentSupport?.surfaceHeight) || support < 0.01;
    }

    function updateCollapses(dt) {
      for (const collapse of pedestalCollapses) {
        const totalCollected = orbs.filter(o => o.collected).length;
        const required = orbsRequiredForCollapse[collapse.levelIndex] ?? Infinity;
        const meetsRequirement = collapse.exactOrbs
          ? totalCollected === required
          : totalCollected >= required;
        if (!collapse.started && meetsRequirement) {
          collapse.started = true;
        }
        // For exactOrbs, only progress while requirement is met; reverse if not
        if (collapse.exactOrbs) {
          if (meetsRequirement) {
            collapse.progress = Math.min(1, collapse.progress + dt * collapseConfig.speed);
          } else {
            collapse.progress = Math.max(0, collapse.progress - dt * collapseConfig.speed);
            if (collapse.progress === 0) collapse.started = false;
          }
        } else if (collapse.started) {
          collapse.progress = Math.min(1, collapse.progress + dt * collapseConfig.speed);
        }
      }
    }

    function lightLevelWeight(levelIndex=0) {
      const level = levels[levelIndex];
      if (!level) return 0;
      // Don't light lower levels until we're approaching them or the above level has collapsed
      if (level.index > 0) {
        const aboveCollapse = collapseStateFor(level.index - 1);
        if (!(aboveCollapse?.started ?? false) && marble.y > level.y + approachFadeDepth) return 0;
      }
      const heightAbove = Math.max(0, marble.y - level.y - marble.r * 2);
      const proximity = heightAbove <= 0 ? 1 : Math.max(0, 1 - heightAbove / approachFadeDepth);
      return proximity;
    }

    function collectionBrightnessFactor() {
      const maxCount = Math.max(1, orbCollectionDim.maxCount || 12);
      const minBrightness = Math.max(0, Math.min(1, orbCollectionDim.minBrightness ?? 0.5));
      const collected = orbs.filter(o => o.collected).length;
      const clampedCount = Math.min(maxCount, Math.max(1, collected));
      const t = (clampedCount - 1) / (maxCount - 1 || 1); // 0 when only one orb collected
      return 1 - t * (1 - minBrightness);
    }

    function updateLightsUniforms() {
      const positions = new Float32Array(MAX_POINT_LIGHTS * 3);
      const intensities = new Float32Array(MAX_POINT_LIGHTS);
      const colors = new Float32Array(MAX_POINT_LIGHTS * 3);
      const time = orbAnimTime;
      const collectionFactor = collectionBrightnessFactor();
      const candidates = [];
      for (const orb of orbs) {
        const renderLevelIndex = orb.following ? (orb.renderLevel ?? getActiveLevel()?.index ?? orb.level) : orb.level;
        const weight = lightLevelWeight(renderLevelIndex);
        if (weight <= 0) continue;
        if (orb.collected && orb.dissolve >= 1) continue;
        candidates.push({ orb, renderLevelIndex, weight });
      }
      candidates.sort((a, b) => {
        if (a.weight !== b.weight) return b.weight - a.weight;
        if (a.orb.collected !== b.orb.collected) return a.orb.collected ? 1 : -1;
        return (b.orb.collectFlash || 0) - (a.orb.collectFlash || 0);
      });
      let count = 0;
      for (const { orb, renderLevelIndex, weight } of candidates) {
        if (count >= MAX_POINT_LIGHTS) break;
        const followEase = smoothstep01(clamp01(orb.followProgress ?? 1));
        const brightnessScale = orb.collected ? (1 - 0.5 * followEase) : 1;
        const baseStrength = orb.collected ? Math.max(0, 1 - orb.dissolve) * brightnessScale : 1.0;
        const flash = orb.collectFlash ? clamp01(orb.collectFlash / orbCollectFlashDuration) : 0;
        const flashBoost = orbFlashEnvelope(flash);
        const strength = baseStrength * orbGlowPulse(orb, time) * (1 + flashBoost * 1.0) * weight * collectionFactor;
        const levelY = levels[renderLevelIndex]?.y || 0;
        const satOffset = (orb.sats && orb.sats.length) ? satelliteOffset(orb.sats[0], time, 0) : null;
        const rawX = satOffset ? orb.pos.x + satOffset.x : orb.pos.x;
        const rawY = satOffset ? orb.pos.y + satOffset.y : orb.pos.y;
        const rawZ = satOffset ? orb.pos.z + satOffset.z : orb.pos.z;
        // Transform orb position by board tilt to match floor coordinate space
        const boardM = boardTransform(levelY);
        const transformed = mat4TransformVec4(boardM, [rawX, rawY, rawZ, 1]);
        // Validate position values to prevent NaN in shader
        positions[count*3+0] = Number.isFinite(transformed[0]) ? transformed[0] : 0;
        positions[count*3+1] = Number.isFinite(transformed[1]) ? transformed[1] : 0;
        positions[count*3+2] = Number.isFinite(transformed[2]) ? transformed[2] : 0;
        intensities[count] = Number.isFinite(strength) ? strength : 0;
        // Light color: warm for regular orbs, cycling blue/magenta for wild
        if (orb.wild) {
          const t = time * 0.8 + (orb.seed || 0);
          const wave = Number.isFinite(t) ? (Math.sin(t * Math.PI * 2) + 1) * 0.5 : 0.5;
          colors[count*3+0] = 1.0 + wave * 0.8; // Red: 1.0 to 1.8
          colors[count*3+1] = 0.6;              // More green for brightness
          colors[count*3+2] = 1.8;              // Very strong blue
        } else {
          colors[count*3+0] = 1.1;  // Warm
          colors[count*3+1] = 0.95;
          colors[count*3+2] = 0.5;
        }
        count++;
      }
      gl.uniform1i(uniforms.pointCount, count);
      gl.uniform3fv(uniforms.pointPos, positions);
      gl.uniform1fv(uniforms.pointIntensity, intensities);
      gl.uniform3fv(uniforms.pointColor, colors);

      // Set marble center and radius for orb shadow calculations
      const activeLevel = getActiveLevel();
      const marbleLevelY = activeLevel?.y || 0;
      const marbleBoardM = boardTransform(marbleLevelY);
      const marbleWorld = mat4TransformVec4(marbleBoardM, [marble.pos.x, marble.y - marbleLevelY, marble.pos.z, 1]);
      gl.uniform3f(uniforms.marbleCenter,
        Number.isFinite(marbleWorld[0]) ? marbleWorld[0] : 0,
        Number.isFinite(marbleWorld[1]) ? marbleWorld[1] : 0,
        Number.isFinite(marbleWorld[2]) ? marbleWorld[2] : 0
      );
      gl.uniform1f(uniforms.marbleRadius, marble.r);
    }

    function spawnOrbsForLevel(levelIndex=0, savedOrbs=[]) {
      const level = levels[levelIndex] || levels[0];
      const levelCfg = levelConfigs[levelIndex];
      const margin = marble.r + orbConfig.r * 2 + 20;
      const centerGuard = orbConfig.minCenterDistance;
      let savedOrbIndex = 0; // Track which saved orb to use next
      function randomPos() {
        return {
          x: (Math.random() * 2 - 1) * (plane.w / 2 - margin),
          z: (Math.random() * 2 - 1) * (plane.h / 2 - margin)
        };
      }
      function createOrb(p, isWild, savedOrb=null) {
        const yLocal = (levelHeightAt(level, p.x, p.z) - level.y) + orbConfig.r;
        // Reuse saved orb properties if available, otherwise generate new random ones
        let seed, sats, orbitPhase, orbitRadius, orbitHeight, orbitSpeed;
        if (savedOrb) {
          seed = savedOrb.seed;
          sats = savedOrb.sats;
          orbitPhase = savedOrb.orbitPhase;
          orbitRadius = savedOrb.orbitRadius;
          orbitHeight = savedOrb.orbitHeight;
          orbitSpeed = savedOrb.orbitSpeed;
        } else {
          seed = Math.random() * Math.PI * 2;
          sats=[];
          for(let k=0;k<(orbConfig.satelliteCount || 1);k++){
            // random axis
            let ax=Math.random()*2-1, ay=Math.random()*2-1, az=Math.random()*2-1;
            const axisLen=Math.hypot(ax,ay,az)||1;
            ax/=axisLen; ay/=axisLen; az/=axisLen;
            // base direction orthogonal to axis
            let bx=ay, by=-ax, bz=0;
            if(Math.hypot(bx,by,bz)<1e-3){bx=0; by=az; bz=-ay;}
            const bl=Math.hypot(bx,by,bz)||1;
            bx/=bl; by/=bl; bz/=bl;
            const radius=orbConfig.r*(1.6+Math.random()*0.5);
            const speed=1.4+Math.random()*0.8;
            const phase=Math.random()*Math.PI*2;
            sats.push({axis:{x:ax,y:ay,z:az}, base:{x:bx*radius,y:by*radius,z:bz*radius}, speed, phase});
          }
          orbitPhase = Math.random() * Math.PI * 2;
          orbitRadius = 36 + Math.random() * 12;
          orbitHeight = 10 + Math.random() * 5;
          orbitSpeed = 1 + Math.random() * 0.8;
        }
        orbs.push({
          level: levelIndex,
          renderLevel: levelIndex,
          pos: { x: p.x, y: yLocal, z: p.z },
          collected: savedOrb?.collected || false,
          collectFlash: 0,
          following: false,
          followProgress: 1,
          followStart: null,
          vel: { x: 0, y: 0, z: 0 },
          dissolve: savedOrb?.dissolve || 0,
          seed,
          sats,
          orbitPhase,
          orbitRadius,
          orbitHeight,
          orbitSpeed,
          wild: isWild
        });
      }

      // New format: orbs array with type/position/wild per orb
      if (levelCfg.orbs && Array.isArray(levelCfg.orbs)) {
        for (const orbCfg of levelCfg.orbs) {
          const savedOrb = savedOrbs[savedOrbIndex++]; // Get next saved orb if available
          if (orbCfg.type === 'fixed') {
            // Default x to 250 (outside center guard of 220) if not specified
            createOrb({ x: orbCfg.x ?? 250, z: orbCfg.z ?? 0 }, orbCfg.wild || false, savedOrb);
          } else {
            // Random positioning - reuse saved position if available
            if (savedOrb) {
              createOrb({ x: savedOrb.x, z: savedOrb.z }, orbCfg.wild || false, savedOrb);
            } else {
              // Generate new random position
              let attempts = 0;
              while (attempts < 100) {
                attempts++;
                const p = randomPos();
                if (Math.hypot(p.x, p.z) < centerGuard) continue;
                let ok = true;
                for (const o of orbs) {
                  const dx = o.pos.x - p.x;
                  const dz = o.pos.z - p.z;
                  if (Math.hypot(dx, dz) < (orbConfig.r * 2 + 30)) { ok = false; break; }
                }
                if (ok) {
                  createOrb(p, orbCfg.wild || false);
                  break;
                }
              }
            }
          }
        }
        return;
      }

      // Legacy format: fixedOrb and orbCount
      if (levelCfg.fixedOrb) {
        const savedOrb = savedOrbs[savedOrbIndex++];
        createOrb({ x: levelCfg.fixedOrb.x, z: levelCfg.fixedOrb.z }, levelCfg.fixedOrb.wild, savedOrb);
        return;
      }
      const countForLevel = () => orbs.filter(o => o.level === levelIndex).length;
      const targetCount = levelCfg.orbCount ?? 0;
      while (countForLevel() < targetCount) {
        const savedOrb = savedOrbs[savedOrbIndex++];
        if (savedOrb) {
          // Reuse saved position
          createOrb({ x: savedOrb.x, z: savedOrb.z }, false, savedOrb);
        } else {
          // Generate new random position
          const p = randomPos();
          if (Math.hypot(p.x, p.z) < centerGuard) continue;
          let ok = true;
          for (const o of orbs) {
            const dx = o.pos.x - p.x;
            const dz = o.pos.z - p.z;
            if (Math.hypot(dx, dz) < (orbConfig.r * 2 + 30)) { ok = false; break; }
          }
          if (ok) {
            createOrb(p, false);
          }
        }
      }
    }

    // Geometry instances
    const meshes = {
      floor: createMesh(createBox(-plane.w/2, plane.w/2, -2, 0, -plane.h/2, plane.h/2)),
      walls: createWallMeshes(),
      innerWalls: createInnerWallMeshes(),
      pedestal: createMesh(createFrustum(pedestal.topSize + pedestal.ramp * 2, pedestal.topSize, pedestal.height)),
      pedestalHole: createMesh(createFrustum(pedestal.topSize + pedestal.ramp * 2, pedestal.topSize, pedestal.height, false)),
      marble: createMesh(createSphere(marble.r, 18, 18))
    };

    function createWallFrame(outerW, outerH, innerW, innerH, height) {
      // Create a hollow rectangular frame as a single mesh (no internal seams)
      const ow = outerW / 2, oh = outerH / 2;
      const iw = innerW / 2, ih = innerH / 2;
      const y0 = 0, y1 = height;

      // 16 vertices: 4 outer bottom, 4 outer top, 4 inner bottom, 4 inner top
      const verts = [
        // Outer corners bottom (0-3)
        -ow, y0, -oh,   ow, y0, -oh,   ow, y0, oh,   -ow, y0, oh,
        // Outer corners top (4-7)
        -ow, y1, -oh,   ow, y1, -oh,   ow, y1, oh,   -ow, y1, oh,
        // Inner corners bottom (8-11)
        -iw, y0, -ih,   iw, y0, -ih,   iw, y0, ih,   -iw, y0, ih,
        // Inner corners top (12-15)
        -iw, y1, -ih,   iw, y1, -ih,   iw, y1, ih,   -iw, y1, ih
      ];

      // Build faces with proper normals (each face needs its own vertices for flat shading)
      const positions = [];
      const normals = [];

      function addQuad(v0, v1, v2, v3, nx, ny, nz) {
        // Two triangles with CCW winding when viewed from normal direction
        const p = (i) => [verts[i*3], verts[i*3+1], verts[i*3+2]];
        const [p0, p1, p2, p3] = [p(v0), p(v1), p(v2), p(v3)];
        // Winding: v0-v2-v1 and v0-v3-v2 for correct front-facing
        positions.push(...p0, ...p2, ...p1, ...p0, ...p3, ...p2);
        for (let i = 0; i < 6; i++) normals.push(nx, ny, nz);
      }

      // Outer faces (normals pointing outward)
      addQuad(0, 1, 5, 4, 0, 0, -1);  // front (z = -oh)
      addQuad(2, 3, 7, 6, 0, 0, 1);   // back (z = +oh)
      addQuad(3, 0, 4, 7, -1, 0, 0);  // left (x = -ow)
      addQuad(1, 2, 6, 5, 1, 0, 0);   // right (x = +ow)

      // Inner faces (normals pointing inward toward play area)
      addQuad(9, 8, 12, 13, 0, 0, -1);   // front inner (z = -ih)
      addQuad(11, 10, 14, 15, 0, 0, 1);  // back inner (z = +ih)
      addQuad(8, 11, 15, 12, -1, 0, 0);  // left inner (x = -iw)
      addQuad(10, 9, 13, 14, 1, 0, 0);   // right inner (x = +iw)

      // Top rim (connecting outer top to inner top)
      addQuad(4, 5, 13, 12, 0, 1, 0);   // front rim
      addQuad(6, 7, 15, 14, 0, 1, 0);   // back rim
      addQuad(7, 4, 12, 15, 0, 1, 0);   // left rim
      addQuad(5, 6, 14, 13, 0, 1, 0);   // right rim

      // Bottom rim (connecting outer bottom to inner bottom)
      addQuad(1, 0, 8, 9, 0, -1, 0);    // front rim
      addQuad(3, 2, 10, 11, 0, -1, 0);  // back rim
      addQuad(0, 3, 11, 8, 0, -1, 0);   // left rim
      addQuad(2, 1, 9, 10, 0, -1, 0);   // right rim

      // Generate sequential indices (non-indexed rendering with flat shading)
      const indices = [];
      for (let i = 0; i < positions.length / 3; i++) indices.push(i);

      return { positions: new Float32Array(positions), normals: new Float32Array(normals), indices };
    }

    function createWallMeshes(){
      const t = plane.wallThickness;
      const h = plane.wallHeight;
      const w = plane.w;
      const hl = plane.h;
      // Single unified wall frame mesh
      const frame = createWallFrame(w + t * 2, hl + t * 2, w, hl, h);
      return [createMesh(frame)];
    }

    function createInnerWallMeshes(innerWall = null){
      const cfg = innerWall || defaultInnerWall;
      const p = cfg.position;
      const t = cfg.halfWidth;
      const h = cfg.height;
      // Single unified inner wall frame mesh
      const outerSize = (p + t) * 2;
      const innerSize = (p - t) * 2;
      const frame = createWallFrame(outerSize, outerSize, innerSize, innerSize, h);
      return [createMesh(frame)];
    }

    function createWallGridMeshes(walls, wallHeight = pedestal.height) {
      if (!walls || walls.length === 0) return [];
      const cellSize = WALL_CELL_SIZE;
      const halfCell = cellSize / 2;

      // Build lookup set for quick neighbor checking
      const wallSet = new Set(walls.map(w => `${w.x},${w.z}`));
      const hasWall = (x, z) => wallSet.has(`${x},${z}`);

      const positions = [];
      const normals = [];

      // Helper to add a quad (two triangles)
      function addQuad(p1, p2, p3, p4, nx, ny, nz) {
        // Triangle 1: p1, p2, p3
        positions.push(...p1, ...p2, ...p3);
        normals.push(nx, ny, nz, nx, ny, nz, nx, ny, nz);
        // Triangle 2: p1, p3, p4
        positions.push(...p1, ...p3, ...p4);
        normals.push(nx, ny, nz, nx, ny, nz, nx, ny, nz);
      }

      for (const cell of walls) {
        // Convert grid coords to world coords (negated for 180 degree rotation)
        const cx = -(cell.x - WALL_GRID_SIZE / 2 + 0.5) * cellSize;
        const cz = -(cell.z - WALL_GRID_SIZE / 2 + 0.5) * cellSize;

        const x0 = cx - halfCell, x1 = cx + halfCell;
        const y0 = 0, y1 = wallHeight;
        const z0 = cz - halfCell, z1 = cz + halfCell;

        // Top face (always visible) - CCW winding when viewed from above
        addQuad([x0, y1, z1], [x1, y1, z1], [x1, y1, z0], [x0, y1, z0], 0, 1, 0);

        // Side faces - only if no adjacent wall
        // Note: grid coords are negated when converted to world coords, so neighbor checks are inverted
        // -X world face  check neighbor at cell.x + 1 (increasing grid X = decreasing world X)
        if (!hasWall(cell.x + 1, cell.z)) {
          addQuad([x0, y0, z1], [x0, y1, z1], [x0, y1, z0], [x0, y0, z0], -1, 0, 0);
        }
        // +X world face  check neighbor at cell.x - 1
        if (!hasWall(cell.x - 1, cell.z)) {
          addQuad([x1, y0, z0], [x1, y1, z0], [x1, y1, z1], [x1, y0, z1], 1, 0, 0);
        }
        // -Z world face  check neighbor at cell.z + 1
        if (!hasWall(cell.x, cell.z + 1)) {
          addQuad([x0, y0, z0], [x0, y1, z0], [x1, y1, z0], [x1, y0, z0], 0, 0, -1);
        }
        // +Z world face  check neighbor at cell.z - 1
        if (!hasWall(cell.x, cell.z - 1)) {
          addQuad([x1, y0, z1], [x1, y1, z1], [x0, y1, z1], [x0, y0, z1], 0, 0, 1);
        }
      }

      // Return empty if no geometry was generated
      if (positions.length === 0) return [];

      const geometry = {
        positions: new Float32Array(positions),
        normals: new Float32Array(normals),
        indices: []
      };
      for (let i = 0; i < positions.length / 3; i++) {
        geometry.indices.push(i);
      }

      return [createMesh(geometry)];
    }

    // Camera/light
    const lightDir = normalize3({ x: -0.4, y: 0.8, z: 0.3 });
    // Keep the camera directly overhead for a top-down view; nudge z to avoid colinearity with the up vector
    const camera = {
      pos: { x: 0, y: 1500, z: 1 },
      target: { x: 0, y: 0, z: 0 },
      baseHeight: isMobile ? 1150 : 1500,  // Tighter view on mobile
      followRatio: 0.9,
      smooth: 2.6
    };

    // ========================================
    // SHADOW RENDERING FUNCTIONS
    // ========================================

    function mat4Ortho(left, right, bottom, top, near, far) {
      const lr = 1 / (left - right);
      const bt = 1 / (bottom - top);
      const nf = 1 / (near - far);
      return new Float32Array([
        -2 * lr, 0, 0, 0,
        0, -2 * bt, 0, 0,
        0, 0, 2 * nf, 0,
        (left + right) * lr, (top + bottom) * bt, (far + near) * nf, 1
      ]);
    }

    function calculateLightSpaceMatrix() {
      // Shadow light position in screen coordinates (top-down camera view):
      //   right:  positive = light from right (shadow falls left)
      //   up:     positive = light from top of screen (shadow falls toward bottom)
      //   height: light height above scene (affects shadow length)
      const right = 0.4;
      const up = 0.3;
      const height = 1.0;

      const lightDistance = 2000;
      const lightPos = {
        x: right * lightDistance,
        y: height * lightDistance,
        z: up * lightDistance
      };
      const lightTarget = { x: 0, y: 0, z: 0 };

      // Up vector tilted to match desired shadow orientation
      const lightView = mat4LookAt(lightPos, lightTarget, { x: -0.5, y: 0, z: 1 });

      const orthoSize = 1200;
      const lightProj = mat4Ortho(-orthoSize, orthoSize, -orthoSize, orthoSize, 1, lightDistance * 3);

      return mat4Multiply(lightProj, lightView);
    }

    function renderShadowPass(marbleModel, levelY) {
      // Bind shadow framebuffer
      gl.bindFramebuffer(gl.FRAMEBUFFER, shadowFramebuffer);
      gl.viewport(0, 0, SHADOW_MAP_SIZE, SHADOW_MAP_SIZE);
      gl.clear(gl.DEPTH_BUFFER_BIT);

      // Enable depth testing, disable color write
      gl.enable(gl.DEPTH_TEST);
      gl.depthFunc(gl.LESS);
      gl.colorMask(false, false, false, false);

      // Use shadow program
      gl.useProgram(shadowProgram);

      // Calculate light space matrix
      lightSpaceMatrix = calculateLightSpaceMatrix();

      // Create shadow VAO for marble (reuses marble geometry)
      gl.bindVertexArray(meshes.marble.vao);

      // Calculate light MVP for marble
      const lightMVP = mat4Multiply(lightSpaceMatrix, marbleModel);
      gl.uniformMatrix4fv(shadowUniforms.lightMVP, false, lightMVP);

      // Draw marble to shadow map
      gl.drawElements(gl.TRIANGLES, meshes.marble.count, gl.UNSIGNED_SHORT, 0);

      // Restore state
      gl.colorMask(true, true, true, true);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.viewport(0, 0, canvas.width, canvas.height);

      // Switch back to main program
      gl.useProgram(program);
    }

    // Input and physics
    function updateInput(dt) {
      const target = plane.targetTilt;
      target.x = 0;
      target.y = 0;

      // Use gyro input on mobile, keyboard on desktop
      if (gyroEnabled) {
        target.x = gyroTilt.x;
        target.y = gyroTilt.y;
      } else {
        // Swap left/right so A tilts left, D tilts right
        if (keys.has('KeyA')) target.x -= 1;
        if (keys.has('KeyD')) target.x += 1;
        if (keys.has('KeyW')) target.y += 1;
        if (keys.has('KeyS')) target.y -= 1;
      }
      if (keys.has('Space')) return; // Freeze input accumulation while rewinding

      // Calculate target supportTilt, then smooth it to prevent wobble on landing
      const airborne = isAirborne();
      const level = currentSupport?.level;
      let holeOverlap = 0;
      if (level?.hasHole) holeOverlap = Math.max(holeOverlap, holeOverlapAt(level, marble.pos.x, marble.pos.z));
      if (lastGroundedLevel?.hasHole && lastGroundedLevel !== level) {
        holeOverlap = Math.max(holeOverlap, holeOverlapAt(lastGroundedLevel, marble.pos.x, marble.pos.z));
      }
      const nearHole = holeOverlap > 0.1;
      const targetSupportTilt = (airborne || nearHole)
        ? 1 // let the plane still respond to input while falling or near hole
        : Math.max(0, Math.min(1, currentSupport?.support ?? 0));

      // Smooth the support tilt to prevent sudden jumps
      const supportTiltSpeed = 6;
      smoothedSupportTilt += (targetSupportTilt - smoothedSupportTilt) * Math.min(1, dt * supportTiltSpeed);

      target.x *= smoothedSupportTilt;
      target.y *= smoothedSupportTilt;
      const len = Math.hypot(target.x, target.y);
      if (len > 1) { target.x /= len; target.y /= len; }
      const smoothing = 12;
      plane.tilt.x += (target.x * plane.maxTilt - plane.tilt.x) * dt * smoothing;
      plane.tilt.y += (target.y * plane.maxTilt - plane.tilt.y) * dt * smoothing;
    }

    function updateCamera(dt) {
      const follow = camera.followRatio;
      const level = getActiveLevel();
      const levelY = level?.y || 0;
      const marbleLocalY = marble.y - levelY;
      const desiredPosY = levelY + camera.baseHeight + marbleLocalY * follow;
      const desiredTargetY = levelY + marbleLocalY * follow * 0.6;
      const smooth = camera.smooth;
      camera.pos.y += (desiredPosY - camera.pos.y) * dt * smooth;
      camera.target.y += (desiredTargetY - camera.target.y) * dt * smooth;
    }

    function screenToBoardXZ(clientX, clientY) {
      const rect = canvas.getBoundingClientRect();
      if (!rect.width || !rect.height) return null;
      const xNdc = ((clientX - rect.left) / rect.width) * 2 - 1;
      const yNdc = ((rect.bottom - clientY) / rect.height) * 2 - 1;

      const aspect = canvas.width / canvas.height;
      const proj = mat4Perspective(Math.PI / 4, aspect, 10, 5000);
      const view = mat4LookAt(camera.pos, camera.target, { x: 0, y: 0, z: 1 });
      const invVP = mat4Invert(mat4Multiply(proj, view));

      const near = mat4TransformVec4(invVP, [xNdc, yNdc, -1, 1]);
      const far = mat4TransformVec4(invVP, [xNdc, yNdc, 1, 1]);
      const nearWorld = { x: near[0] / near[3], y: near[1] / near[3], z: near[2] / near[3] };
      const farWorld = { x: far[0] / far[3], y: far[1] / far[3], z: far[2] / far[3] };
      const dir = normalize3({
        x: farWorld.x - nearWorld.x,
        y: farWorld.y - nearWorld.y,
        z: farWorld.z - nearWorld.z
      });

      const level = getActiveLevel();
      const planePoint = { x: 0, y: level?.y || 0, z: 0 };
      const n = boardNormal();
      const denom = dir.x * n.x + dir.y * n.y + dir.z * n.z;
      if (Math.abs(denom) < 1e-5) return null;
      const t = ((planePoint.x - nearWorld.x) * n.x + (planePoint.y - nearWorld.y) * n.y + (planePoint.z - nearWorld.z) * n.z) / denom;
      if (!Number.isFinite(t) || t < 0) return null;

      const hit = {
        x: nearWorld.x + dir.x * t,
        z: nearWorld.z + dir.z * t
      };
      const halfW = plane.w * 0.5 - marble.r;
      const halfH = plane.h * 0.5 - marble.r;
      return {
        x: Math.max(-halfW, Math.min(halfW, hit.x)),
        z: Math.max(-halfH, Math.min(halfH, hit.z))
      };
    }

    function updatePhysics(dt) {
      const tiltAccel = 240;
      const supportInfo = calculateSupport(marble.pos.x, marble.pos.z, marble.y);
      currentSupport = supportInfo;
      const support = supportInfo.support;
      const supportLevel = supportInfo.level;
      const airborne = isAirborne();

      // Fade tilt control near hole edges - check BOTH current and previous level
      // to prevent discontinuity when transitioning between levels
      let holeOverlap = 0;
      if (supportLevel?.hasHole) {
        holeOverlap = Math.max(holeOverlap, holeOverlapAt(supportLevel, marble.pos.x, marble.pos.z));
      }
      if (lastGroundedLevel?.hasHole && lastGroundedLevel !== supportLevel) {
        holeOverlap = Math.max(holeOverlap, holeOverlapAt(lastGroundedLevel, marble.pos.x, marble.pos.z));
      }
      const holeProximityFade = 1 - holeOverlap;

      // Use direct tilt scale for natural physics (no smoothing here - visual smoothing handles the pop)
      const tiltScale = airborne ? 0 : (0.35 + 0.65 * support) * holeProximityFade;

      let ax = -tiltAccel * Math.sin(plane.tilt.x) * tiltScale;
      let az = tiltAccel * Math.sin(plane.tilt.y) * tiltScale;

      // Only calculate slope if not near a hole (avoid -Infinity issues)
      const eps = 2;
      let dhdx = 0, dhdz = 0;
      if (holeProximityFade > 0.5) {
        const left = levelHeightAt(supportLevel, marble.pos.x - eps, marble.pos.z);
        const right = levelHeightAt(supportLevel, marble.pos.x + eps, marble.pos.z);
        const forward = levelHeightAt(supportLevel, marble.pos.x, marble.pos.z + eps);
        const back = levelHeightAt(supportLevel, marble.pos.x, marble.pos.z - eps);
        dhdx = (Number.isFinite(right) && Number.isFinite(left)) ? (right - left) / (2 * eps) : 0;
        dhdz = (Number.isFinite(forward) && Number.isFinite(back)) ? (forward - back) / (2 * eps) : 0;
      }
      const slopeScale = pedestal.slopeGravity * tiltScale;
      ax += -slopeScale * dhdx;
      az += -slopeScale * dhdz;

      if (mouseAttractor.active) {
        const dx = mouseAttractor.target.x - marble.pos.x;
        const dz = mouseAttractor.target.z - marble.pos.z;
        const dist = Math.hypot(dx, dz);
        if (dist > 1) {
          const attractScale = airborne ? 0.35 : 1;
          const pull = mouseAttractor.strength * Math.min(1, dist / 180) * attractScale;
          ax += (dx / dist) * pull;
          az += (dz / dist) * pull;
        } else {
          mouseAttractor.active = false;
        }
      }

      // Apply acceleration directly - visual smoothing handles the pop
      marble.vel.x += ax * dt;
      marble.vel.z += az * dt;

      // Smooth friction transition too
      const frictionGround = 0.9975;
      const frictionAir = 0.999;
      const frictionBlend = Math.max(0, Math.min(1, support * 2)); // Smooth 0-0.5 range
      const friction = frictionAir + (frictionGround - frictionAir) * frictionBlend;
      marble.vel.x *= friction;
      marble.vel.z *= friction;

      marble.pos.x += marble.vel.x * dt;
      marble.pos.z += marble.vel.z * dt;

      const gravityY = 900;
      marble.vy -= gravityY * dt;
      marble.y += marble.vy * dt;

      let landingSupport = refreshSupport();
      const newGround = landingSupport.groundHeight;
      if (Number.isFinite(newGround) && marble.y <= newGround) {
        marble.y = newGround;
        if (marble.vy < 0) marble.vy = 0;
        landingSupport = refreshSupport();
      }

      const { w, h } = plane;
      const minX = -w / 2 + marble.r;
      const maxX = w / 2 - marble.r;
      const minZ = -h / 2 + marble.r;
      const maxZ = h / 2 - marble.r;

      // Only apply floor edge collision if marble is at floor level (not on wall top)
      const currentLevel = landingSupport?.level || levels[0];
      const floorY = currentLevel.y;
      const wallTopY = floorY + plane.wallHeight;
      const onWallTop = marble.y > floorY + marble.r + plane.wallHeight * 0.5;

      if (!onWallTop) {
        if (marble.pos.x < minX) { marble.pos.x = minX; marble.vel.x *= -0.6; }
        if (marble.pos.x > maxX) { marble.pos.x = maxX; marble.vel.x *= -0.6; }
        if (marble.pos.z < minZ) { marble.pos.z = minZ; marble.vel.z *= -0.6; }
        if (marble.pos.z > maxZ) { marble.pos.z = maxZ; marble.vel.z *= -0.6; }
      } else {
        // On wall top - allow movement on wall, but clamp to outer wall edge
        const outerMinX = -w / 2 - plane.wallThickness + marble.r;
        const outerMaxX = w / 2 + plane.wallThickness - marble.r;
        const outerMinZ = -h / 2 - plane.wallThickness + marble.r;
        const outerMaxZ = h / 2 + plane.wallThickness - marble.r;
        if (marble.pos.x < outerMinX) { marble.pos.x = outerMinX; marble.vel.x *= -0.6; }
        if (marble.pos.x > outerMaxX) { marble.pos.x = outerMaxX; marble.vel.x *= -0.6; }
        if (marble.pos.z < outerMinZ) { marble.pos.z = outerMinZ; marble.vel.z *= -0.6; }
        if (marble.pos.z > outerMaxZ) { marble.pos.z = outerMaxZ; marble.vel.z *= -0.6; }
      }

      // Wall grid collision (for levels with walls configured)
      // Skip collision if marble is on top of the wall
      if (currentLevel?.walls?.length > 0 && landingSupport.support > 0.5) {
        const onWallTop = marble.y > currentLevel.y + marble.r + currentLevel.wallHeight * 0.5;
        if (!onWallTop) {
          const cellSize = WALL_CELL_SIZE;
          const halfCell = cellSize / 2;
          const r = marble.r;

          for (const cell of currentLevel.walls) {
            // Convert grid coords to world coords (must match createWallGridMeshes)
            const worldX = -(cell.x - WALL_GRID_SIZE / 2 + 0.5) * cellSize;
            const worldZ = -(cell.z - WALL_GRID_SIZE / 2 + 0.5) * cellSize;

            // Wall bounds
            const minX = worldX - halfCell;
            const maxX = worldX + halfCell;
            const minZ = worldZ - halfCell;
            const maxZ = worldZ + halfCell;

            // Check if marble is colliding with this wall cell
            if (marble.pos.x > minX - r && marble.pos.x < maxX + r &&
                marble.pos.z > minZ - r && marble.pos.z < maxZ + r) {
              // Find closest edge and push out
              const overlapLeft = marble.pos.x - (minX - r);
              const overlapRight = (maxX + r) - marble.pos.x;
              const overlapFront = marble.pos.z - (minZ - r);
              const overlapBack = (maxZ + r) - marble.pos.z;

              const minOverlap = Math.min(overlapLeft, overlapRight, overlapFront, overlapBack);

              if (minOverlap === overlapLeft) {
                marble.pos.x = minX - r;
                marble.vel.x *= -0.6;
              } else if (minOverlap === overlapRight) {
                marble.pos.x = maxX + r;
                marble.vel.x *= -0.6;
              } else if (minOverlap === overlapFront) {
                marble.pos.z = minZ - r;
                marble.vel.z *= -0.6;
              } else {
                marble.pos.z = maxZ + r;
                marble.vel.z *= -0.6;
              }
            }
          }
        }
      }

      checkOrbCollisions();
      updateOrbs(dt);
      updateCollapses(dt);
      refreshSupport();
    }

    // Render helpers
    function getActiveLevel() {
      if (isAirborne()) return lastGroundedLevel || currentSupport?.level || levels[0];
      return currentSupport?.level || lastGroundedLevel || levels[0];
    }

    function setMatrices(model) {
      const aspect = canvas.width / canvas.height;
      const proj = mat4Perspective(Math.PI / 4, aspect, 10, 5000);
      const view = mat4LookAt(camera.pos, camera.target, { x: 0, y: 0, z: 1 });
      const vp = mat4Multiply(proj, view);
      const mvp = mat4Multiply(vp, model);
      const normalMatrix = mat4Transpose(mat4Invert(model));
      gl.uniformMatrix4fv(uniforms.mvp, false, mvp);
      gl.uniformMatrix4fv(uniforms.model, false, model);
      gl.uniformMatrix4fv(uniforms.normalMatrix, false, normalMatrix);
    }

    let shadowEnabled = false;
    let shadowReceiveEnabled = true;

    function drawMesh(mesh, model, color, ambient=[0.05,0.08,0.12], alpha=1.0, holeMask=null, receiveShadow=true) {
      gl.bindVertexArray(mesh.vao);
      setMatrices(model);
      gl.uniform3fv(uniforms.lightDir, new Float32Array([lightDir.x, lightDir.y, lightDir.z]));

      // Shadow uniforms
      gl.uniformMatrix4fv(uniforms.lightSpaceMatrix, false, lightSpaceMatrix);
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, shadowDepthTexture);
      gl.uniform1i(uniforms.shadowMap, 0);
      gl.uniform1f(uniforms.shadowEnabled, (shadowEnabled && shadowReceiveEnabled && receiveShadow) ? 1.0 : 0.0);
      // Validate color array to prevent NaN/undefined issues
      const safeColor = Array.isArray(color) && color.length >= 3
        ? [
            Number.isFinite(color[0]) ? color[0] : 0.3,
            Number.isFinite(color[1]) ? color[1] : 0.3,
            Number.isFinite(color[2]) ? color[2] : 0.6
          ]
        : [0.3, 0.3, 0.6];
      gl.uniform3fv(uniforms.color, new Float32Array(safeColor));
      // Validate ambient array
      const safeAmbient = Array.isArray(ambient) && ambient.length >= 3
        ? [
            Number.isFinite(ambient[0]) ? ambient[0] : 0.05,
            Number.isFinite(ambient[1]) ? ambient[1] : 0.08,
            Number.isFinite(ambient[2]) ? ambient[2] : 0.12
          ]
        : [0.05, 0.08, 0.12];
      gl.uniform3fv(uniforms.ambient, new Float32Array(safeAmbient));
      // Validate alpha
      const safeAlpha = Number.isFinite(alpha) ? Math.max(0, Math.min(1, alpha)) : 1.0;
      gl.uniform1f(uniforms.alpha, safeAlpha);
      holeCentersArr.fill(0);
      holeRadiiArr.fill(0);
      holeSoftnessArr.fill(0);
      if (holeMask) {
        const holes = Array.isArray(holeMask.holes) ? holeMask.holes : [holeMask];
        const count = Math.min(MAX_HOLES, holes.length);
        for (let i = 0; i < count; i++) {
          const h = holes[i] || {};
          const progress = Math.max(0, Math.min(1, h.progress ?? 1));
          const radius = (h.radius || 0) * progress;
          const c = h.center || { x: 0, y: 0, z: 0 };
          holeCentersArr[i * 3 + 0] = c.x || 0;
          holeCentersArr[i * 3 + 1] = c.y || 0;
          holeCentersArr[i * 3 + 2] = c.z || 0;
          holeRadiiArr[i] = radius;
          holeSoftnessArr[i] = h.softness ?? 0;
        }
        gl.uniform1i(uniforms.holeCount, count);
        gl.uniform3fv(uniforms.holeCenters, holeCentersArr);
        gl.uniform1fv(uniforms.holeRadii, holeRadiiArr);
        gl.uniform1fv(uniforms.holeSoftness, holeSoftnessArr);
      } else {
        gl.uniform1i(uniforms.holeCount, 0);
        gl.uniform3fv(uniforms.holeCenters, holeCentersArr);
        gl.uniform1fv(uniforms.holeRadii, holeRadiiArr);
        gl.uniform1fv(uniforms.holeSoftness, holeSoftnessArr);
      }
      gl.drawElements(gl.TRIANGLES, mesh.count, gl.UNSIGNED_SHORT, 0);
    }

    function boardTransform(offsetY=0, tiltScale=1) {
      let m = mat4Identity();
      m = mat4Translate(m, [0, offsetY, 0]);
      // Skip visual tilt on mobile - the phone itself is tilting
      if (!isMobile) {
        m = mat4RotateX(m, plane.tilt.y * 0.35 * tiltScale);
        m = mat4RotateZ(m, plane.tilt.x * 0.35 * tiltScale);
      }
      return m;
    }
    function boardNormal() {
      const m = boardTransform(0);
      return transformDirection(m, { x: 0, y: 1, z: 0 });
    }

    function drawMarbleEffects(boardM) {
      const supportLevel = getActiveLevel();
      const holeMask = (supportLevel?.hasHole)
        ? (() => {
            const holes = holesForLevel(supportLevel);
            return holes.length ? { holes } : null;
          })()
        : null;
      const levelY = supportLevel.y || 0;
      const surfaceY = isAirborne()
        ? lastGroundSurfaceHeight
        : (Number.isFinite(currentSupport?.surfaceHeight) ? currentSupport.surfaceHeight : levelHeightAt(supportLevel, marble.pos.x, marble.pos.z));
      const planeY = Number.isFinite(surfaceY) ? surfaceY : (marble.y - marble.r);
      const normal = levelNormalAt(supportLevel, marble.pos.x, marble.pos.z);
      const orient = mat4FromNormal(normal);
      const deltaY = Number.isFinite(surfaceY) ? marble.y - (surfaceY + marble.r) : Infinity; // >0 above plane, <0 below
      const altitudeForFx = deltaY > 0 ? deltaY : Infinity; // hide reflection once we fall through

      // Calculate proximity for reflection fade (used to be for old blob shadow too)
      const altitude = isAirborne()
        ? altitudeForFx
        : (Number.isFinite(currentSupport?.altitude) ? currentSupport.altitude : altitudeForFx);
      const proximityStrength = Number.isFinite(altitude) ? Math.max(0, Math.min(1, 1 - Math.max(0, altitude) / (marble.r * 2.5))) : 0;

      // Reflection (mirror across the local surface plane)
      // Shadow is now handled by shadow mapping in the main shader
      const distanceAbove = marble.y - planeY;
      if (deltaY >= 0) { // only show reflection while above the plane
        const reflectionY = planeY - distanceAbove + 1.2;
        let reflectionM = boardM;
        reflectionM = mat4Translate(reflectionM, [marble.pos.x, reflectionY - levelY, marble.pos.z]);
        reflectionM = mat4Multiply(reflectionM, orient);
        reflectionM = mat4Scale(reflectionM, [1, -1, 1]);
        drawMesh(meshes.marble, reflectionM, [0.65,0.7,0.8], [0.05,0.05,0.08], 0.22 * Math.max(0, proximityStrength * 0.58), holeMask, false); // Reflection doesn't receive shadow
      }
    }

    function drawOrbs(boardM, orbTime, levelIndex=0, alpha=1, opts={}) {
      const includeFollowing = opts.includeFollowing ?? true;
      const followingOnly = opts.followingOnly ?? false;
      const liftOffset = opts.liftOffset;
      const transitionBoards = opts.transitionBoards;
      const hasTransitionBoards = transitionBoards && transitionBoards.flat && transitionBoards.tilted && transitionBoards.invFlat;
      for (const orb of orbs) {
        const isFollowing = !!orb.following;
        if (followingOnly && !isFollowing) continue;
        if (!followingOnly && !includeFollowing && isFollowing) continue;
        const renderLevelIndex = isFollowing ? (orb.renderLevel ?? getActiveLevel()?.index ?? orb.level) : orb.level;
        if (renderLevelIndex !== levelIndex) continue;
        const dissolve = orb.collected ? orb.dissolve : 0;
        if (dissolve >= 1) continue;
        const followProgress = isFollowing ? clamp01(orb.followProgress ?? 1) : 1;
        const followEase = smoothstep01(followProgress);
        const flash = orb.collectFlash ? clamp01(orb.collectFlash / orbCollectFlashDuration) : 0;
        const flashEase = orbFlashEnvelope(flash);
        const baseGlow = orbGlowPulse(orb, orbTime);
        gl.depthMask(false);
        gl.enable(gl.DEPTH_TEST);
        gl.depthFunc(gl.LEQUAL);

        // Orbiting sun(s) (additive-ish)
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
        for (let i=0;i<orb.sats.length;i++){
          const sat = orb.sats[i];
          const offset = satelliteOffset(sat, orbTime, i);
          const extraY = liftOffset ? liftOffset(orb, renderLevelIndex, followEase) : 0;
          const basePos = [orb.pos.x + offset.x, orb.pos.y + offset.y, orb.pos.z + offset.z, 1];
          let sM;
          if (isFollowing && hasTransitionBoards && followEase < 1) {
            const tiltedPos = mat4TransformVec4(transitionBoards.tilted, basePos);
            const flatPos = mat4TransformVec4(transitionBoards.flat, [basePos[0], basePos[1] + extraY, basePos[2], basePos[3]]);
            const blended = [
              tiltedPos[0] + (flatPos[0] - tiltedPos[0]) * followEase,
              tiltedPos[1] + (flatPos[1] - tiltedPos[1]) * followEase,
              tiltedPos[2] + (flatPos[2] - tiltedPos[2]) * followEase,
              1
            ];
            const local = mat4TransformVec4(transitionBoards.invFlat, blended);
            sM = transitionBoards.flat;
            sM = mat4Translate(sM, [local[0], local[1], local[2]]);
          } else {
            sM = boardM;
            sM = mat4Translate(sM, [basePos[0], basePos[1] + extraY, basePos[2]]);
          }
          const shrink = orb.collected ? (1 - 0.5 * followEase) : 1;
          const sScale = 0.35 * shrink * (1 - dissolve);
          sM = mat4Scale(sM, [sScale, sScale, sScale]);
          const flashColor = baseGlow + flashEase * 5.5;
          const flashAlpha = (0.65 * baseGlow + flashEase * 3.6) * (1 - dissolve);
          // Wild orbs cycle through rainbow colors
          let diffuse, specular;
          let satAlpha = alpha * flashAlpha;
          let ambient;
          if (orb.wild) {
            // Cycle between blue and magenta
            const t = orbTime * 0.8 + (orb.seed || 0);
            const wave = Number.isFinite(t) ? (Math.sin(t * Math.PI * 2) + 1) * 0.5 : 0.5; // 0 to 1
            // Brighter, slightly less saturated (add some green)
            diffuse = [wave * 2.8, 0.4, 2.5];
            ambient = [wave * 0.9, 0.15, 0.9];
            // Two-pass for both states: solid color base + additive glow
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            const baseAlpha = orb.collected ? satAlpha * 0.5 : satAlpha * 0.35;
            drawMesh(meshes.marble, sM, diffuse, ambient, baseAlpha);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
            const glowAlpha = orb.collected ? satAlpha * 0.45 : satAlpha * 0.3;
            drawMesh(meshes.marble, sM, [wave * 0.45, 0.08, 0.4], [wave * 0.18, 0.03, 0.18], glowAlpha);
          } else {
            diffuse = [1.3 * flashColor, 1.05 * flashColor, 0.6 * flashColor];
            ambient = [0.25, 0.2, 0.1];
            drawMesh(meshes.marble, sM, diffuse, ambient, satAlpha);
          }
        }
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        gl.depthMask(true);
        gl.depthFunc(gl.LESS);
        gl.enable(gl.DEPTH_TEST);
      }
    }

    function frame(time) {
      try {
      const now = time * 0.001;
      const delta = now - (frame.last || now);
      const dt = Math.min(0.033, delta);
      frame.last = now;

      const rewinding = keys.has('Space');
      if (rewinding) {
        rewindAccumulator += rewindSpeed;
        let rewindBlocked = false;
        while (rewindAccumulator >= 1) {
          rewindAccumulator -= 1;
          if (rewindStep()) {
            rewindBlocked = true;
            rewindAccumulator = 0; // Stop accumulating when blocked
            break;
          }
        }
        refreshSupport();
        // Update collapses during rewind so pedestals can close when orb count drops
        updateCollapses(dt);
        // Only update wild orbs and animation if there's still history to rewind and not blocked
        if (history.length > 1 && !rewindBlocked) {
          updateWildOrbs(dt);
          // Keep animation time advancing for wild orb rainbow effect (ensure finite)
          if (Number.isFinite(delta)) orbAnimTime += delta;
        }
        // When star history is exhausted, keep stars moving with reversed velocities
        // But freeze everything when main history hits zero or rewind is blocked
        if (starsReversed && history.length > 1 && !rewindBlocked) {
          updateStars(dt);
        }
      } else {
        rewindAccumulator = 0;
        // Transition from rewind to forward: un-reverse star velocities
        if (starsReversed) {
          reverseStarVelocities();
          starsReversed = false;
        }
        updateInput(dt);
        updatePhysics(dt);
        updateStars(dt);
        if (Number.isFinite(delta)) orbAnimTime += delta;
        pushHistory();
      }

      // Update rewind bar
      updateRewindBar();
      updateCamera(dt);
      drawStars();
      updateLightsUniforms();

      // Reset WebGL state at start of each frame to recover from any mid-frame errors
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
      gl.depthMask(true);
      gl.depthFunc(gl.LESS);
      gl.enable(gl.DEPTH_TEST);
      gl.disable(gl.CULL_FACE);
      gl.clearColor(0, 0, 0, 0);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

      const activeLevel = getActiveLevel();
      const activeLevelYForShadow = activeLevel?.y || 0;

      // Smooth the marble tilt scale for rendering to prevent visual pops
      // (moved before shadow pass to keep shadow in sync)
      const targetMarbleTilt = Math.max(0, Math.min(1, currentSupport?.support ?? 0));
      const marbleTiltSmoothSpeed = 5;
      smoothedMarbleTilt += (targetMarbleTilt - smoothedMarbleTilt) * Math.min(1, dt * marbleTiltSmoothSpeed);
      const marbleTiltScale = smoothedMarbleTilt;

      // ========================================
      // SHADOW PASS - Render marble to shadow map
      // ========================================
      {
        const marbleTiltMForShadow = boardTransform(activeLevelYForShadow, marbleTiltScale);
        let marbleModelForShadow = marbleTiltMForShadow;
        marbleModelForShadow = mat4Translate(marbleModelForShadow, [marble.pos.x, marble.y - activeLevelYForShadow, marble.pos.z]);
        renderShadowPass(marbleModelForShadow, activeLevelYForShadow);
        shadowEnabled = true;
      }
      const fadeDepth = levelDrop * 0.75; // fade out as we fall roughly three quarters of a level
      function isLevelUnlocked(level) {
        if (!level) return false;
        if (level.index === 0) return true;
        const aboveCollapse = collapseStateFor(level.index - 1);
        const hasHoleOpen = (aboveCollapse?.progress ?? 0) > 0;
        return hasHoleOpen || marble.y <= level.y + approachFadeDepth;
      }

      const boardEntries = [];
      for (const level of levels) {
        if (!isLevelUnlocked(level)) continue;
        const aboveCollapse = collapseStateFor(level.index - 1);
        const hasHoleOpen = (aboveCollapse?.progress ?? 0) > 0;
        const heightAbove = Math.max(0, marble.y - level.y - marble.r * 2);
        const heightBelow = Math.max(0, level.y - marble.y);
        // Fade in as marble approaches from above (skip if hole is open above)
        const approachFade = hasHoleOpen ? 1
          : heightAbove <= 0 ? 1
          : Math.max(0, Math.min(1, 1 - (heightAbove / approachFadeDepth)));
        // Fade out as marble falls below
        const departureFade = heightBelow <= 0
          ? 1
          : Math.max(0, Math.min(1, 1 - (heightBelow / fadeDepth)));
        const fade = Math.min(approachFade, departureFade);
        if (fade <= 0.001) continue;
        const levelHoles = holesForLevel(level);
        const mask = level.hasHole && levelHoles.length ? { holes: levelHoles } : null;
        boardEntries.push({ level, matrix: boardTransform(level.y), mask, alpha: fade });
      }

      // Draw from lowest to highest so fading boards overlay what's below without popping
      boardEntries.sort((a, b) => a.level.y - b.level.y);

      // Calculate max alpha of levels above the active level (for fading marble/orbs)
      // Skip levels where the marble is in the hole - it's visible through the hole
      const activeLevelIndex = activeLevel?.index ?? 0;
      const maxAlphaAbove = boardEntries
        .filter(e => e.level.index < activeLevelIndex)
        .filter(e => !isPointInHole(e.level, marble.pos.x, marble.pos.z))
        .reduce((max, e) => Math.max(max, e.alpha), 0);

      for (const entry of boardEntries) {
        const { level, matrix, mask } = entry;
        // Validate level index and get palette with fallbacks
        const levelIdx = Number.isFinite(level?.index) ? level.index : 0;
        const rawPalette = boardColors[levelIdx] || boardColors[0] || defaultBoardColors;
        // Ensure all palette colors exist
        const palette = {
          floor: rawPalette.floor || defaultBoardColors.floor,
          wall: rawPalette.wall || defaultBoardColors.wall,
          pedestal: rawPalette.pedestal || defaultBoardColors.pedestal,
          pedestalHole: rawPalette.pedestalHole || defaultBoardColors.pedestalHole
        };
        const allowDepthWrite = entry.alpha > 0.001;
        gl.depthMask(allowDepthWrite);
        drawMesh(meshes.floor, matrix, palette.floor, [0.04,0.06,0.1], entry.alpha, level.hasHole ? mask : null);
        const wallColor = palette.wall;
        gl.enable(gl.CULL_FACE);
        for(const w of meshes.walls) drawMesh(w, matrix, wallColor, [0.04,0.05,0.09], entry.alpha);
        if (level.wallMeshes && Array.isArray(level.wallMeshes)) {
          for(const w of level.wallMeshes) if (w) drawMesh(w, matrix, wallColor, [0.04,0.05,0.09], entry.alpha);
        }
        gl.disable(gl.CULL_FACE);
        const pedestals = pedestalsForLevel(level);
        const isWild = isWildPedestal(level.index);
        for(const { pos, idx } of pedestals){
          const height = pedestalHeightForIndex(idx, level);
          const pedCollapse = collapseProgressFor(level.index, idx);
          const pedMesh = pedCollapse > 0 ? meshes.pedestalHole : meshes.pedestal;
          const pedAlpha = pedCollapse > 0 ? entry.alpha * pedestalCollapseAlpha(pedCollapse) : entry.alpha;
          if (pedAlpha <= 0.001) continue;
          let pedM = matrix;
          pedM = mat4Translate(pedM, [pos.x, 0, pos.z]);
          pedM = mat4Scale(pedM, [1, height / pedestal.height, 1]);
          // Ensure pedestal colors are valid arrays before calculations
          const safePedestal = Array.isArray(palette.pedestal) ? palette.pedestal : defaultBoardColors.pedestal;
          const safePedestalHole = Array.isArray(palette.pedestalHole) ? palette.pedestalHole : defaultBoardColors.pedestalHole;
          let pedColor = pedCollapse > 0
            ? safePedestal.map((c, i) => (c || 0) + ((safePedestalHole[i] || 0) - (c || 0)) * pedCollapse)
            : [...safePedestal];
          // Wild pedestals cycle through rainbow colors like wild orbs
          if (isWild) {
            const t = orbAnimTime * 0.8 + idx * 0.5; // offset by pedestal index
            const wave = Number.isFinite(t) ? (Math.sin(t * Math.PI * 2) + 1) * 0.5 : 0.5;
            // Blend from original green to rainbow (blue-magenta cycle)
            const wildColor = [wave * 0.7, 0.3, 0.6 + wave * 0.3];
            pedColor = pedColor.map((c, i) => (c || 0) * 0.4 + wildColor[i] * 0.6);
          }
          if (pedCollapse > 0) gl.depthMask(false); // let the hole reveal the level below while fading
          drawMesh(pedMesh, pedM, pedColor, [0.05,0.06,0.1], pedAlpha);
          if (pedCollapse > 0) gl.depthMask(allowDepthWrite);
        }
        // Draw level orbs with depth so lower levels stay occluded by boards
        drawOrbs(matrix, orbAnimTime, level.index, entry.alpha, { includeFollowing: false });
      }
      gl.depthMask(true);

      const activeLevelY = activeLevel?.y || 0;
      const boardTiltM = boardTransform(activeLevelY);
      const marbleTiltM = marbleTiltScale >= 0.999 ? boardTiltM : boardTransform(activeLevelY, marbleTiltScale);
      // Fade marble/orbs as level above fades in
      const marbleOrbAlpha = 1 - maxAlphaAbove;
      gl.depthMask(false);
      gl.disable(gl.DEPTH_TEST);
      drawMarbleEffects(boardTiltM);
      gl.depthMask(true);
      gl.enable(gl.DEPTH_TEST);
      gl.clear(gl.DEPTH_BUFFER_BIT); // Clear depth so marble/orbs render on top, alpha handles fade
      let marbleM = marbleTiltM;
      marbleM = mat4Translate(marbleM, [marble.pos.x, marble.y - activeLevelY, marble.pos.z]);
      drawMesh(meshes.marble, marbleM, [0.7,0.7,0.7], [0.1,0.1,0.1], marbleOrbAlpha, null, false); // Marble doesn't receive its own shadow

      // Draw current-level orbs over the marble for a brighter, on-top glow
      const activeEntry = boardEntries.find(e => e.level.index === activeLevel?.index);
      if (activeEntry) {
        drawOrbs(activeEntry.matrix, orbAnimTime, activeEntry.level.index, activeEntry.alpha * marbleOrbAlpha, { includeFollowing: false });
      }
      const followingLevels = new Set();
      for (const orb of orbs) {
        if (!orb.following) continue;
        if (orb.collected && orb.dissolve >= 1) continue;
        const idx = orb.renderLevel ?? activeLevel?.index ?? orb.level;
        if (!Number.isFinite(idx)) continue;
        followingLevels.add(idx);
      }
      for (const idx of followingLevels) {
        const lvl = levels[idx] || levels[0];
        const flatBoard = boardTransform(lvl?.y || 0, 0);
        const tiltedBoard = boardTransform(lvl?.y || 0);
        const flatInv = mat4Invert(flatBoard);
        const liftOffset = (orb, _renderLevelIndex, followEase=1) => {
          const pos = [orb.pos.x, orb.pos.y, orb.pos.z, 1];
          const tilted = mat4TransformVec4(tiltedBoard, pos);
          const flat = mat4TransformVec4(flatBoard, pos);
          const tiltLift = tilted[1] - flat[1];
          return tiltLift + followingOrbLift * followEase;
        };
        drawOrbs(flatBoard, orbAnimTime, idx, marbleOrbAlpha, { followingOnly: true, liftOffset, transitionBoards: { flat: flatBoard, tilted: tiltedBoard, invFlat: flatInv } });
      }

      // Re-draw floors and walls of levels above the marble to properly occlude it (holes still discard)
      for (const entry of boardEntries) {
        if (entry.level.y <= marble.y) continue; // Only floors above the marble
        if (entry.alpha <= 0.001) continue;
        const { level, matrix, mask } = entry;
        // Validate level index and get palette with fallbacks
        const levelIdx = Number.isFinite(level?.index) ? level.index : 0;
        const rawPalette = boardColors[levelIdx] || boardColors[0] || defaultBoardColors;
        const palette = {
          floor: rawPalette.floor || defaultBoardColors.floor,
          wall: rawPalette.wall || defaultBoardColors.wall
        };
        gl.depthMask(true);
        drawMesh(meshes.floor, matrix, palette.floor, [0.04,0.06,0.1], entry.alpha, level.hasHole ? mask : null);
        const wallColor = palette.wall;
        gl.enable(gl.CULL_FACE);
        for(const w of meshes.walls) drawMesh(w, matrix, wallColor, [0.04,0.05,0.09], entry.alpha);
        if (level.wallMeshes && Array.isArray(level.wallMeshes)) {
          for(const w of level.wallMeshes) if (w) drawMesh(w, matrix, wallColor, [0.04,0.05,0.09], entry.alpha);
        }
        gl.disable(gl.CULL_FACE);
      }

      if (!paused) rafId = requestAnimationFrame(frame);
      } catch (err) {
        console.error('Frame error:', err);
        // Recover by continuing the animation loop
        if (!paused) rafId = requestAnimationFrame(frame);
      }
    }

    function setupInput() {
      window.addEventListener('keydown', (e) => {
        if (!e.repeat && (e.code === 'Digit0' || e.code === 'Numpad0')) {
          skipNextOrbBatch();
          return;
        }
        if (!e.repeat && e.code === 'Escape') {
          togglePause();
          return;
        }
        keys.add(e.code);
      });
      window.addEventListener('keyup', (e) => keys.delete(e.code));
      function setAttractorFromEvent(e) {
        const target = screenToBoardXZ(e.clientX, e.clientY);
        if (!target) return false;
        mouseAttractor.active = true;
        mouseAttractor.target.x = target.x;
        mouseAttractor.target.z = target.z;
        return true;
      }
      canvas.addEventListener('pointerdown', (e) => {
        if (setAttractorFromEvent(e) && canvas.setPointerCapture) {
          canvas.setPointerCapture(e.pointerId);
        }
      });
      canvas.addEventListener('pointermove', (e) => {
        if (!mouseAttractor.active) return;
        setAttractorFromEvent(e);
      });
      function stopAttractor(e) {
        mouseAttractor.active = false;
        if (e && canvas.releasePointerCapture) canvas.releasePointerCapture(e.pointerId);
      }
      canvas.addEventListener('pointerup', stopAttractor);
      canvas.addEventListener('pointercancel', stopAttractor);
      canvas.addEventListener('pointerleave', () => { mouseAttractor.active = false; });

      // Mobile touch-to-rewind (tap anywhere on canvas)
      if (isMobile) {
        canvas.addEventListener('touchstart', (e) => {
          e.preventDefault();
          keys.add('Space');
        }, { passive: false });
        canvas.addEventListener('touchend', (e) => {
          e.preventDefault();
          keys.delete('Space');
        }, { passive: false });
        canvas.addEventListener('touchcancel', () => {
          keys.delete('Space');
        });
        // Prevent magnifying glass / context menu on iOS
        document.addEventListener('contextmenu', (e) => e.preventDefault());
        document.addEventListener('selectstart', (e) => e.preventDefault());
      }
    }

    // Mobile gyroscope setup
    function setupMobileGyro() {
      window.addEventListener('deviceorientation', (e) => {
        if (!gyroEnabled) return;
        // gamma = left/right tilt (-90 to 90)
        // beta = front/back tilt (-180 to 180), ~45 when holding phone naturally
        let gamma = e.gamma || 0;
        let beta = e.beta || 0; // phone held parallel to ground

        // Apply deadzone
        if (Math.abs(gamma) < gyroDeadzone) gamma = 0;
        if (Math.abs(beta) < gyroDeadzone) beta = 0;

        // Map to -1 to 1 range with sensitivity (negated for natural feel)
        gyroTilt.x = Math.max(-1, Math.min(1, gamma / gyroSensitivity));
        gyroTilt.y = Math.max(-1, Math.min(1, -beta / gyroSensitivity));
      }, true);
    }

    async function requestGyroPermission() {
      // iOS 13+ requires explicit permission request
      if (typeof DeviceOrientationEvent !== 'undefined' &&
          typeof DeviceOrientationEvent.requestPermission === 'function') {
        try {
          const permission = await DeviceOrientationEvent.requestPermission();
          return permission === 'granted';
        } catch (err) {
          console.error('Gyro permission error:', err);
          return false;
        }
      }
      // Non-iOS or older iOS - permission not required
      return true;
    }

    function showMobileOverlay() {
      const overlay = document.getElementById('mobile-start-overlay');
      overlay.classList.remove('hidden');
    }

    function hideMobileOverlay() {
      const overlay = document.getElementById('mobile-start-overlay');
      overlay.classList.add('hidden');
    }

    function setupMobileStartButton() {
      const btn = document.getElementById('mobile-start-btn');
      const hud = document.getElementById('hud');

      btn.addEventListener('click', async () => {
        const granted = await requestGyroPermission();
        if (granted) {
          gyroEnabled = true;
          setupMobileGyro();
          hideMobileOverlay();
          // Update HUD for mobile
          hud.innerHTML = 'Tilt to roll<br>Tap to rewind';
        } else {
          // Fallback: still allow playing without gyro
          hideMobileOverlay();
          hud.innerHTML = 'Gyro denied - tap to rewind';
        }
      });
    }

    // ===========================================
    // MarbLD INTEGRATION - Reload and navigation functions
    // ===========================================
    function rebuildDerivedArrays() {
      levels = levelConfigs.map((cfg, i) => {
        const layout = cfg.pedestals.filter(idx => idx >= 0);

        // Handle walls - new grid format or legacy innerWall format
        let walls = null;
        let wallHeight = pedestal.height;
        let wallMeshes = null;

        if (cfg.walls && cfg.walls.length > 0) {
          // New wall grid format
          walls = cfg.walls;
          wallHeight = cfg.wallHeight ?? pedestal.height;
          try {
            wallMeshes = createWallGridMeshes(walls, wallHeight);
          } catch (e) {
            console.error('Error creating wall meshes for level', i, e);
            wallMeshes = [];
          }
        } else if (cfg.innerWall?.enabled) {
          // Legacy innerWall format - convert to grid format for collision
          const innerWall = {
            position: cfg.innerWall.position ?? defaultInnerWall.position,
            halfWidth: cfg.innerWall.halfWidth ?? defaultInnerWall.halfWidth,
            height: cfg.innerWall.height ?? defaultInnerWall.height
          };
          wallHeight = innerWall.height;
          // Use legacy mesh rendering for old format
          wallMeshes = createInnerWallMeshes(innerWall);
          // Convert to walls array for collision (approximate)
          walls = [];
          const pos = innerWall.position;
          const centerCell = WALL_GRID_SIZE / 2;
          const posCell = Math.round(pos / WALL_CELL_SIZE);
          for (let j = 0; j < WALL_GRID_SIZE; j++) {
            const topRow = Math.round(centerCell - posCell);
            const bottomRow = Math.round(centerCell + posCell - 1);
            if (topRow >= 0 && topRow < WALL_GRID_SIZE) walls.push({ x: j, z: topRow });
            if (bottomRow >= 0 && bottomRow < WALL_GRID_SIZE) walls.push({ x: j, z: bottomRow });
            if (topRow >= 0 && topRow < WALL_GRID_SIZE) walls.push({ x: topRow, z: j });
            if (bottomRow >= 0 && bottomRow < WALL_GRID_SIZE) walls.push({ x: bottomRow, z: j });
          }
        }

        return {
          y: -levelDrop * i,
          hasHole: layout.length > 0,
          index: i,
          pedestalIndices: layout,
          pedestals: layout.map(idx => pedestalReferencePositions[idx]).filter(Boolean),
          walls,
          wallHeight,
          wallMeshes
        };
      });
      pedestalLayouts = levelConfigs.map(cfg => cfg.pedestals.filter(idx => idx >= 0));
      boardColors = levelConfigs.map(cfg => ensureColors(cfg.colors));
      // A level collapses if it has pedestals; orbs needed = number of pedestals
      pedestalCollapses = levelConfigs
        .map((cfg, i) => pedestalLayouts[i].length > 0 ? {
          levelIndex: i,
          pedestals: pedestalLayouts[i],
          started: false,
          progress: 0,
          wild: cfg.wild,
          exactOrbs: cfg.exactOrbs ?? !cfg.wild
        } : null)
        .filter(Boolean);
      orbsRequiredForCollapse = pedestalLayouts
        .filter(layout => layout.length > 0)
        .map(layout => layout.length);
      // Update CSS colors for rewind bar
      levelColorsCSS = levelConfigs.map((cfg, i) => {
        const c = boardColors[i]?.floor || defaultBoardColors.floor;
        return `rgb(${Math.round(c[0]*255)}, ${Math.round(c[1]*255)}, ${Math.round(c[2]*255)})`;
      });
    }

    function resetGameState() {
      // Reset marble - place at a safe starting position
      marble.pos.x = 0;
      marble.pos.z = 0;
      marble.vel.x = 0;
      marble.vy = 0;
      marble.vel.z = 0;
      // Find a valid starting height (avoid hole at center)
      const level0 = levels[0];
      let startHeight = level0.y;
      // Try center first, if it's a hole, try offset positions
      const testPositions = [[0, 0], [150, 0], [-150, 0], [0, 150], [0, -150]];
      for (const [tx, tz] of testPositions) {
        const h = levelHeightAt(level0, tx, tz);
        if (Number.isFinite(h)) {
          startHeight = h;
          marble.pos.x = tx;
          marble.pos.z = tz;
          break;
        }
      }
      marble.y = startHeight + marble.r;

      // Clear orbs and respawn
      orbs.length = 0;
      for (let i = 0; i < levels.length; i++) {
        spawnOrbsForLevel(i);
      }

      // Reset collapse states
      for (const collapse of pedestalCollapses) {
        collapse.started = false;
        collapse.progress = 0;
      }

      // Clear history
      history.length = 0;
      starHistory.length = 0;
      starsReversed = false;
      rewindAccumulator = 0;

      // Reset support tracking
      currentSupport = null;
      lastGroundedLevel = null;
      lastGroundSurfaceHeight = null;

      refreshSupport();
      pushHistory();
    }

    function reloadWithConfigs(newConfigs, preserveLevel, hotReload = false) {
      try {
      // Save state for hot reload
      const savedCollapses = hotReload ? pedestalCollapses.map(c => ({ ...c })) : null;

      levelConfigs = newConfigs;
      rebuildDerivedArrays();

      if (hotReload) {
        // Restore collapse states
        for (const saved of savedCollapses) {
          const current = pedestalCollapses.find(c => c.levelIndex === saved.levelIndex);
          if (current) {
            current.started = saved.started;
            current.progress = saved.progress;
          }
        }
        // Save all orb states by level for position preservation
        const savedOrbsByLevel = {};
        for (const orb of orbs) {
          if (!savedOrbsByLevel[orb.level]) savedOrbsByLevel[orb.level] = [];
          savedOrbsByLevel[orb.level].push({
            x: orb.pos.x,
            z: orb.pos.z,
            wild: orb.wild,
            collected: orb.collected,
            dissolve: orb.dissolve,
            seed: orb.seed,
            sats: orb.sats,
            orbitPhase: orb.orbitPhase,
            orbitRadius: orb.orbitRadius,
            orbitHeight: orb.orbitHeight,
            orbitSpeed: orb.orbitSpeed
          });
        }
        orbs.length = 0;
        for (let i = 0; i < levels.length; i++) {
          spawnOrbsForLevel(i, savedOrbsByLevel[i] || []);
        }
        // Just refresh support without moving marble
        refreshSupport();
        // Notify parent that reload is complete
        if (isEmbedded) {
          window.parent.postMessage({ type: 'marbl-reloaded' }, '*');
        }
        return;
      }

      // Full reload - respawn orbs and reset state
      orbs.length = 0;
      for (let i = 0; i < levels.length; i++) {
        spawnOrbsForLevel(i);
      }
      // If preserveLevel is specified, jump to that level instead of resetting to 0
      if (typeof preserveLevel === 'number' && preserveLevel >= 0 && preserveLevel < levels.length) {
        jumpToLevel(preserveLevel);
      } else {
        resetGameState();
      }
      // Notify parent that reload is complete
      if (isEmbedded) {
        window.parent.postMessage({ type: 'marbl-reloaded' }, '*');
      }
      } catch (err) {
        console.error('Error during reload:', err);
        // Try to keep the game running
        if (isEmbedded) {
          window.parent.postMessage({ type: 'marbl-reloaded' }, '*');
        }
      }
    }

    function jumpToLevel(levelIndex) {
      if (levelIndex < 0 || levelIndex >= levels.length) return;
      const level = levels[levelIndex];
      // Reset marble position on target level - find safe starting spot
      marble.pos.x = 0;
      marble.pos.z = 0;
      marble.vel.x = 0;
      marble.vy = 0;
      marble.vel.z = 0;
      // Find a valid starting height (avoid hole at center)
      let startHeight = level.y;
      const testPositions = [[0, 0], [150, 0], [-150, 0], [0, 150], [0, -150]];
      for (const [tx, tz] of testPositions) {
        const h = levelHeightAt(level, tx, tz);
        if (Number.isFinite(h)) {
          startHeight = h;
          marble.pos.x = tx;
          marble.pos.z = tz;
          break;
        }
      }
      marble.y = startHeight + marble.r;
      // Collapse all levels above
      for (let i = 0; i < levelIndex; i++) {
        const collapse = collapseStateFor(i);
        if (collapse) {
          collapse.started = true;
          collapse.progress = 1;
        }
      }
      // Make sure current level's collapse is reset
      const currentCollapse = collapseStateFor(levelIndex);
      if (currentCollapse) {
        currentCollapse.started = false;
        currentCollapse.progress = 0;
      }
      refreshSupport();
      history.length = 0;
      pushHistory();
      // Notify parent
      if (isEmbedded) {
        window.parent.postMessage({ type: 'marbl-jumped', levelIndex }, '*');
      }
    }

    // Export current configs for MarbLD
    function exportLevelConfigs() {
      return JSON.parse(JSON.stringify(levelConfigs));
    }

    // Expose API for embedded use
    window.marblAPI = {
      reloadWithConfigs,
      jumpToLevel,
      exportLevelConfigs,
      getLevelConfigs: () => levelConfigs
    };

    // ===========================================
    // LEVEL PICKER - File loading UI
    // ===========================================
    const levelPicker = document.getElementById('level-picker');
    const levelPickerBtn = document.getElementById('level-picker-btn');
    const levelFileInput = document.getElementById('level-file-input');
    const levelPickerError = document.getElementById('level-picker-error');
    const pickerBox = levelPicker.querySelector('.picker-box');

    function showLevelPicker() {
      levelPicker.classList.remove('hidden');
      stopLoop();
    }

    function hideLevelPicker() {
      levelPicker.classList.add('hidden');
    }

    function showPickerError(message) {
      levelPickerError.textContent = message;
    }

    function clearPickerError() {
      levelPickerError.textContent = '';
    }

    function loadLevelsFromText(jsText, filename = 'levels') {
      clearPickerError();
      try {
        // Create a sandboxed function that captures marblLevels
        const sandbox = {};
        const fn = new Function('window', jsText + '\nreturn typeof marblLevels !== "undefined" ? marblLevels : null;');
        const loadedLevels = fn(sandbox);

        if (!loadedLevels || !Array.isArray(loadedLevels) || loadedLevels.length === 0) {
          throw new Error('No valid marblLevels array found in file');
        }

        console.log('Loading', loadedLevels.length, 'levels from', filename);
        reloadWithConfigs(loadedLevels);
        hideLevelPicker();
        setupInput();
        if (isMobile) {
          setupMobileStartButton();
          showMobileOverlay();
        }
        resumeLoop();
      } catch (e) {
        console.error('Error loading levels:', e);
        showPickerError('Error loading file: ' + e.message);
      }
    }

    function handleFileSelect(file) {
      if (!file) return;
      if (!file.name.endsWith('.js')) {
        showPickerError('Please select a .js file');
        return;
      }
      const reader = new FileReader();
      reader.onload = (e) => {
        loadLevelsFromText(e.target.result, file.name);
      };
      reader.onerror = () => {
        showPickerError('Error reading file');
      };
      reader.readAsText(file);
    }

    // File picker button
    levelPickerBtn.addEventListener('click', () => {
      levelFileInput.click();
    });

    levelFileInput.addEventListener('change', (e) => {
      handleFileSelect(e.target.files[0]);
    });

    // Drag and drop
    pickerBox.addEventListener('dragover', (e) => {
      e.preventDefault();
      pickerBox.classList.add('dragover');
    });

    pickerBox.addEventListener('dragleave', () => {
      pickerBox.classList.remove('dragover');
    });

    pickerBox.addEventListener('drop', (e) => {
      e.preventDefault();
      pickerBox.classList.remove('dragover');
      const file = e.dataTransfer.files[0];
      handleFileSelect(file);
    });

    // Auto-load levels from marbl-levels.js if it exists
    const hasExternalLevels = window.marblLevels && Array.isArray(window.marblLevels) && window.marblLevels.length > 0;
    if (hasExternalLevels) {
      console.log('Loading', window.marblLevels.length, 'levels from marbl-levels.js');
      reloadWithConfigs(window.marblLevels);
      hideLevelPicker();
      setupInput();
      if (isMobile) {
        setupMobileStartButton();
        showMobileOverlay();
      }
      resumeLoop();
    } else if (!isEmbedded) {
      // Show level picker only in standalone mode (not embedded in MarbLD)
      showLevelPicker();
    } else {
      // In embedded mode, wait for levels from parent
      hideLevelPicker();
    }

    // Watchdog: ensure animation loop keeps running in embedded mode
    if (isEmbedded) {
      setInterval(() => {
        if (!paused && rafId === null) {
          console.warn('Animation loop stopped unexpectedly, restarting...');
          resumeLoop(true);
        }
      }, 1000);
    }
  </script>
</body>
</html>
