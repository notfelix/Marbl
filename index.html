<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Marbl (WebGL)</title>
  <style>
    :root {
      --bg: #050915;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      display: grid;
      place-items: center;
      position: relative;
      overflow: hidden;
      background: radial-gradient(circle at 30% 20%, #0c1224 0%, var(--bg) 55%);
      color: #e5ecff;
      font-family: "Inter", system-ui, -apple-system, sans-serif;
      height: 100vh;
    }
    #stars {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      display: block;
      pointer-events: none;
      z-index: 0;
    }
    #c {
      width: 1024px;
      height: 1024px;
      background: transparent;
      display: block;
      position: relative;
      z-index: 1;
    }
    #game-container {
      position: relative;
      display: flex;
      align-items: center;
    }
    #rewind-bar-container {
      position: absolute;
      left: calc(1024px + 1024px * 2 / 15);
      top: 5%;
      width: calc(1024px / 15);
      height: calc(1024px * 0.9);
      background: rgba(255, 255, 255, 0.08);
      border-radius: 4px;
      overflow: hidden;
    }
    #rewind-bar-container .segment {
      position: absolute;
      left: 0;
      right: 0;
      border-radius: 2px;
    }
    .hud {
      position: absolute;
      top: 16px;
      left: 50%;
      transform: translateX(-50%);
      letter-spacing: 0.08em;
      font-size: 12px;
      text-transform: uppercase;
      text-align: center;
      color: rgba(229, 236, 255, 0.6);
      pointer-events: none;
      text-shadow: 0 1px 8px rgba(0,0,0,0.35);
      z-index: 2;
    }
  </style>
</head>
<body>
  <canvas id="stars"></canvas>
  <div class="hud">WASD to tilt<br>SPACE to rewind</div>
  <div id="game-container">
    <canvas id="c" width="1024" height="1024"></canvas>
    <div id="rewind-bar-container"></div>
  </div>
  <script>
    const starCanvas = document.getElementById('stars');
    const canvas = document.getElementById('c');
    const starCtx = starCanvas.getContext('2d');
    const gl = canvas.getContext('webgl2', { antialias: true, alpha: true });
    if (!gl) {
      alert('WebGL2 not supported');
      throw new Error('WebGL2 not supported');
    }

    const rewindBarContainer = document.getElementById('rewind-bar-container');
    const levelColorsCSS = [
      'rgb(18, 71, 179)',   // Level 0 blue
      'rgb(199, 82, 87)',   // Level 1 red
      'rgb(46, 148, 82)',   // Level 2 green
      'rgb(140, 89, 166)',  // Level 3 purple
      'rgb(204, 136, 51)'   // Level 4 gold
    ];

    function updateRewindBar() {
      // Compute segments from history, tracking fall frames (transition > 0)
      const segments = [];
      const fallThreshold = 0.05; // ignore small dips when marble is on the edge
      for (let i = 0; i < history.length; i++) {
        const lvl = history[i].levelIndex ?? 0;
        const trans = history[i].levelTransition ?? 0;
        const isFalling = trans > fallThreshold;
        if (segments.length === 0 || segments[segments.length - 1].level !== lvl) {
          segments.push({ level: lvl, count: 1, fallFrames: isFalling ? 1 : 0 });
        } else {
          const seg = segments[segments.length - 1];
          seg.count++;
          if (isFalling) seg.fallFrames++;
        }
      }

      // Update DOM - reuse existing segment divs where possible
      while (rewindBarContainer.children.length > segments.length) {
        rewindBarContainer.removeChild(rewindBarContainer.lastChild);
      }
      while (rewindBarContainer.children.length < segments.length) {
        const div = document.createElement('div');
        div.className = 'segment';
        rewindBarContainer.appendChild(div);
      }

      // Position segments from bottom to top
      const totalFrames = maxHistoryFrames;
      let bottomOffset = 0;
      for (let i = 0; i < segments.length; i++) {
        const seg = segments[i];
        const segmentHeight = (seg.count / totalFrames) * 100;
        const div = rewindBarContainer.children[i];
        div.style.bottom = bottomOffset + '%';
        div.style.height = segmentHeight + '%';
        const currentColor = levelColorsCSS[seg.level] || levelColorsCSS[0];

        // Apply gradient only to the falling portion at the top of the segment
        const nextLevel = seg.level + 1;
        if (seg.fallFrames > 0 && nextLevel < levelColorsCSS.length) {
          const nextColor = levelColorsCSS[nextLevel];
          // Solid portion is the non-falling frames at the bottom
          const solidPortion = ((seg.count - seg.fallFrames) / seg.count) * 100;
          div.style.background = `linear-gradient(to top, ${currentColor} ${solidPortion}%, ${nextColor})`;
        } else {
          div.style.background = currentColor;
        }
        bottomOffset += segmentHeight;
      }
    }

    const starConfig = {
      density: 0.00014,
      minSpeed: 8,
      maxSpeed: 18,
      minSize: 0.6,
      maxSize: 1.6,
      margin: 32
    };
    const stars = [];
    let starTargetCount = 0;
    let starAreaWidth = 0;
    let starAreaHeight = 0;

    function resetStar(star, anywhere=false) {
      const w = starAreaWidth || window.innerWidth;
      const h = starAreaHeight || window.innerHeight;
      const margin = starConfig.margin;
      const speed = starConfig.minSpeed + Math.random() * (starConfig.maxSpeed - starConfig.minSpeed);
      star.size = starConfig.minSize + Math.random() * (starConfig.maxSize - starConfig.minSize);
      star.alpha = 0.25 + Math.random() * 0.45;
      let angle = Math.random() * Math.PI * 2;
      if (!anywhere) {
        const side = Math.floor(Math.random() * 4);
        const spread = Math.PI / 3;
        switch (side) {
          case 0: star.x = -margin; star.y = Math.random() * h; angle = 0; break;
          case 1: star.x = w + margin; star.y = Math.random() * h; angle = Math.PI; break;
          case 2: star.x = Math.random() * w; star.y = -margin; angle = Math.PI / 2; break;
          default: star.x = Math.random() * w; star.y = h + margin; angle = -Math.PI / 2; break;
        }
        angle += (Math.random() - 0.5) * spread;
      } else {
        star.x = Math.random() * w;
        star.y = Math.random() * h;
      }
      star.vx = Math.cos(angle) * speed;
      star.vy = Math.sin(angle) * speed;
    }

    function makeStar(fillArea=false) {
      const s = { x: 0, y: 0, vx: 0, vy: 0, size: 1, alpha: 1 };
      resetStar(s, fillArea);
      return s;
    }

    function adjustStarCount(fillArea=false) {
      if (stars.length > starTargetCount) {
        stars.length = starTargetCount;
      } else {
        while (stars.length < starTargetCount) stars.push(makeStar(fillArea));
      }
    }

    function resizeStars() {
      const dpr = window.devicePixelRatio || 1;
      starAreaWidth = window.innerWidth;
      starAreaHeight = window.innerHeight;
      starCanvas.style.width = `${starAreaWidth}px`;
      starCanvas.style.height = `${starAreaHeight}px`;
      starCanvas.width = Math.round(starAreaWidth * dpr);
      starCanvas.height = Math.round(starAreaHeight * dpr);
      starCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
      starTargetCount = Math.max(80, Math.floor(starAreaWidth * starAreaHeight * starConfig.density));
      adjustStarCount(true);
    }

    function updateStars(dt) {
      const w = starAreaWidth;
      const h = starAreaHeight;
      const margin = starConfig.margin;
      for (const s of stars) {
        s.x += s.vx * dt;
        s.y += s.vy * dt;
        if (s.x < -margin || s.x > w + margin || s.y < -margin || s.y > h + margin) {
          resetStar(s);
        }
      }
    }

    function drawStars() {
      starCtx.clearRect(0, 0, starAreaWidth, starAreaHeight);
      starCtx.fillStyle = '#d7e1ff';
      for (const s of stars) {
        starCtx.globalAlpha = s.alpha;
        starCtx.beginPath();
        starCtx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
        starCtx.fill();
      }
      starCtx.globalAlpha = 1;
    }

    // HiDPI handling
    function resize() {
      const dpr = window.devicePixelRatio || 1;
      const displayW = 1024;
      const displayH = 1024;
      canvas.style.width = `${displayW}px`;
      canvas.style.height = `${displayH}px`;
      canvas.width = displayW * dpr;
      canvas.height = displayH * dpr;
      gl.viewport(0, 0, canvas.width, canvas.height);
      resizeStars();
    }
    resize();
    window.addEventListener('resize', resize);

    // Math helpers
    function normalize3(v) {
      const len = Math.hypot(v.x, v.y, v.z || 0) || 1;
      return { x: v.x / len, y: v.y / len, z: (v.z || 0) / len };
    }
    function clamp01(v) {
      return Math.max(0, Math.min(1, v));
    }
    function smoothstep01(t) {
      const x = clamp01(t);
      return x * x * (3 - 2 * x);
    }
    function mat4Identity() {
      const out = new Float32Array(16);
      out[0]=1; out[5]=1; out[10]=1; out[15]=1;
      return out;
    }
    function mat4Multiply(a,b){
      const out=new Float32Array(16);
      const a00=a[0], a01=a[1], a02=a[2], a03=a[3];
      const a10=a[4], a11=a[5], a12=a[6], a13=a[7];
      const a20=a[8], a21=a[9], a22=a[10],a23=a[11];
      const a30=a[12],a31=a[13],a32=a[14],a33=a[15];

      const b00=b[0], b01=b[1], b02=b[2], b03=b[3];
      const b10=b[4], b11=b[5], b12=b[6], b13=b[7];
      const b20=b[8], b21=b[9], b22=b[10],b23=b[11];
      const b30=b[12],b31=b[13],b32=b[14],b33=b[15];

      out[0]=a00*b00 + a10*b01 + a20*b02 + a30*b03;
      out[1]=a01*b00 + a11*b01 + a21*b02 + a31*b03;
      out[2]=a02*b00 + a12*b01 + a22*b02 + a32*b03;
      out[3]=a03*b00 + a13*b01 + a23*b02 + a33*b03;

      out[4]=a00*b10 + a10*b11 + a20*b12 + a30*b13;
      out[5]=a01*b10 + a11*b11 + a21*b12 + a31*b13;
      out[6]=a02*b10 + a12*b11 + a22*b12 + a32*b13;
      out[7]=a03*b10 + a13*b11 + a23*b12 + a33*b13;

      out[8]=a00*b20 + a10*b21 + a20*b22 + a30*b23;
      out[9]=a01*b20 + a11*b21 + a21*b22 + a31*b23;
      out[10]=a02*b20 + a12*b21 + a22*b22 + a32*b23;
      out[11]=a03*b20 + a13*b21 + a23*b22 + a33*b23;

      out[12]=a00*b30 + a10*b31 + a20*b32 + a30*b33;
      out[13]=a01*b30 + a11*b31 + a21*b32 + a31*b33;
      out[14]=a02*b30 + a12*b31 + a22*b32 + a32*b33;
      out[15]=a03*b30 + a13*b31 + a23*b32 + a33*b33;
      return out;
    }
    function mat4Translate(m,[x,y,z]){
      const out = mat4Identity();
      out[12]=x; out[13]=y; out[14]=z;
      return mat4Multiply(m,out);
    }
    function mat4Scale(m,[x,y,z]){
      const out = mat4Identity();
      out[0]=x; out[5]=y; out[10]=z;
      return mat4Multiply(m,out);
    }
    function mat4RotateX(m,rad){
      const c=Math.cos(rad),s=Math.sin(rad);
      const r=mat4Identity();
      r[5]=c; r[9]=-s; r[6]=s; r[10]=c;
      return mat4Multiply(m,r);
    }
    function mat4RotateZ(m,rad){
      const c=Math.cos(rad),s=Math.sin(rad);
      const r=mat4Identity();
      r[0]=c; r[4]=-s; r[1]=s; r[5]=c;
      return mat4Multiply(m,r);
    }
    function rotateAroundAxis(v, axis, angle){
      const {x:ax,y:ay,z:az}=normalize3(axis);
      const cos=Math.cos(angle), sin=Math.sin(angle);
      return {
        x: v.x*cos + (ay*v.z - az*v.y)*sin + ax*(ax*v.x + ay*v.y + az*v.z)*(1-cos),
        y: v.y*cos + (az*v.x - ax*v.z)*sin + ay*(ax*v.x + ay*v.y + az*v.z)*(1-cos),
        z: v.z*cos + (ax*v.y - ay*v.x)*sin + az*(ax*v.x + ay*v.y + az*v.z)*(1-cos)
      };
    }
    function satelliteOffset(sat, time, index=0){
      if (!sat) return { x: 0, y: 0, z: 0 };
      const angle = time * sat.speed + sat.phase;
      const dir = rotateAroundAxis(sat.base, sat.axis, angle);
      return {
        x: dir.x,
        y: dir.y * 0.3 + 2 * Math.sin(time * 3 + index),
        z: dir.z
      };
    }
    function orbGlowPulse(orb, time){
      // Mild breathing so flashes start from current glow
      return 1 + 0.12 * Math.sin(time * 3 + (orb.seed || 0));
    }
    function orbFlashEnvelope(flashNorm=0){
      const t = clamp01(1 - clamp01(flashNorm)); // 0 at start, 1 at end
      return Math.sin(Math.PI * t); // smooth attack/decay bell
    }
    // HSL to RGB for wild orb rainbow cycling (h in 0-1, returns [r,g,b] in 0-1)
    function hslToRgb(h, s=1, l=0.5) {
      const c = (1 - Math.abs(2 * l - 1)) * s;
      const x = c * (1 - Math.abs((h * 6) % 2 - 1));
      const m = l - c / 2;
      let r, g, b;
      if (h < 1/6) { r = c; g = x; b = 0; }
      else if (h < 2/6) { r = x; g = c; b = 0; }
      else if (h < 3/6) { r = 0; g = c; b = x; }
      else if (h < 4/6) { r = 0; g = x; b = c; }
      else if (h < 5/6) { r = x; g = 0; b = c; }
      else { r = c; g = 0; b = x; }
      return [r + m, g + m, b + m];
    }
    function mat4Perspective(fov,aspect,near,far){
      const f=1/Math.tan(fov/2);
      const nf=1/(near-far);
      const out=new Float32Array(16);
      out[0]=f/aspect;
      out[5]=f;
      out[10]=(far+near)*nf;
      out[11]=-1;
      out[14]=(2*far*near)*nf;
      out[15]=0;
      out[1]=out[2]=out[3]=out[4]=out[6]=out[7]=out[8]=out[9]=out[12]=out[13]=0;
      return out;
    }
    function mat4FromNormal(n){
      // Build a basis where Y aligns with the surface normal
      let tangent = { x: n.z, y: 0, z: -n.x };
      let len = Math.hypot(tangent.x, tangent.y, tangent.z);
      if (len < 1e-3) tangent = { x: 1, y: 0, z: 0 };
      else tangent = { x: tangent.x/len, y: tangent.y/len, z: tangent.z/len };
      const bitangent = normalize3({
        x: n.y * tangent.z - n.z * tangent.y,
        y: n.z * tangent.x - n.x * tangent.z,
        z: n.x * tangent.y - n.y * tangent.x
      });
      const out = mat4Identity();
      out[0]=tangent.x; out[1]=tangent.y; out[2]=tangent.z;
      out[4]=n.x; out[5]=n.y; out[6]=n.z;
      out[8]=bitangent.x; out[9]=bitangent.y; out[10]=bitangent.z;
      return out;
    }
    function mat4LookAt(eye, target, up){
      // Forward from eye toward target (camera look direction)
      let zx=eye.x-target.x, zy=eye.y-target.y, zz=eye.z-target.z;
      let len=Math.hypot(zx,zy,zz);
      if(len===0){zz=1; len=1;}
      zx/=len; zy/=len; zz/=len;
      // Right = forward x up
      let xx=up.y*zz-up.z*zy;
      let xy=up.z*zx-up.x*zz;
      let xz=up.x*zy-up.y*zx;
      len=Math.hypot(xx,xy,xz)||1;
      xx/=len; xy/=len; xz/=len;
      // Recomputed up = right x forward
      const yx=zy*xz-zz*xy;
      const yy=zz*xx-zx*xz;
      const yz=zx*xy-zy*xx;
      const out=mat4Identity();
      out[0]=xx; out[1]=xy; out[2]=xz;
      out[4]=yx; out[5]=yy; out[6]=yz;
      out[8]=zx; out[9]=zy; out[10]=zz;
      out[12]=-(xx*eye.x + xy*eye.y + xz*eye.z);
      out[13]=-(yx*eye.x + yy*eye.y + yz*eye.z);
      out[14]=-(zx*eye.x + zy*eye.y + zz*eye.z);
      return out;
    }
    function mat4TransformVec4(m, v){
      return [
        m[0]*v[0] + m[4]*v[1] + m[8]*v[2] + m[12]*v[3],
        m[1]*v[0] + m[5]*v[1] + m[9]*v[2] + m[13]*v[3],
        m[2]*v[0] + m[6]*v[1] + m[10]*v[2] + m[14]*v[3],
        m[3]*v[0] + m[7]*v[1] + m[11]*v[2] + m[15]*v[3]
      ];
    }
    function transformDirection(m, v){
      return normalize3({
        x: m[0]*v.x + m[4]*v.y + m[8]*v.z,
        y: m[1]*v.x + m[5]*v.y + m[9]*v.z,
        z: m[2]*v.x + m[6]*v.y + m[10]*v.z
      });
    }
    function mat4Invert(a){
      const out=new Float32Array(16);
      const a00=a[0], a01=a[1], a02=a[2], a03=a[3];
      const a10=a[4], a11=a[5], a12=a[6], a13=a[7];
      const a20=a[8], a21=a[9], a22=a[10], a23=a[11];
      const a30=a[12],a31=a[13],a32=a[14],a33=a[15];

      const b00 = a00 * a11 - a01 * a10;
      const b01 = a00 * a12 - a02 * a10;
      const b02 = a00 * a13 - a03 * a10;
      const b03 = a01 * a12 - a02 * a11;
      const b04 = a01 * a13 - a03 * a11;
      const b05 = a02 * a13 - a03 * a12;
      const b06 = a20 * a31 - a21 * a30;
      const b07 = a20 * a32 - a22 * a30;
      const b08 = a20 * a33 - a23 * a30;
      const b09 = a21 * a32 - a22 * a31;
      const b10 = a21 * a33 - a23 * a31;
      const b11 = a22 * a33 - a23 * a32;

      let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
      if (!det) return mat4Identity();
      det = 1.0 / det;

      out[0]  = ( a11 * b11 - a12 * b10 + a13 * b09) * det;
      out[1]  = (-a01 * b11 + a02 * b10 - a03 * b09) * det;
      out[2]  = ( a31 * b05 - a32 * b04 + a33 * b03) * det;
      out[3]  = (-a21 * b05 + a22 * b04 - a23 * b03) * det;
      out[4]  = (-a10 * b11 + a12 * b08 - a13 * b07) * det;
      out[5]  = ( a00 * b11 - a02 * b08 + a03 * b07) * det;
      out[6]  = (-a30 * b05 + a32 * b02 - a33 * b01) * det;
      out[7]  = ( a20 * b05 - a22 * b02 + a23 * b01) * det;
      out[8]  = ( a10 * b10 - a11 * b08 + a13 * b06) * det;
      out[9]  = (-a00 * b10 + a01 * b08 - a03 * b06) * det;
      out[10] = ( a30 * b04 - a31 * b02 + a33 * b00) * det;
      out[11] = (-a20 * b04 + a21 * b02 - a23 * b00) * det;
      out[12] = (-a10 * b09 + a11 * b07 - a12 * b06) * det;
      out[13] = ( a00 * b09 - a01 * b07 + a02 * b06) * det;
      out[14] = (-a30 * b03 + a31 * b01 - a32 * b00) * det;
      out[15] = ( a20 * b03 - a21 * b01 + a22 * b00) * det;
      return out;
    }
    function mat4Invert(a){
      const out=new Float32Array(16);
      const a00=a[0], a01=a[1], a02=a[2], a03=a[3];
      const a10=a[4], a11=a[5], a12=a[6], a13=a[7];
      const a20=a[8], a21=a[9], a22=a[10], a23=a[11];
      const a30=a[12], a31=a[13], a32=a[14], a33=a[15];

      const b00 = a00 * a11 - a01 * a10;
      const b01 = a00 * a12 - a02 * a10;
      const b02 = a00 * a13 - a03 * a10;
      const b03 = a01 * a12 - a02 * a11;
      const b04 = a01 * a13 - a03 * a11;
      const b05 = a02 * a13 - a03 * a12;
      const b06 = a20 * a31 - a21 * a30;
      const b07 = a20 * a32 - a22 * a30;
      const b08 = a20 * a33 - a23 * a30;
      const b09 = a21 * a32 - a22 * a31;
      const b10 = a21 * a33 - a23 * a31;
      const b11 = a22 * a33 - a23 * a32;

      let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
      if (!det) return mat4Identity();
      det = 1.0 / det;

      out[0] = ( a11 * b11 - a12 * b10 + a13 * b09) * det;
      out[1] = (-a01 * b11 + a02 * b10 - a03 * b09) * det;
      out[2] = ( a31 * b05 - a32 * b04 + a33 * b03) * det;
      out[3] = (-a21 * b05 + a22 * b04 - a23 * b03) * det;
      out[4] = (-a10 * b11 + a12 * b08 - a13 * b07) * det;
      out[5] = ( a00 * b11 - a02 * b08 + a03 * b07) * det;
      out[6] = (-a30 * b05 + a32 * b02 - a33 * b01) * det;
      out[7] = ( a20 * b05 - a22 * b02 + a23 * b01) * det;
      out[8] = ( a10 * b10 - a11 * b08 + a13 * b06) * det;
      out[9] = (-a00 * b10 + a01 * b08 - a03 * b06) * det;
      out[10]= ( a30 * b04 - a31 * b02 + a33 * b00) * det;
      out[11]= (-a20 * b04 + a21 * b02 - a23 * b00) * det;
      out[12]= (-a10 * b09 + a11 * b07 - a12 * b06) * det;
      out[13]= ( a00 * b09 - a01 * b07 + a02 * b06) * det;
      out[14]= (-a30 * b03 + a31 * b01 - a32 * b00) * det;
      out[15]= ( a20 * b03 - a21 * b01 + a22 * b00) * det;
      return out;
    }
    function mat4Transpose(m){
      const out=new Float32Array(16);
      out[0]=m[0]; out[1]=m[4]; out[2]=m[8]; out[3]=m[12];
      out[4]=m[1]; out[5]=m[5]; out[6]=m[9]; out[7]=m[13];
      out[8]=m[2]; out[9]=m[6]; out[10]=m[10]; out[11]=m[14];
      out[12]=m[3]; out[13]=m[7]; out[14]=m[11]; out[15]=m[15];
      return out;
    }

    // Geometry
    function createBox(minX,maxX,minY,maxY,minZ,maxZ){
      const positions=[
        minX,minY,maxZ,  maxX,minY,maxZ,  maxX,maxY,maxZ,  minX,maxY,maxZ, // front
        maxX,minY,minZ,  minX,minY,minZ,  minX,maxY,minZ,  maxX,maxY,minZ, // back
        minX,minY,minZ,  minX,minY,maxZ,  minX,maxY,maxZ,  minX,maxY,minZ, // left
        maxX,minY,maxZ,  maxX,minY,minZ,  maxX,maxY,minZ,  maxX,maxY,maxZ, // right
        minX,maxY,maxZ,  maxX,maxY,maxZ,  maxX,maxY,minZ,  minX,maxY,minZ, // top
        minX,minY,minZ,  maxX,minY,minZ,  maxX,minY,maxZ,  minX,minY,maxZ  // bottom
      ];
      const normals=[
        0,0,1,0,0,1,0,0,1,0,0,1,
        0,0,-1,0,0,-1,0,0,-1,0,0,-1,
        -1,0,0,-1,0,0,-1,0,0,-1,0,0,
        1,0,0,1,0,0,1,0,0,1,0,0,
        0,1,0,0,1,0,0,1,0,0,1,0,
        0,-1,0,0,-1,0,0,-1,0,0,-1,0
      ];
      const indices=[];
      for(let i=0;i<6;i++){
        const o=i*4;
        indices.push(o,o+1,o+2, o,o+2,o+3);
      }
      return {positions,normals,indices};
    }

    function createFrustum(base, top, height, includeBottom=true){
      const hb=base/2, ht=top/2;
      const y0=0, y1=height;
      const positions=[
        -hb,y0,hb,  hb,y0,hb,  ht,y1,ht,  -ht,y1,ht, // front
        hb,y0,hb,  hb,y0,-hb,  ht,y1,-ht,  ht,y1,ht, // right
        hb,y0,-hb, -hb,y0,-hb, -ht,y1,-ht, ht,y1,-ht, // back
        -hb,y0,-hb, -hb,y0,hb, -ht,y1,ht, -ht,y1,-ht, // left
        -ht,y1,ht,  ht,y1,ht,  ht,y1,-ht, -ht,y1,-ht, // top
        -hb,y0,-hb, hb,y0,-hb, hb,y0,hb, -hb,y0,hb    // bottom
      ];
      const normals=[];
      const faceNormals=[
        normalize3({x:0,y:0.6,z:1}),
        normalize3({x:1,y:0.6,z:0}),
        normalize3({x:0,y:0.6,z:-1}),
        normalize3({x:-1,y:0.6,z:0}),
        {x:0,y:1,z:0},
        {x:0,y:-1,z:0}
      ];
      for(const n of faceNormals){
        for(let i=0;i<4;i++) normals.push(n.x,n.y,n.z);
      }
      const indices=[];
      const faceCount = includeBottom ? 6 : 5;
      for(let i=0;i<faceCount;i++){
        const o=i*4;
        indices.push(o,o+1,o+2, o,o+2,o+3);
      }
      return {positions,normals,indices};
    }

    function createSphere(radius, latBands=18, lonBands=18){
      const positions=[], normals=[], indices=[];
      for(let lat=0;lat<=latBands;lat++){
        const theta=lat*Math.PI/latBands;
        const sinT=Math.sin(theta), cosT=Math.cos(theta);
        for(let lon=0;lon<=lonBands;lon++){
          const phi=lon*2*Math.PI/lonBands;
          const sinP=Math.sin(phi), cosP=Math.cos(phi);
          const x=cosP*sinT, y=cosT, z=sinP*sinT;
          positions.push(radius*x, radius*y, radius*z);
          normals.push(x,y,z);
        }
      }
      for(let lat=0;lat<latBands;lat++){
        for(let lon=0;lon<lonBands;lon++){
          const first=lat*(lonBands+1)+lon;
          const second=first+lonBands+1;
          indices.push(first,second,first+1, second,second+1,first+1);
        }
      }
      return {positions,normals,indices};
    }

    // Shaders
    const vsSource=`
    attribute vec3 aPosition;
    attribute vec3 aNormal;
    uniform mat4 uMVP;
    uniform mat4 uModel;
    uniform mat4 uNormalMatrix;
    varying vec3 vNormal;
    varying vec3 vWorldPos;
    void main(){
      vNormal = mat3(uNormalMatrix) * aNormal;
      vWorldPos = (uModel * vec4(aPosition,1.0)).xyz;
      gl_Position = uMVP * vec4(aPosition,1.0);
    }`;
    const fsSource=`
    precision mediump float;
    varying vec3 vNormal;
    varying vec3 vWorldPos;
    uniform vec3 uLightDir;
    uniform vec3 uColor;
    uniform vec3 uAmbient;
    uniform float uAlpha;
    const int MAX_POINTS = 12;
    const int MAX_HOLES = 4;
    uniform int uPointCount;
    uniform vec3 uPointPos[MAX_POINTS];
    uniform float uPointIntensity[MAX_POINTS];
    uniform vec3 uPointColor[MAX_POINTS];
    uniform int uHoleCount;
    uniform vec3 uHoleCenters[MAX_HOLES];
    uniform float uHoleRadii[MAX_HOLES];
    uniform float uHoleSoftness[MAX_HOLES];
    void main(){
      vec3 n = normalize(vNormal);
      float diff = max(dot(n, normalize(uLightDir)), 0.0);
      vec3 color = uAmbient + uColor * diff;
      float holeMask = 1.0;
      for (int i=0; i<MAX_HOLES; ++i) {
        if (i >= uHoleCount) break;
        float radius = uHoleRadii[i];
        if (radius <= 0.0) continue;
        vec3 center = uHoleCenters[i];
        vec2 d = abs(vWorldPos.xz - center.xz);
        float dist = max(d.x, d.y);
        float feather = max(uHoleSoftness[i], 0.0001);
        float mask = smoothstep(radius - feather, radius, dist);
        if (dist < radius) discard;
        holeMask = min(holeMask, mask);
      }
      color *= holeMask;
      // Point lights from orbs
      for (int i=0; i<MAX_POINTS; ++i) {
        if (i >= uPointCount) break;
        vec3 L = uPointPos[i] - vWorldPos;
        float dist = length(L) + 1e-4;
        vec3 ld = L / dist;
        float halfLambert = dot(n, ld) * 0.5 + 0.5;
        float diffP = halfLambert * halfLambert;
        float ambient = 0.25;  // Minimum glow regardless of angle
        float lighting = ambient + (1.0 - ambient) * diffP;
        float atten = uPointIntensity[i] / (1.0 + dist * dist * 0.0008);
        color += uPointColor[i] * lighting * atten;
      }
      color = clamp(color, 0.0, 2.5);
      gl_FragColor = vec4(color, uAlpha);
    }`;

    function createShader(type, source){
      const s=gl.createShader(type);
      gl.shaderSource(s, source);
      gl.compileShader(s);
      if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){
        console.error(gl.getShaderInfoLog(s));
      }
      return s;
    }
    const vs=createShader(gl.VERTEX_SHADER, vsSource);
    const fs=createShader(gl.FRAGMENT_SHADER, fsSource);
    const program=gl.createProgram();
    gl.attachShader(program, vs);
    gl.attachShader(program, fs);
    gl.linkProgram(program);
    if(!gl.getProgramParameter(program, gl.LINK_STATUS)){
      console.error(gl.getProgramInfoLog(program));
    }
    gl.useProgram(program);
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

    const attribs={
      position: gl.getAttribLocation(program, 'aPosition'),
      normal: gl.getAttribLocation(program, 'aNormal')
    };
    const uniforms={
      mvp: gl.getUniformLocation(program, 'uMVP'),
      model: gl.getUniformLocation(program, 'uModel'),
      normalMatrix: gl.getUniformLocation(program, 'uNormalMatrix'),
      lightDir: gl.getUniformLocation(program, 'uLightDir'),
      color: gl.getUniformLocation(program, 'uColor'),
      ambient: gl.getUniformLocation(program, 'uAmbient'),
      alpha: gl.getUniformLocation(program, 'uAlpha'),
      pointCount: gl.getUniformLocation(program, 'uPointCount'),
      pointPos: gl.getUniformLocation(program, 'uPointPos'),
      pointIntensity: gl.getUniformLocation(program, 'uPointIntensity'),
      pointColor: gl.getUniformLocation(program, 'uPointColor'),
      holeCount: gl.getUniformLocation(program, 'uHoleCount'),
      holeCenters: gl.getUniformLocation(program, 'uHoleCenters[0]'),
      holeRadii: gl.getUniformLocation(program, 'uHoleRadii[0]'),
      holeSoftness: gl.getUniformLocation(program, 'uHoleSoftness[0]')
    };
    const MAX_HOLES = 4;
    const MAX_POINT_LIGHTS = 12;
    const holeCentersArr = new Float32Array(MAX_HOLES * 3);
    const holeRadiiArr = new Float32Array(MAX_HOLES);
    const holeSoftnessArr = new Float32Array(MAX_HOLES);

    function createMesh(geo){
      const vao=gl.createVertexArray();
      gl.bindVertexArray(vao);

      const pos=gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, pos);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(geo.positions), gl.STATIC_DRAW);
      gl.enableVertexAttribArray(attribs.position);
      gl.vertexAttribPointer(attribs.position,3,gl.FLOAT,false,0,0);

      const nor=gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, nor);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(geo.normals), gl.STATIC_DRAW);
      gl.enableVertexAttribArray(attribs.normal);
      gl.vertexAttribPointer(attribs.normal,3,gl.FLOAT,false,0,0);

      const idx=gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, idx);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(geo.indices), gl.STATIC_DRAW);

      return {vao, count: geo.indices.length};
    }

    // Scene params
    const plane = {
      w: 920,
      h: 920,
      tilt: { x: 0, y: 0 },
      targetTilt: { x: 0, y: 0 },
      maxTilt: 0.8,
      wallHeight: 35,
      wallThickness: 14
    };
    const marble = {
      r: 25,
      pos: { x: 0, z: 0 },
      vel: { x: 0, z: 0 },
      y: 0,
      vy: 0
    };
    const pedestal = {
      topSize: marble.r * (8 / 3),
      ramp: marble.r * (8 / 3),
      height: marble.r * (4 / 3),
      slopeGravity: 420
    };
    const pedestalFootprint = pedestal.topSize * 0.5 + pedestal.ramp;
    const pedestalGridCount = 3;
    const pedestalGridSpacing = (() => {
      const totalPedestalWidth = pedestalFootprint * 2 * pedestalGridCount;
      const gap = Math.max(0, (Math.min(plane.w, plane.h) - totalPedestalWidth) / (pedestalGridCount + 1));
      return pedestalFootprint * 2 + gap;
    })();
    const pedestalGrid = {
      count: pedestalGridCount,
      spacing: pedestalGridSpacing
    };
    const pedestalReferencePositions = (() => {
      const arr=[];
      const offset = (pedestalGrid.count - 1) * 0.5;
      for(let i=0;i<pedestalGrid.count;i++){
        for(let j=0;j<pedestalGrid.count;j++){
          arr.push({
            x: (i - offset) * pedestalGrid.spacing,
            z: (j - offset) * pedestalGrid.spacing
          });
        }
      }
      return arr;
    })();
    const centralPedestalIndex = pedestalReferencePositions.findIndex(p => Math.abs(p.x) < 1e-3 && Math.abs(p.z) < 1e-3);
    const topLeftPedestalIndex = pedestalReferencePositions.findIndex(p => p.x < 0 && p.z < 0);
    const topRightPedestalIndex = pedestalReferencePositions.findIndex(p => p.x < 0 && p.z > 0);
    const bottomLeftPedestalIndex = pedestalReferencePositions.findIndex(p => p.x > 0 && p.z < 0);
    const bottomRightPedestalIndex = pedestalReferencePositions.findIndex(p => p.x > 0 && p.z > 0);
    const levelDrop = plane.w;
    const collapseConfig = { speed: 0.5 };
    const approachFadeDepth = levelDrop * 0.65;
    const centralHoleRadius = pedestalFootprint * 1.05;
    const centralHoleSoftness = pedestal.ramp * 0.35;

    // ===========================================
    // LEVEL CONFIGURATION - Add new levels here!
    // ===========================================
    const levelConfigs = [
      {
        // Level 0 - Blue
        hasHole: true,
        pedestals: [centralPedestalIndex],
        colors: {
          floor: [0.07, 0.28, 0.7],
          wall: [0.08, 0.22, 0.6],
          pedestal: [0.1, 0.35, 0.8],
          pedestalHole: [0.05, 0.18, 0.5]
        },
        orbCount: 1,
        orbsToCollapse: 1,
        wild: false
      },
      {
        // Level 1 - Red
        hasHole: true,
        pedestals: [topLeftPedestalIndex, bottomRightPedestalIndex],
        colors: {
          floor: [0.78, 0.32, 0.34],
          wall: [0.78, 0.32, 0.34],
          pedestal: [0.78, 0.32, 0.34],
          pedestalHole: [0.78, 0.32, 0.34]
        },
        orbCount: 1,
        orbsToCollapse: 2,
        wild: false
      },
      {
        // Level 2 - Green
        hasHole: true,
        pedestals: [topLeftPedestalIndex, topRightPedestalIndex, bottomLeftPedestalIndex, bottomRightPedestalIndex],
        colors: {
          floor: [0.18, 0.58, 0.32],
          wall: [0.16, 0.48, 0.26],
          pedestal: [0.22, 0.68, 0.36],
          pedestalHole: [0.12, 0.42, 0.24]
        },
        orbCount: 2,
        orbsToCollapse: 4,
        wild: true
      },
      {
        // Level 3 - Purple (diagonal pedestals, requires exactly 3 orbs)
        hasHole: true,
        pedestals: [0, 4, 8],
        colors: {
          floor: [0.55, 0.35, 0.65],
          wall: [0.45, 0.28, 0.55],
          pedestal: [0.62, 0.42, 0.72],
          pedestalHole: [0.38, 0.22, 0.48]
        },
        orbCount: 0,
        orbsToCollapse: 3,
        wild: false
      },
      {
        // Level 4 - Gold final level (no pedestals)
        hasHole: false,
        pedestals: [],
        colors: {
          floor: [0.75, 0.5, 0.15],
          wall: [0.65, 0.43, 0.12],
          pedestal: [0.85, 0.57, 0.18],
          pedestalHole: [0.55, 0.36, 0.1]
        },
        orbCount: 0,
        orbsToCollapse: null, // final level
        wild: false
      }
    ];

    // Derived arrays (for compatibility with existing code)
    const levels = levelConfigs.map((cfg, i) => {
      const layout = cfg.pedestals.filter(idx => idx >= 0);
      return {
        y: -levelDrop * i,
        hasHole: cfg.hasHole,
        index: i,
        pedestalIndices: layout,
        pedestals: layout.map(idx => pedestalReferencePositions[idx]).filter(Boolean)
      };
    });
    const pedestalLayouts = levelConfigs.map(cfg => cfg.pedestals.filter(idx => idx >= 0));
    const boardColors = levelConfigs.map(cfg => cfg.colors);
    const pedestalCollapses = levelConfigs
      .map((cfg, i) => cfg.orbsToCollapse !== null ? {
        levelIndex: i,
        pedestals: pedestalLayouts[i],
        started: false,
        progress: 0,
        wild: cfg.wild,
        exactOrbs: cfg.exactOrbs ?? !cfg.wild
      } : null)
      .filter(Boolean);
    const orbsRequiredForCollapse = levelConfigs
      .filter(cfg => cfg.orbsToCollapse !== null)
      .map(cfg => cfg.orbsToCollapse);

    const mouseAttractor = {
      active: false,
      target: { x: 0, z: 0 },
      strength: 480
    };
    const orbConfig = {
      r: 12,
      countPerLevel: levelConfigs.map(cfg => cfg.orbCount),
      minCenterDistance: 220,
      touchRadius: 22,
      satelliteCount: 1
    };
    const orbFollowTransition = 0.75;
    const orbCollectFlashDuration = 0.35;
    const followingOrbLift = orbConfig.r * 0.5;
    const orbs = [];
    const keys = new Set();
    const history = [];
    const maxHistoryFrames = 3600; // ~60s at 60fps
    const starHistory = [];
    const maxStarHistoryFrames = 180; // ~3s at 60fps for accurate star reversal
    let starsReversed = false;
    const rewindSpeed = 1.5;
    let rewindAccumulator = 0;
    const orbCollectionDim = { maxCount: 4, minBrightness: 0.3 }; // adjust minBrightness to change how dim orbs get at full collection
    let orbAnimTime = 0;
    let currentSupport = null;
    let lastGroundedLevel = null;
    let lastGroundSurfaceHeight = null;
    let paused = false;
    let rafId = null;

    function captureState() {
      return {
        marble: {
          pos: { x: marble.pos.x, z: marble.pos.z },
          vel: { x: marble.vel.x, z: marble.vel.z },
          y: marble.y,
          vy: marble.vy
        },
        plane: {
          tilt: { x: plane.tilt.x, y: plane.tilt.y },
          target: { x: plane.targetTilt.x, y: plane.targetTilt.y }
        },
        mouseAttractor: {
          active: mouseAttractor.active,
          target: { x: mouseAttractor.target.x, z: mouseAttractor.target.z }
        },
        orbs: orbs.map(o => ({
          pos: { x: o.pos.x, y: o.pos.y, z: o.pos.z },
          level: o.level,
          renderLevel: o.renderLevel ?? o.level,
          collected: o.collected,
          collectFlash: o.collectFlash || 0,
          dissolve: o.dissolve,
          following: !!o.following,
          followProgress: o.followProgress ?? 1,
          followStart: o.followStart ? { x: o.followStart.x, y: o.followStart.y, z: o.followStart.z } : null,
          vel: { x: o.vel?.x || 0, y: o.vel?.y || 0, z: o.vel?.z || 0 },
          orbitPhase: o.orbitPhase,
          orbitRadius: o.orbitRadius,
          orbitHeight: o.orbitHeight,
          orbitSpeed: o.orbitSpeed
        })),
        collapses: pedestalCollapses.map(c => ({ started: c.started, progress: c.progress })),
        orbAnimTime,
        levelIndex: getActiveLevel()?.index ?? 0,
        levelTransition: (() => {
          const currentLevel = getActiveLevel();
          const currentIndex = currentLevel?.index ?? 0;
          const nextIndex = currentIndex + 1;
          if (nextIndex >= levels.length) return 0;
          const currentY = currentLevel?.y ?? 0;
          const nextY = levels[nextIndex].y;
          const progress = (currentY - marble.y) / (currentY - nextY);
          return clamp01(progress);
        })()
      };
    }

    function applyState(state) {
      marble.pos.x = state.marble.pos.x;
      marble.pos.z = state.marble.pos.z;
      marble.vel.x = state.marble.vel.x;
      marble.vel.z = state.marble.vel.z;
      marble.y = state.marble.y;
      marble.vy = state.marble.vy;
      plane.tilt.x = state.plane.tilt.x;
      plane.tilt.y = state.plane.tilt.y;
      plane.targetTilt.x = state.plane.target.x;
      plane.targetTilt.y = state.plane.target.y;
      if (state.mouseAttractor) {
        mouseAttractor.active = !!state.mouseAttractor.active;
        mouseAttractor.target.x = state.mouseAttractor.target?.x ?? mouseAttractor.target.x;
        mouseAttractor.target.z = state.mouseAttractor.target?.z ?? mouseAttractor.target.z;
      }
      orbAnimTime = state.orbAnimTime ?? orbAnimTime;
      state.orbs.forEach((o,i) => {
        if (orbs[i]) {
          // Wild orbs stay collected once collected, but still update position for smooth rewind
          if (orbs[i].wild) {
            if (orbs[i].collected) {
              // Always update orbit parameters
              orbs[i].orbitRadius = o.orbitRadius ?? orbs[i].orbitRadius ?? 40;
              orbs[i].orbitHeight = o.orbitHeight ?? orbs[i].orbitHeight ?? 12;
              orbs[i].orbitSpeed = o.orbitSpeed ?? orbs[i].orbitSpeed ?? 1.2;

              if (o.collected) {
                // Historical state also collected - restore position and orbitPhase from history
                orbs[i].pos.x = o.pos.x;
                orbs[i].pos.y = o.pos.y;
                orbs[i].pos.z = o.pos.z;
                orbs[i].orbitPhase = o.orbitPhase ?? orbs[i].orbitPhase ?? 0;
                orbs[i]._rewindPastCollection = false;
                if (o.followStart) {
                  orbs[i].followStart = {
                    x: o.followStart.x ?? orbs[i].pos.x,
                    y: o.followStart.y ?? orbs[i].pos.y,
                    z: o.followStart.z ?? orbs[i].pos.z
                  };
                }
              } else {
                // Rewinding past collection - flag for updateWildOrbs to calculate position
                // Start lerp if this is the first frame past collection
                if (!orbs[i]._rewindPastCollection) {
                  orbs[i]._rewindLerpStart = { x: orbs[i].pos.x, y: orbs[i].pos.y, z: orbs[i].pos.z };
                  orbs[i]._rewindLerpProgress = 0;
                }
                orbs[i]._rewindPastCollection = true;
              }
              orbs[i].vel = { x: 0, y: 0, z: 0 };
            }
            return;
          }
          orbs[i].pos.x = o.pos.x;
          orbs[i].pos.y = o.pos.y;
          orbs[i].pos.z = o.pos.z;
          orbs[i].collected = o.collected;
          orbs[i].collectFlash = o.collectFlash || 0;
          orbs[i].dissolve = o.dissolve || 0;
          orbs[i].level = o.level ?? orbs[i].level;
          orbs[i].renderLevel = o.renderLevel ?? orbs[i].renderLevel ?? orbs[i].level;
          orbs[i].following = !!o.following;
          orbs[i].followProgress = o.followProgress ?? orbs[i].followProgress ?? 1;
          if (o.followStart) {
            orbs[i].followStart = {
              x: o.followStart.x ?? orbs[i].pos.x,
              y: o.followStart.y ?? orbs[i].pos.y,
              z: o.followStart.z ?? orbs[i].pos.z
            };
          } else if (!orbs[i].followStart && o.collected) {
            orbs[i].followStart = { x: orbs[i].pos.x, y: orbs[i].pos.y, z: orbs[i].pos.z };
          }
          const vx = o.vel?.x ?? orbs[i].vel?.x ?? 0;
          const vy = o.vel?.y ?? orbs[i].vel?.y ?? 0;
          const vz = o.vel?.z ?? orbs[i].vel?.z ?? 0;
          orbs[i].vel = { x: vx, y: vy, z: vz };
          orbs[i].orbitPhase = o.orbitPhase ?? orbs[i].orbitPhase ?? 0;
          orbs[i].orbitRadius = o.orbitRadius ?? orbs[i].orbitRadius ?? 40;
          orbs[i].orbitHeight = o.orbitHeight ?? orbs[i].orbitHeight ?? 12;
          orbs[i].orbitSpeed = o.orbitSpeed ?? orbs[i].orbitSpeed ?? 1.2;
        }
      });
      if (Array.isArray(state.collapses)) {
        // Calculate orb count after rewind (wild orbs stay collected, regular orbs restored from history)
        const totalCollectedAfterRewind = orbs.filter(o => o.collected).length;

        state.collapses.forEach((c, i) => {
          if (pedestalCollapses[i]) {
            // Wild pedestals never revert their collapse - once collapsed, stay collapsed
            if (pedestalCollapses[i].wild && pedestalCollapses[i].started) {
              return;
            }

            // During rewind, don't reopen pedestals if orb count doesn't meet requirement
            const collapse = pedestalCollapses[i];
            const required = orbsRequiredForCollapse[collapse.levelIndex] ?? Infinity;
            const meetsRequirement = collapse.exactOrbs
              ? totalCollectedAfterRewind === required
              : totalCollectedAfterRewind >= required;

            // If requirement not met, don't restore a more-open state (prevent reopening)
            if (!meetsRequirement && (c.progress ?? 0) > collapse.progress) {
              return;
            }

            pedestalCollapses[i].started = !!c.started;
            pedestalCollapses[i].progress = c.progress ?? pedestalCollapses[i].progress;
          }
        });
      }
    }

    function captureStarState() {
      return stars.map(s => ({ x: s.x, y: s.y, vx: s.vx, vy: s.vy, size: s.size, alpha: s.alpha }));
    }

    function applyStarState(starState) {
      stars.length = starState.length;
      for (let i = 0; i < starState.length; i++) {
        const src = starState[i];
        let dst = stars[i];
        if (!dst) dst = stars[i] = { x: 0, y: 0, vx: 0, vy: 0, size: 1, alpha: 1 };
        dst.x = src.x;
        dst.y = src.y;
        dst.vx = src.vx;
        dst.vy = src.vy;
        dst.size = src.size;
        dst.alpha = src.alpha;
      }
    }

    function reverseStarVelocities() {
      for (const star of stars) {
        star.vx = -star.vx;
        star.vy = -star.vy;
      }
    }

    function pushHistory() {
      history.push(captureState());
      if (history.length > maxHistoryFrames) history.shift();
      // Separate star history with shorter duration
      starHistory.push(captureStarState());
      if (starHistory.length > maxStarHistoryFrames) starHistory.shift();
    }

    function wouldCrossClosedPedestal(nextState) {
      const nextY = nextState.marble.y;
      const currentY = marble.y;

      // Only check if rewinding upward
      if (nextY <= currentY) return false;

      // Calculate orb count after applying orb state (wild orbs stay collected)
      const totalCollectedAfterRewind = orbs.reduce((count, orb, i) => {
        if (orb.wild && orb.collected) return count + 1;
        return count + (nextState.orbs[i]?.collected ? 1 : 0);
      }, 0);

      // Check if crossing any level boundary going upward
      for (let i = 0; i < levels.length; i++) {
        const level = levels[i];
        const collapse = collapseStateFor(i);
        if (!collapse) continue;

        // Wild pedestals, once opened, always allow passage
        if (collapse.wild && collapse.started) continue;

        const levelY = level.y;
        // Block about a marble's diameter below the hole
        const blockingY = levelY - marble.r * 2;

        // Check if crossing from below to above this level's floor
        if (currentY < blockingY && nextY >= blockingY) {
          const required = orbsRequiredForCollapse[collapse.levelIndex] ?? Infinity;
          const meetsRequirement = collapse.exactOrbs
            ? totalCollectedAfterRewind === required
            : totalCollectedAfterRewind >= required;

          if (!meetsRequirement) {
            return true;
          }
        }
      }

      return false;
    }

    function rewindStep() {
      if (history.length > 1) {
        const nextState = history[history.length - 2];

        // Block rewind if it would cross a closed pedestal opening
        if (nextState && wouldCrossClosedPedestal(nextState)) {
          return true; // blocked
        }

        history.pop(); // discard current
        const restoredState = history[history.length - 1];
        applyState(restoredState);

        // Update lastGroundedLevel to match the restored state's level
        // This prevents stale level references after rewinding mid-fall
        const levelIdx = restoredState.levelIndex ?? 0;
        if (levels[levelIdx]) {
          lastGroundedLevel = levels[levelIdx];
        }
      }
      // Handle star rewind separately
      if (starHistory.length > 1) {
        starHistory.pop();
        applyStarState(starHistory[starHistory.length - 1]);
        starsReversed = false;
      } else if (!starsReversed) {
        // Star history exhausted - reverse velocities for approximate rewind effect
        reverseStarVelocities();
        starsReversed = true;
      }
      return false; // not blocked
    }

    function stopLoop() {
      if (rafId !== null) {
        cancelAnimationFrame(rafId);
        rafId = null;
      }
    }

    function resumeLoop(resetClock=false) {
      if (resetClock) frame.last = performance.now() * 0.001;
      if (rafId === null && !paused) {
        rafId = requestAnimationFrame(frame);
      }
    }

    function setPaused(state) {
      if (state === paused) return;
      paused = state;
      if (paused) {
        stopLoop();
        frame.last = null;
      } else {
        resumeLoop(true);
      }
    }

    function togglePause() {
      setPaused(!paused);
    }

    function checkOrbCollisions() {
      const currentLevelIndex = getActiveLevel()?.index ?? 0;
      for (const orb of orbs) {
        if (orb.level !== currentLevelIndex) continue;
        if (orb.collected) continue;
        const dx = marble.pos.x - orb.pos.x;
        const dz = marble.pos.z - orb.pos.z;
        const dist = Math.hypot(dx, dz);
        const touch = orbConfig.touchRadius || orbConfig.r;
        if (dist <= marble.r + touch) {
          orb.collected = true;
          orb.collectFlash = orbCollectFlashDuration;
          orb.dissolve = 0;
          orb.following = true;
          orb.followProgress = 0;
          orb.followStart = { x: orb.pos.x, y: orb.pos.y, z: orb.pos.z };
          const activeLevel = getActiveLevel();
          orb.renderLevel = activeLevel?.index ?? orb.level;
          const angleToMarble = Math.atan2(orb.pos.z - marble.pos.z, orb.pos.x - marble.pos.x);
          if (!Number.isFinite(orb.orbitPhase)) {
            orb.orbitPhase = Number.isFinite(angleToMarble) ? angleToMarble : Math.random() * Math.PI * 2;
          }
          if (!Number.isFinite(orb.orbitRadius)) orb.orbitRadius = 36 + Math.random() * 12;
          if (!Number.isFinite(orb.orbitHeight)) orb.orbitHeight = 10 + Math.random() * 5;
          if (!Number.isFinite(orb.orbitSpeed)) orb.orbitSpeed = 1 + Math.random() * 0.8;
          if (!orb.vel) orb.vel = { x: 0, y: 0, z: 0 };
        }
      }
    }

    function applyOrbFloorClamp(orb, renderLevelIndex) {
      const level = levels[renderLevelIndex];
      if (!level) return;
      const ground = levelHeightAt(level, orb.pos.x, orb.pos.z);
      if (!Number.isFinite(ground)) return; // let orbs fall through holes
      const levelY = level.y || 0;
      const clearance = (orbConfig.r || 12) * 0.6;
      const floorLocal = (ground - levelY) + clearance;
      const distAbove = orb.pos.y - floorLocal;
      const approachZone = clearance * 3;
      // Feather the downward speed as we approach the floor to avoid hard stops
      if (distAbove < approachZone && orb.vel.y < 0) {
        const t = Math.max(0, Math.min(1, 1 - distAbove / approachZone));
        const damp = 1 - 0.5 * t;
        orb.vel.y *= damp;
      }
      if (distAbove < 0) {
        // Nudge back to the safe band and kill downward velocity
        orb.pos.y = floorLocal;
        if (orb.vel.y < 0) orb.vel.y = 0;
      }
    }

    function updateOrbs(dt) {
      const activeLevel = getActiveLevel() || levels[0];
      const renderLevelIndex = activeLevel?.index ?? 0;
      const renderLevelY = activeLevel?.y || 0;
      for (const orb of orbs) {
        if (!orb.collected) continue;
        orb.following = true;
        orb.dissolve = 0;
        if (orb.collectFlash > 0) {
          orb.collectFlash = Math.max(0, orb.collectFlash - dt);
        }
        const prevRenderLevel = orb.renderLevel ?? renderLevelIndex;
        const prevLevelY = levels[prevRenderLevel]?.y || 0;
        if (prevRenderLevel !== renderLevelIndex) {
          // Preserve world-space height when re-parenting to a new level frame
          const worldY = orb.pos.y + prevLevelY;
          orb.pos.y = worldY - renderLevelY;
        }
        orb.renderLevel = renderLevelIndex;
        const rawProgress = orb.followProgress ?? 1;
        const nextProgress = clamp01(rawProgress + dt / orbFollowTransition);
        orb.followProgress = nextProgress;
        const followEase = smoothstep01(nextProgress);
        if (!orb.vel) orb.vel = { x: 0, y: 0, z: 0 };
        const radius = orb.orbitRadius || 40;
        const speed = orb.orbitSpeed || 1.2;
        const height = orb.orbitHeight || 12;
        orb.orbitPhase = (orb.orbitPhase ?? 0) + dt * speed;
        const angle = orb.orbitPhase;
        const bob = Math.sin(orbAnimTime * 2 + (orb.seed || 0)) * 2;
        const targetX = marble.pos.x + Math.cos(angle) * radius;
        const targetZ = marble.pos.z + Math.sin(angle) * radius;
        const targetY = (marble.y - renderLevelY) + height + bob;
        const anchor = orb.followStart || orb.pos;
        const blendedTargetX = anchor.x + (targetX - anchor.x) * followEase;
        const blendedTargetY = anchor.y + (targetY - anchor.y) * followEase;
        const blendedTargetZ = anchor.z + (targetZ - anchor.z) * followEase;
        const dx = blendedTargetX - orb.pos.x;
        const dy = blendedTargetY - orb.pos.y;
        const dz = blendedTargetZ - orb.pos.z;
        const dist = Math.hypot(dx, dy, dz) || 1;
        const pull = 2000;
        const accel = pull * Math.min(1, dist / 220);
        orb.vel.x += (dx / dist) * accel * dt;
        orb.vel.y += (dy / dist) * accel * dt;
        orb.vel.z += (dz / dist) * accel * dt;
        const drag = Math.exp(-dt * 4);
        orb.vel.x *= drag;
        orb.vel.y *= drag;
        orb.vel.z *= drag;
        orb.pos.x += orb.vel.x * dt;
        orb.pos.y += orb.vel.y * dt;
        orb.pos.z += orb.vel.z * dt;
        applyOrbFloorClamp(orb, renderLevelIndex);
      }
    }

    // Update only wild orbs during rewind - calculates position relative to marble
    function updateWildOrbs(dt) {
      const activeLevel = getActiveLevel() || levels[0];
      const renderLevelIndex = activeLevel?.index ?? 0;
      const renderLevelY = activeLevel?.y || 0;
      for (const orb of orbs) {
        if (!orb.wild || !orb.collected) continue;
        orb.following = true;
        orb.dissolve = 0;
        orb.renderLevel = renderLevelIndex;
        orb.followProgress = 1;
        if (orb.collectFlash > 0) {
          orb.collectFlash = Math.max(0, orb.collectFlash - dt);
        }

        // If rewinding past collection, calculate position relative to marble
        // Otherwise position was restored from history in applyState
        if (orb._rewindPastCollection) {
          const speed = orb.orbitSpeed || 1.2;
          orb.orbitPhase = (orb.orbitPhase ?? 0) - dt * speed;

          const radius = orb.orbitRadius || 40;
          const height = orb.orbitHeight || 12;
          const angle = orb.orbitPhase ?? 0;
          const bob = Math.sin(orbAnimTime * 2 + (orb.seed || 0)) * 2;

          // Target position (where the orb should be relative to marble)
          const targetX = marble.pos.x + Math.cos(angle) * radius;
          const targetZ = marble.pos.z + Math.sin(angle) * radius;
          const targetY = (marble.y - renderLevelY) + height + bob;

          // Lerp from saved start position to target
          const lerpSpeed = 1; // Adjust for faster/slower transition
          orb._rewindLerpProgress = Math.min(1, (orb._rewindLerpProgress ?? 0) + dt * lerpSpeed);
          const t = smoothstep01(orb._rewindLerpProgress);

          if (orb._rewindLerpStart && t < 1) {
            orb.pos.x = orb._rewindLerpStart.x + (targetX - orb._rewindLerpStart.x) * t;
            orb.pos.y = orb._rewindLerpStart.y + (targetY - orb._rewindLerpStart.y) * t;
            orb.pos.z = orb._rewindLerpStart.z + (targetZ - orb._rewindLerpStart.z) * t;
          } else {
            orb.pos.x = targetX;
            orb.pos.y = targetY;
            orb.pos.z = targetZ;
          }
          orb.followStart = { x: orb.pos.x, y: orb.pos.y, z: orb.pos.z };
        }

        orb.vel = { x: 0, y: 0, z: 0 };
      }
    }

    function skipNextOrbBatch() {
      const orb = orbs.find(o => !o.collected);
      if (!orb) return;
      orb.collected = true;
      orb.dissolve = 1;
      console.log(`Debug: skipped orb`);
    }

    function collapseEase(t) {
      const clamped = Math.min(1, Math.max(0, t));
      return clamped * clamped * (3 - 2 * clamped);
    }

    function collapseStateFor(levelIndex=-1, pedestalIdx=null) {
      return pedestalCollapses.find(c => c.levelIndex === levelIndex && (pedestalIdx === null || c.pedestals.includes(pedestalIdx)));
    }

    function collapseProgressFor(levelIndex=-1, pedestalIdx=null) {
      const state = collapseStateFor(levelIndex, pedestalIdx);
      return state && state.started ? collapseEase(state.progress) : 0;
    }

    function pedestalCollapseAlpha(progress) {
      const fadeStart = 0.18; // keep visible while it starts folding, then fade out
      if (progress <= fadeStart) return 1;
      const t = (progress - fadeStart) / (1 - fadeStart);
      return Math.max(0, 1 - t);
    }

    function isWildPedestal(levelIndex) {
      const collapse = pedestalCollapses.find(c => c.levelIndex === levelIndex);
      return collapse?.wild ?? false;
    }

    function pedestalsForLevel(level=null) {
      const positions = level?.pedestals ?? pedestalReferencePositions;
      const indices = level?.pedestalIndices ?? positions.map((_, idx) => idx);
      const count = Math.min(positions.length, indices.length);
      const list = [];
      for (let i=0;i<count;i++) {
        list.push({ pos: positions[i], idx: indices[i] });
      }
      return list;
    }

    function pedestalHeightForIndex(idx, level=null) {
      const levelIndex = level?.index ?? 0;
      const collapseProgress = collapseProgressFor(levelIndex, idx);
      if (collapseProgress > 0) return pedestal.height * (1 - collapseProgress);
      return pedestal.height;
    }

    function pedestalHeightAtLocal(x, z, height=pedestal.height) {
      const halfTop = pedestal.topSize / 2;
      const ramp = pedestal.ramp;
      const maxHalf = halfTop + ramp;
      const dx = Math.abs(x);
      const dz = Math.abs(z);
      if (dx > maxHalf || dz > maxHalf) return -Infinity;
      if (dx <= halfTop && dz <= halfTop) return height;
      const t = Math.max(dx - halfTop, dz - halfTop);
      const ratio = 1 - Math.min(1, t / ramp);
      return height * ratio;
    }
    function pedestalHeightAt(x, z, level=null) {
      const pedestals = pedestalsForLevel(level);
      let maxH = -Infinity;
      for (const { pos, idx } of pedestals) {
        const h = pedestalHeightAtLocal(x - pos.x, z - pos.z, pedestalHeightForIndex(idx, level));
        if (h > maxH) maxH = h;
      }
      return maxH === -Infinity ? 0 : maxH;
    }
    function pedestalNormalAt(x, z, level=null) {
      const eps = 2;
      const h = pedestalHeightAt(x, z, level);
      const hx = pedestalHeightAt(x + eps, z, level) - pedestalHeightAt(x - eps, z, level);
      const hz = pedestalHeightAt(x, z + eps, level) - pedestalHeightAt(x, z - eps, level);
      return normalize3({ x: -hx, y: eps * 2, z: -hz });
    }

    function holesForLevel(level=null) {
      const levelIndex = level?.index ?? -1;
      const state = collapseStateFor(levelIndex);
      if (!state || !state.started) return [];
      const progress = collapseEase(state.progress);
      if (progress <= 0) return [];
      return state.pedestals
        .map(idx => {
          const center = pedestalReferencePositions[idx];
          if (!center) return null;
          return {
            center,
            radius: centralHoleRadius * progress,
            softness: centralHoleSoftness
          };
        })
        .filter(Boolean);
    }

    function isPointInHole(level, x, z) {
      const holes = holesForLevel(level);
      if (!holes.length) return false;
      for (const hole of holes) {
        const openRadius = hole.radius - (hole.softness ?? 0) * 0.35;
        if (openRadius <= 0) continue;
        const dx = Math.abs(x - hole.center.x);
        const dz = Math.abs(z - hole.center.z);
        const dist = Math.max(dx, dz);
        if (dist < openRadius) return true;
      }
      return false;
    }

    function levelHeightAt(level, x, z) {
      if (level.hasHole && isPointInHole(level, x, z)) return -Infinity;
      const h = pedestalHeightAt(x, z, level);
      return h + level.y;
    }

    function levelNormalAt(level, x, z) {
      const eps = 2;
      const h = levelHeightAt(level, x, z);
      if (!Number.isFinite(h)) return { x: 0, y: 1, z: 0 };
      const hx = levelHeightAt(level, x + eps, z) - levelHeightAt(level, x - eps, z);
      const hz = levelHeightAt(level, x, z + eps) - levelHeightAt(level, x, z - eps);
      return normalize3({ x: -hx, y: eps * 2, z: -hz });
    }

    function findSupportSurface(x, z, y) {
      let best = null;
      const maxRise = marble.r * 1.5;
      for (const level of levels) {
        const surface = levelHeightAt(level, x, z);
        if (!Number.isFinite(surface)) continue;
        if (surface > y + maxRise) continue; // ignore surfaces too far above current height
        if (!best || surface > best.height) {
          best = { level, height: surface };
        }
      }
      return best;
    }

    function calculateSupport(x, z, y) {
      const surface = findSupportSurface(x, z, y);
      const surfaceHeight = surface ? surface.height : -Infinity;
      const groundHeight = Number.isFinite(surfaceHeight) ? surfaceHeight + marble.r : -Infinity;
      const altitude = Number.isFinite(surfaceHeight) ? y - groundHeight : Infinity;
      const support = Number.isFinite(surfaceHeight) ? Math.max(0, Math.min(1, 1 - altitude / (marble.r * 1.5))) : 0;
      return {
        level: surface?.level || levels[0],
        surfaceHeight,
        groundHeight,
        altitude,
        support
      };
    }

    function refreshSupport() {
      currentSupport = calculateSupport(marble.pos.x, marble.pos.z, marble.y);
      if ((currentSupport?.support ?? 0) > 0.01 && Number.isFinite(currentSupport.surfaceHeight)) {
        lastGroundedLevel = currentSupport.level || lastGroundedLevel || levels[0];
        lastGroundSurfaceHeight = currentSupport.surfaceHeight;
      }
      return currentSupport;
    }

    function isAirborne() {
      const support = currentSupport?.support ?? 0;
      return !Number.isFinite(currentSupport?.surfaceHeight) || support < 0.01;
    }

    function updateCollapses(dt) {
      for (const collapse of pedestalCollapses) {
        const totalCollected = orbs.filter(o => o.collected).length;
        const required = orbsRequiredForCollapse[collapse.levelIndex] ?? Infinity;
        const meetsRequirement = collapse.exactOrbs
          ? totalCollected === required
          : totalCollected >= required;
        if (!collapse.started && meetsRequirement) {
          collapse.started = true;
        }
        // For exactOrbs, only progress while requirement is met; reverse if not
        if (collapse.exactOrbs) {
          if (meetsRequirement) {
            collapse.progress = Math.min(1, collapse.progress + dt * collapseConfig.speed);
          } else {
            collapse.progress = Math.max(0, collapse.progress - dt * collapseConfig.speed);
            if (collapse.progress === 0) collapse.started = false;
          }
        } else if (collapse.started) {
          collapse.progress = Math.min(1, collapse.progress + dt * collapseConfig.speed);
        }
      }
    }

    function lightLevelWeight(levelIndex=0) {
      const level = levels[levelIndex];
      if (!level) return 0;
      // Don't light lower levels until we're approaching them or the above level has collapsed
      if (level.index > 0) {
        const aboveCollapse = collapseStateFor(level.index - 1);
        if (!(aboveCollapse?.started ?? false) && marble.y > level.y + approachFadeDepth) return 0;
      }
      const heightAbove = Math.max(0, marble.y - level.y - marble.r * 2);
      const proximity = heightAbove <= 0 ? 1 : Math.max(0, 1 - heightAbove / approachFadeDepth);
      return proximity;
    }

    function collectionBrightnessFactor() {
      const maxCount = Math.max(1, orbCollectionDim.maxCount || 12);
      const minBrightness = Math.max(0, Math.min(1, orbCollectionDim.minBrightness ?? 0.5));
      const collected = orbs.filter(o => o.collected).length;
      const clampedCount = Math.min(maxCount, Math.max(1, collected));
      const t = (clampedCount - 1) / (maxCount - 1 || 1); // 0 when only one orb collected
      return 1 - t * (1 - minBrightness);
    }

    function updateLightsUniforms() {
      const positions = new Float32Array(MAX_POINT_LIGHTS * 3);
      const intensities = new Float32Array(MAX_POINT_LIGHTS);
      const colors = new Float32Array(MAX_POINT_LIGHTS * 3);
      const time = orbAnimTime;
      const collectionFactor = collectionBrightnessFactor();
      const candidates = [];
      for (const orb of orbs) {
        const renderLevelIndex = orb.following ? (orb.renderLevel ?? getActiveLevel()?.index ?? orb.level) : orb.level;
        const weight = lightLevelWeight(renderLevelIndex);
        if (weight <= 0) continue;
        if (orb.collected && orb.dissolve >= 1) continue;
        candidates.push({ orb, renderLevelIndex, weight });
      }
      candidates.sort((a, b) => {
        if (a.weight !== b.weight) return b.weight - a.weight;
        if (a.orb.collected !== b.orb.collected) return a.orb.collected ? 1 : -1;
        return (b.orb.collectFlash || 0) - (a.orb.collectFlash || 0);
      });
      let count = 0;
      for (const { orb, renderLevelIndex, weight } of candidates) {
        if (count >= MAX_POINT_LIGHTS) break;
        const followEase = smoothstep01(clamp01(orb.followProgress ?? 1));
        const brightnessScale = orb.collected ? (1 - 0.5 * followEase) : 1;
        const baseStrength = orb.collected ? Math.max(0, 1 - orb.dissolve) * brightnessScale : 1.0;
        const flash = orb.collectFlash ? clamp01(orb.collectFlash / orbCollectFlashDuration) : 0;
        const flashBoost = orbFlashEnvelope(flash);
        const strength = baseStrength * orbGlowPulse(orb, time) * (1 + flashBoost * 1.0) * weight * collectionFactor;
        const levelY = levels[renderLevelIndex]?.y || 0;
        const satOffset = (orb.sats && orb.sats.length) ? satelliteOffset(orb.sats[0], time, 0) : null;
        const rawX = satOffset ? orb.pos.x + satOffset.x : orb.pos.x;
        const rawY = satOffset ? orb.pos.y + satOffset.y : orb.pos.y;
        const rawZ = satOffset ? orb.pos.z + satOffset.z : orb.pos.z;
        // Transform orb position by board tilt to match floor coordinate space
        const boardM = boardTransform(levelY);
        const transformed = mat4TransformVec4(boardM, [rawX, rawY, rawZ, 1]);
        positions[count*3+0] = transformed[0];
        positions[count*3+1] = transformed[1];
        positions[count*3+2] = transformed[2];
        intensities[count] = strength;
        // Light color: warm for regular orbs, cycling blue/magenta for wild
        if (orb.wild) {
          const t = time * 0.8 + (orb.seed || 0);
          const wave = (Math.sin(t * Math.PI * 2) + 1) * 0.5;
          colors[count*3+0] = 1.0 + wave * 0.8; // Red: 1.0 to 1.8
          colors[count*3+1] = 0.6;              // More green for brightness
          colors[count*3+2] = 1.8;              // Very strong blue
        } else {
          colors[count*3+0] = 1.1;  // Warm
          colors[count*3+1] = 0.95;
          colors[count*3+2] = 0.5;
        }
        count++;
      }
      gl.uniform1i(uniforms.pointCount, count);
      gl.uniform3fv(uniforms.pointPos, positions);
      gl.uniform1fv(uniforms.pointIntensity, intensities);
      gl.uniform3fv(uniforms.pointColor, colors);
    }

    function spawnOrbsForLevel(levelIndex=0) {
      const level = levels[levelIndex] || levels[0];
      const margin = marble.r + orbConfig.r * 2 + 20;
      const centerGuard = orbConfig.minCenterDistance;
      function randomPos() {
        return {
          x: (Math.random() * 2 - 1) * (plane.w / 2 - margin),
          z: (Math.random() * 2 - 1) * (plane.h / 2 - margin)
        };
      }
      const countForLevel = () => orbs.filter(o => o.level === levelIndex).length;
      const targetCount = orbConfig.countPerLevel?.[levelIndex] ?? 0;
      while (countForLevel() < targetCount) {
        const p = randomPos();
        if (Math.hypot(p.x, p.z) < centerGuard) continue;
        let ok = true;
        for (const o of orbs) {
          const dx = o.pos.x - p.x;
          const dz = o.pos.z - p.z;
          if (Math.hypot(dx, dz) < (orbConfig.r * 2 + 30)) { ok = false; break; }
        }
        if (ok) {
          const yLocal = (levelHeightAt(level, p.x, p.z) - level.y) + orbConfig.r;
          const seed = Math.random() * Math.PI * 2;
          const sats=[];
          for(let k=0;k<(orbConfig.satelliteCount || 1);k++){
            // random axis
            let ax=Math.random()*2-1, ay=Math.random()*2-1, az=Math.random()*2-1;
            const axisLen=Math.hypot(ax,ay,az)||1;
            ax/=axisLen; ay/=axisLen; az/=axisLen;
            // base direction orthogonal to axis
            let bx=ay, by=-ax, bz=0;
            if(Math.hypot(bx,by,bz)<1e-3){bx=0; by=az; bz=-ay;}
            const bl=Math.hypot(bx,by,bz)||1;
            bx/=bl; by/=bl; bz/=bl;
            const radius=orbConfig.r*(1.6+Math.random()*0.5);
            const speed=1.4+Math.random()*0.8;
            const phase=Math.random()*Math.PI*2;
            sats.push({axis:{x:ax,y:ay,z:az}, base:{x:bx*radius,y:by*radius,z:bz*radius}, speed, phase});
          }
          const orbitPhase = Math.random() * Math.PI * 2;
          const orbitRadius = 36 + Math.random() * 12;
          const orbitHeight = 10 + Math.random() * 5;
          const orbitSpeed = 1 + Math.random() * 0.8;
          // Determine if this orb should be wild (level 2, second orb = index 1 within level)
          const orbIndexInLevel = countForLevel();
          const isWild = (levelIndex === 2 && orbIndexInLevel === 1);
          orbs.push({
            level: levelIndex,
            renderLevel: levelIndex,
            pos: { x: p.x, y: yLocal, z: p.z },
            collected: false,
            collectFlash: 0,
            following: false,
            followProgress: 1,
            followStart: null,
            vel: { x: 0, y: 0, z: 0 },
            dissolve: 0,
            seed,
            sats,
            orbitPhase,
            orbitRadius,
            orbitHeight,
            orbitSpeed,
            wild: isWild
          });
        }
      }
    }

    // Geometry instances
    const meshes = {
      floor: createMesh(createBox(-plane.w/2, plane.w/2, -2, 0, -plane.h/2, plane.h/2)),
      walls: createWallMeshes(),
      innerWalls: createInnerWallMeshes(),
      pedestal: createMesh(createFrustum(pedestal.topSize + pedestal.ramp * 2, pedestal.topSize, pedestal.height)),
      pedestalHole: createMesh(createFrustum(pedestal.topSize + pedestal.ramp * 2, pedestal.topSize, pedestal.height, false)),
      marble: createMesh(createSphere(marble.r, 18, 18))
    };

    function createWallMeshes(){
      const t=plane.wallThickness;
      const h=plane.wallHeight;
      const w=plane.w;
      const hl=plane.h;
      const boxes=[
        createBox(-w/2-t, w/2+t, 0, h, hl/2, hl/2+t),    // back
        createBox(-w/2-t, w/2+t, 0, h, -hl/2-t, -hl/2),  // front
        createBox(-w/2-t, -w/2, 0, h, -hl/2, hl/2),      // left
        createBox(w/2, w/2+t, 0, h, -hl/2, hl/2)         // right
      ];
      return boxes.map(createMesh);
    }

    function createInnerWallMeshes(){
      // Inner square walls for level 4, corners at pedestal positions from level 2
      const spacing = pedestalGrid.spacing;
      const t = pedestal.topSize / 2;  // half-width of wall (as wide as pedestal top)
      const h = pedestal.height;       // wall height same as pedestal
      const boxes = [
        // Top wall (X = -spacing, runs along Z) - extended to cover corners
        createBox(-spacing - t, -spacing + t, 0, h, -spacing - t, spacing + t),
        // Bottom wall (X = +spacing, runs along Z) - extended to cover corners
        createBox(spacing - t, spacing + t, 0, h, -spacing - t, spacing + t),
        // Left wall (Z = -spacing, runs along X) - fits between top/bottom walls
        createBox(-spacing + t, spacing - t, 0, h, -spacing - t, -spacing + t),
        // Right wall (Z = +spacing, runs along X) - fits between top/bottom walls
        createBox(-spacing + t, spacing - t, 0, h, spacing - t, spacing + t)
      ];
      return boxes.map(createMesh);
    }

    // Camera/light
    const lightDir = normalize3({ x: -0.4, y: 0.8, z: 0.3 });
    // Keep the camera directly overhead for a top-down view; nudge z to avoid colinearity with the up vector
    const camera = {
      pos: { x: 0, y: 1500, z: 1 },
      target: { x: 0, y: 0, z: 0 },
      baseHeight: 1500,
      followRatio: 0.9,
      smooth: 2.6
    };

    // Input and physics
    function updateInput(dt) {
      const target = plane.targetTilt;
      target.x = 0;
      target.y = 0;
      // Swap left/right so A tilts left, D tilts right
      if (keys.has('KeyA')) target.x -= 1;
      if (keys.has('KeyD')) target.x += 1;
      if (keys.has('KeyW')) target.y += 1;
      if (keys.has('KeyS')) target.y -= 1;
      if (keys.has('Space')) return; // Freeze input accumulation while rewinding
      const supportTilt = isAirborne()
        ? 1 // let the plane still respond to input while falling
        : Math.max(0, Math.min(1, currentSupport?.support ?? 0));
      target.x *= supportTilt;
      target.y *= supportTilt;
      const len = Math.hypot(target.x, target.y);
      if (len > 1) { target.x /= len; target.y /= len; }
      const smoothing = 12;
      plane.tilt.x += (target.x * plane.maxTilt - plane.tilt.x) * dt * smoothing;
      plane.tilt.y += (target.y * plane.maxTilt - plane.tilt.y) * dt * smoothing;
    }

    function updateCamera(dt) {
      const follow = camera.followRatio;
      const level = getActiveLevel();
      const levelY = level?.y || 0;
      const marbleLocalY = marble.y - levelY;
      const desiredPosY = levelY + camera.baseHeight + marbleLocalY * follow;
      const desiredTargetY = levelY + marbleLocalY * follow * 0.6;
      const smooth = camera.smooth;
      camera.pos.y += (desiredPosY - camera.pos.y) * dt * smooth;
      camera.target.y += (desiredTargetY - camera.target.y) * dt * smooth;
    }

    function screenToBoardXZ(clientX, clientY) {
      const rect = canvas.getBoundingClientRect();
      if (!rect.width || !rect.height) return null;
      const xNdc = ((clientX - rect.left) / rect.width) * 2 - 1;
      const yNdc = ((rect.bottom - clientY) / rect.height) * 2 - 1;

      const aspect = canvas.width / canvas.height;
      const proj = mat4Perspective(Math.PI / 4, aspect, 10, 5000);
      const view = mat4LookAt(camera.pos, camera.target, { x: 0, y: 0, z: 1 });
      const invVP = mat4Invert(mat4Multiply(proj, view));

      const near = mat4TransformVec4(invVP, [xNdc, yNdc, -1, 1]);
      const far = mat4TransformVec4(invVP, [xNdc, yNdc, 1, 1]);
      const nearWorld = { x: near[0] / near[3], y: near[1] / near[3], z: near[2] / near[3] };
      const farWorld = { x: far[0] / far[3], y: far[1] / far[3], z: far[2] / far[3] };
      const dir = normalize3({
        x: farWorld.x - nearWorld.x,
        y: farWorld.y - nearWorld.y,
        z: farWorld.z - nearWorld.z
      });

      const level = getActiveLevel();
      const planePoint = { x: 0, y: level?.y || 0, z: 0 };
      const n = boardNormal();
      const denom = dir.x * n.x + dir.y * n.y + dir.z * n.z;
      if (Math.abs(denom) < 1e-5) return null;
      const t = ((planePoint.x - nearWorld.x) * n.x + (planePoint.y - nearWorld.y) * n.y + (planePoint.z - nearWorld.z) * n.z) / denom;
      if (!Number.isFinite(t) || t < 0) return null;

      const hit = {
        x: nearWorld.x + dir.x * t,
        z: nearWorld.z + dir.z * t
      };
      const halfW = plane.w * 0.5 - marble.r;
      const halfH = plane.h * 0.5 - marble.r;
      return {
        x: Math.max(-halfW, Math.min(halfW, hit.x)),
        z: Math.max(-halfH, Math.min(halfH, hit.z))
      };
    }

    function updatePhysics(dt) {
      const tiltAccel = 240;
      const supportInfo = calculateSupport(marble.pos.x, marble.pos.z, marble.y);
      currentSupport = supportInfo;
      const support = supportInfo.support;
      const supportLevel = supportInfo.level;
      const airborne = isAirborne();

      const tiltScale = airborne ? 0 : (0.35 + 0.65 * support);
      let ax = -tiltAccel * Math.sin(plane.tilt.x) * tiltScale;
      let az = tiltAccel * Math.sin(plane.tilt.y) * tiltScale;

      const eps = 2;
      const left = levelHeightAt(supportLevel, marble.pos.x - eps, marble.pos.z);
      const right = levelHeightAt(supportLevel, marble.pos.x + eps, marble.pos.z);
      const forward = levelHeightAt(supportLevel, marble.pos.x, marble.pos.z + eps);
      const back = levelHeightAt(supportLevel, marble.pos.x, marble.pos.z - eps);
      const dhdx = (Number.isFinite(right) && Number.isFinite(left)) ? (right - left) / (2 * eps) : 0;
      const dhdz = (Number.isFinite(forward) && Number.isFinite(back)) ? (forward - back) / (2 * eps) : 0;
      const slopeScale = pedestal.slopeGravity * support;
      ax += -slopeScale * dhdx;
      az += -slopeScale * dhdz;

      if (mouseAttractor.active) {
        const dx = mouseAttractor.target.x - marble.pos.x;
        const dz = mouseAttractor.target.z - marble.pos.z;
        const dist = Math.hypot(dx, dz);
        if (dist > 1) {
          const attractScale = airborne ? 0.35 : 1;
          const pull = mouseAttractor.strength * Math.min(1, dist / 180) * attractScale;
          ax += (dx / dist) * pull;
          az += (dz / dist) * pull;
        } else {
          mouseAttractor.active = false;
        }
      }

      marble.vel.x += ax * dt;
      marble.vel.z += az * dt;

      const frictionGround = 0.9975;
      const frictionAir = 0.999;
      const friction = support > 0.5 ? frictionGround : frictionAir;
      marble.vel.x *= friction;
      marble.vel.z *= friction;

      marble.pos.x += marble.vel.x * dt;
      marble.pos.z += marble.vel.z * dt;

      const gravityY = 900;
      marble.vy -= gravityY * dt;
      marble.y += marble.vy * dt;

      let landingSupport = refreshSupport();
      const newGround = landingSupport.groundHeight;
      if (Number.isFinite(newGround) && marble.y <= newGround) {
        marble.y = newGround;
        if (marble.vy < 0) marble.vy = 0;
        landingSupport = refreshSupport();
      }

      const { w, h } = plane;
      const minX = -w / 2 + marble.r;
      const maxX = w / 2 - marble.r;
      const minZ = -h / 2 + marble.r;
      const maxZ = h / 2 - marble.r;

      if (marble.pos.x < minX) { marble.pos.x = minX; marble.vel.x *= -0.6; }
      if (marble.pos.x > maxX) { marble.pos.x = maxX; marble.vel.x *= -0.6; }
      if (marble.pos.z < minZ) { marble.pos.z = minZ; marble.vel.z *= -0.6; }
      if (marble.pos.z > maxZ) { marble.pos.z = maxZ; marble.vel.z *= -0.6; }

      // Inner wall collision for level 4 (only when grounded on level 4, not falling through)
      if (landingSupport?.level?.index === 4 && landingSupport.support > 0.5) {
        const spacing = pedestalGrid.spacing;
        const wallHalfWidth = pedestal.topSize / 2;
        const wallOuterX1 = -spacing - wallHalfWidth - marble.r;
        const wallInnerX1 = -spacing + wallHalfWidth + marble.r;
        const wallInnerX2 = spacing - wallHalfWidth - marble.r;
        const wallOuterX2 = spacing + wallHalfWidth + marble.r;
        const wallOuterZ1 = -spacing - wallHalfWidth - marble.r;
        const wallInnerZ1 = -spacing + wallHalfWidth + marble.r;
        const wallInnerZ2 = spacing - wallHalfWidth - marble.r;
        const wallOuterZ2 = spacing + wallHalfWidth + marble.r;

        // Check collision with left wall (X = -spacing)
        if (marble.pos.x > wallOuterX1 && marble.pos.x < wallInnerX1 &&
            marble.pos.z > -spacing && marble.pos.z < spacing) {
          if (marble.vel.x > 0) { marble.pos.x = wallOuterX1; marble.vel.x *= -0.6; }
          else { marble.pos.x = wallInnerX1; marble.vel.x *= -0.6; }
        }
        // Check collision with right wall (X = +spacing)
        if (marble.pos.x > wallInnerX2 && marble.pos.x < wallOuterX2 &&
            marble.pos.z > -spacing && marble.pos.z < spacing) {
          if (marble.vel.x > 0) { marble.pos.x = wallInnerX2; marble.vel.x *= -0.6; }
          else { marble.pos.x = wallOuterX2; marble.vel.x *= -0.6; }
        }
        // Check collision with front wall (Z = -spacing)
        if (marble.pos.z > wallOuterZ1 && marble.pos.z < wallInnerZ1 &&
            marble.pos.x > -spacing && marble.pos.x < spacing) {
          if (marble.vel.z > 0) { marble.pos.z = wallOuterZ1; marble.vel.z *= -0.6; }
          else { marble.pos.z = wallInnerZ1; marble.vel.z *= -0.6; }
        }
        // Check collision with back wall (Z = +spacing)
        if (marble.pos.z > wallInnerZ2 && marble.pos.z < wallOuterZ2 &&
            marble.pos.x > -spacing && marble.pos.x < spacing) {
          if (marble.vel.z > 0) { marble.pos.z = wallInnerZ2; marble.vel.z *= -0.6; }
          else { marble.pos.z = wallOuterZ2; marble.vel.z *= -0.6; }
        }
      }

      checkOrbCollisions();
      updateOrbs(dt);
      updateCollapses(dt);
      refreshSupport();
    }

    // Render helpers
    function getActiveLevel() {
      if (isAirborne()) return lastGroundedLevel || currentSupport?.level || levels[0];
      return currentSupport?.level || lastGroundedLevel || levels[0];
    }

    function setMatrices(model) {
      const aspect = canvas.width / canvas.height;
      const proj = mat4Perspective(Math.PI / 4, aspect, 10, 5000);
      const view = mat4LookAt(camera.pos, camera.target, { x: 0, y: 0, z: 1 });
      const vp = mat4Multiply(proj, view);
      const mvp = mat4Multiply(vp, model);
      const normalMatrix = mat4Transpose(mat4Invert(model));
      gl.uniformMatrix4fv(uniforms.mvp, false, mvp);
      gl.uniformMatrix4fv(uniforms.model, false, model);
      gl.uniformMatrix4fv(uniforms.normalMatrix, false, normalMatrix);
    }

    function drawMesh(mesh, model, color, ambient=[0.05,0.08,0.12], alpha=1.0, holeMask=null) {
      gl.bindVertexArray(mesh.vao);
      setMatrices(model);
      gl.uniform3fv(uniforms.lightDir, new Float32Array([lightDir.x, lightDir.y, lightDir.z]));
      gl.uniform3fv(uniforms.color, new Float32Array(color));
      gl.uniform3fv(uniforms.ambient, new Float32Array(ambient));
      gl.uniform1f(uniforms.alpha, alpha);
      holeCentersArr.fill(0);
      holeRadiiArr.fill(0);
      holeSoftnessArr.fill(0);
      if (holeMask) {
        const holes = Array.isArray(holeMask.holes) ? holeMask.holes : [holeMask];
        const count = Math.min(MAX_HOLES, holes.length);
        for (let i = 0; i < count; i++) {
          const h = holes[i] || {};
          const progress = Math.max(0, Math.min(1, h.progress ?? 1));
          const radius = (h.radius || 0) * progress;
          const c = h.center || { x: 0, y: 0, z: 0 };
          holeCentersArr[i * 3 + 0] = c.x || 0;
          holeCentersArr[i * 3 + 1] = c.y || 0;
          holeCentersArr[i * 3 + 2] = c.z || 0;
          holeRadiiArr[i] = radius;
          holeSoftnessArr[i] = h.softness ?? 0;
        }
        gl.uniform1i(uniforms.holeCount, count);
        gl.uniform3fv(uniforms.holeCenters, holeCentersArr);
        gl.uniform1fv(uniforms.holeRadii, holeRadiiArr);
        gl.uniform1fv(uniforms.holeSoftness, holeSoftnessArr);
      } else {
        gl.uniform1i(uniforms.holeCount, 0);
        gl.uniform3fv(uniforms.holeCenters, holeCentersArr);
        gl.uniform1fv(uniforms.holeRadii, holeRadiiArr);
        gl.uniform1fv(uniforms.holeSoftness, holeSoftnessArr);
      }
      gl.drawElements(gl.TRIANGLES, mesh.count, gl.UNSIGNED_SHORT, 0);
    }

    function boardTransform(offsetY=0, tiltScale=1) {
      let m = mat4Identity();
      m = mat4Translate(m, [0, offsetY, 0]);
      m = mat4RotateX(m, plane.tilt.y * 0.35 * tiltScale);
      m = mat4RotateZ(m, plane.tilt.x * 0.35 * tiltScale);
      return m;
    }
    function boardNormal() {
      const m = boardTransform(0);
      return transformDirection(m, { x: 0, y: 1, z: 0 });
    }

    function drawMarbleEffects(boardM) {
      const supportLevel = getActiveLevel();
      const holeMask = (supportLevel?.hasHole)
        ? (() => {
            const holes = holesForLevel(supportLevel);
            return holes.length ? { holes } : null;
          })()
        : null;
      const levelY = supportLevel.y || 0;
      const surfaceY = isAirborne()
        ? lastGroundSurfaceHeight
        : (Number.isFinite(currentSupport?.surfaceHeight) ? currentSupport.surfaceHeight : levelHeightAt(supportLevel, marble.pos.x, marble.pos.z));
      const planeY = Number.isFinite(surfaceY) ? surfaceY : (marble.y - marble.r);
      const normal = levelNormalAt(supportLevel, marble.pos.x, marble.pos.z);
      const orient = mat4FromNormal(normal);
      const deltaY = Number.isFinite(surfaceY) ? marble.y - (surfaceY + marble.r) : Infinity; // >0 above plane, <0 below
      const altitudeForFx = deltaY > 0 ? deltaY : Infinity; // hide shadow/reflection once we fall through
      // Soft blob shadow aligned to surface
      const shadowOffset = 1.2;
      const altitude = isAirborne()
        ? altitudeForFx
        : (Number.isFinite(currentSupport?.altitude) ? currentSupport.altitude : altitudeForFx);
      const shadowStrength = Number.isFinite(altitude) ? Math.max(0, Math.min(1, 1 - Math.max(0, altitude) / (marble.r * 2.5))) : 0;
      let shadowM = boardM;
      shadowM = mat4Translate(shadowM, [marble.pos.x, planeY - levelY + shadowOffset, marble.pos.z]);
      shadowM = mat4Multiply(shadowM, orient);
      shadowM = mat4Scale(shadowM, [1.08, 0.08, 1.08]);
      drawMesh(meshes.marble, shadowM, [0,0,0], [0,0,0], 0.38 * shadowStrength, holeMask);
      // Reflection (mirror across the local surface plane)
      const distanceAbove = marble.y - planeY;
      if (deltaY >= 0) { // only show reflection while above the plane
        const reflectionY = planeY - distanceAbove + 1.2;
        let reflectionM = boardM;
        reflectionM = mat4Translate(reflectionM, [marble.pos.x, reflectionY - levelY, marble.pos.z]);
        reflectionM = mat4Multiply(reflectionM, orient);
        reflectionM = mat4Scale(reflectionM, [1, -1, 1]);
        drawMesh(meshes.marble, reflectionM, [0.65,0.7,0.8], [0.05,0.05,0.08], 0.22 * Math.max(0, shadowStrength * 0.58), holeMask);
      }
    }

    function drawOrbs(boardM, orbTime, levelIndex=0, alpha=1, opts={}) {
      const includeFollowing = opts.includeFollowing ?? true;
      const followingOnly = opts.followingOnly ?? false;
      const liftOffset = opts.liftOffset;
      const transitionBoards = opts.transitionBoards;
      const hasTransitionBoards = transitionBoards && transitionBoards.flat && transitionBoards.tilted && transitionBoards.invFlat;
      for (const orb of orbs) {
        const isFollowing = !!orb.following;
        if (followingOnly && !isFollowing) continue;
        if (!followingOnly && !includeFollowing && isFollowing) continue;
        const renderLevelIndex = isFollowing ? (orb.renderLevel ?? getActiveLevel()?.index ?? orb.level) : orb.level;
        if (renderLevelIndex !== levelIndex) continue;
        const dissolve = orb.collected ? orb.dissolve : 0;
        if (dissolve >= 1) continue;
        const followProgress = isFollowing ? clamp01(orb.followProgress ?? 1) : 1;
        const followEase = smoothstep01(followProgress);
        const flash = orb.collectFlash ? clamp01(orb.collectFlash / orbCollectFlashDuration) : 0;
        const flashEase = orbFlashEnvelope(flash);
        const baseGlow = orbGlowPulse(orb, orbTime);
        gl.depthMask(false);
        gl.enable(gl.DEPTH_TEST);
        gl.depthFunc(gl.LEQUAL);

        // Orbiting sun(s) (additive-ish)
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
        for (let i=0;i<orb.sats.length;i++){
          const sat = orb.sats[i];
          const offset = satelliteOffset(sat, orbTime, i);
          const extraY = liftOffset ? liftOffset(orb, renderLevelIndex, followEase) : 0;
          const basePos = [orb.pos.x + offset.x, orb.pos.y + offset.y, orb.pos.z + offset.z, 1];
          let sM;
          if (isFollowing && hasTransitionBoards && followEase < 1) {
            const tiltedPos = mat4TransformVec4(transitionBoards.tilted, basePos);
            const flatPos = mat4TransformVec4(transitionBoards.flat, [basePos[0], basePos[1] + extraY, basePos[2], basePos[3]]);
            const blended = [
              tiltedPos[0] + (flatPos[0] - tiltedPos[0]) * followEase,
              tiltedPos[1] + (flatPos[1] - tiltedPos[1]) * followEase,
              tiltedPos[2] + (flatPos[2] - tiltedPos[2]) * followEase,
              1
            ];
            const local = mat4TransformVec4(transitionBoards.invFlat, blended);
            sM = transitionBoards.flat;
            sM = mat4Translate(sM, [local[0], local[1], local[2]]);
          } else {
            sM = boardM;
            sM = mat4Translate(sM, [basePos[0], basePos[1] + extraY, basePos[2]]);
          }
          const shrink = orb.collected ? (1 - 0.5 * followEase) : 1;
          const sScale = 0.35 * shrink * (1 - dissolve);
          sM = mat4Scale(sM, [sScale, sScale, sScale]);
          const flashColor = baseGlow + flashEase * 5.5;
          const flashAlpha = (0.65 * baseGlow + flashEase * 3.6) * (1 - dissolve);
          // Wild orbs cycle through rainbow colors
          let diffuse, specular;
          let satAlpha = alpha * flashAlpha;
          let ambient;
          if (orb.wild) {
            // Cycle between blue and magenta
            const t = orbTime * 0.8 + (orb.seed || 0);
            const wave = (Math.sin(t * Math.PI * 2) + 1) * 0.5; // 0 to 1
            // Brighter, slightly less saturated (add some green)
            diffuse = [wave * 2.8, 0.4, 2.5];
            ambient = [wave * 0.9, 0.15, 0.9];
            // Two-pass for both states: solid color base + additive glow
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            const baseAlpha = orb.collected ? satAlpha * 0.5 : satAlpha * 0.35;
            drawMesh(meshes.marble, sM, diffuse, ambient, baseAlpha);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
            const glowAlpha = orb.collected ? satAlpha * 0.45 : satAlpha * 0.3;
            drawMesh(meshes.marble, sM, [wave * 0.45, 0.08, 0.4], [wave * 0.18, 0.03, 0.18], glowAlpha);
          } else {
            diffuse = [1.3 * flashColor, 1.05 * flashColor, 0.6 * flashColor];
            ambient = [0.25, 0.2, 0.1];
            drawMesh(meshes.marble, sM, diffuse, ambient, satAlpha);
          }
        }
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        gl.depthMask(true);
        gl.depthFunc(gl.LESS);
        gl.enable(gl.DEPTH_TEST);
      }
    }

    function frame(time) {
      const now = time * 0.001;
      const delta = now - (frame.last || now);
      const dt = Math.min(0.033, delta);
      frame.last = now;

      const rewinding = keys.has('Space');
      if (rewinding) {
        rewindAccumulator += rewindSpeed;
        let rewindBlocked = false;
        while (rewindAccumulator >= 1) {
          rewindAccumulator -= 1;
          if (rewindStep()) {
            rewindBlocked = true;
            rewindAccumulator = 0; // Stop accumulating when blocked
            break;
          }
        }
        refreshSupport();
        // Update collapses during rewind so pedestals can close when orb count drops
        updateCollapses(dt);
        // Only update wild orbs and animation if there's still history to rewind and not blocked
        if (history.length > 1 && !rewindBlocked) {
          updateWildOrbs(dt);
          orbAnimTime += delta; // Keep animation time advancing for wild orb rainbow effect
        }
        // When star history is exhausted, keep stars moving with reversed velocities
        // But freeze everything when main history hits zero or rewind is blocked
        if (starsReversed && history.length > 1 && !rewindBlocked) {
          updateStars(dt);
        }
      } else {
        rewindAccumulator = 0;
        // Transition from rewind to forward: un-reverse star velocities
        if (starsReversed) {
          reverseStarVelocities();
          starsReversed = false;
        }
        updateInput(dt);
        updatePhysics(dt);
        updateStars(dt);
        orbAnimTime += delta;
        pushHistory();
      }

      // Update rewind bar
      updateRewindBar();
      updateCamera(dt);
      drawStars();
      updateLightsUniforms();

      gl.enable(gl.DEPTH_TEST);
      gl.clearColor(0, 0, 0, 0);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

      const activeLevel = getActiveLevel();
      const marbleTiltScale = Math.max(0, Math.min(1, currentSupport?.support ?? 0));
      const fadeDepth = levelDrop * 0.75; // fade out as we fall roughly three quarters of a level
      function isLevelUnlocked(level) {
        if (!level) return false;
        if (level.index === 0) return true;
        const aboveCollapse = collapseStateFor(level.index - 1);
        const hasHoleOpen = (aboveCollapse?.progress ?? 0) > 0;
        return hasHoleOpen || marble.y <= level.y + approachFadeDepth;
      }

      const boardEntries = [];
      for (const level of levels) {
        if (!isLevelUnlocked(level)) continue;
        const aboveCollapse = collapseStateFor(level.index - 1);
        const hasHoleOpen = (aboveCollapse?.progress ?? 0) > 0;
        const heightAbove = Math.max(0, marble.y - level.y - marble.r * 2);
        const heightBelow = Math.max(0, level.y - marble.y);
        // Fade in as marble approaches from above (skip if hole is open above)
        const approachFade = hasHoleOpen ? 1
          : heightAbove <= 0 ? 1
          : Math.max(0, Math.min(1, 1 - (heightAbove / approachFadeDepth)));
        // Fade out as marble falls below
        const departureFade = heightBelow <= 0
          ? 1
          : Math.max(0, Math.min(1, 1 - (heightBelow / fadeDepth)));
        const fade = Math.min(approachFade, departureFade);
        if (fade <= 0.001) continue;
        const levelHoles = holesForLevel(level);
        const mask = level.hasHole && levelHoles.length ? { holes: levelHoles } : null;
        boardEntries.push({ level, matrix: boardTransform(level.y), mask, alpha: fade });
      }

      // Draw from lowest to highest so fading boards overlay what's below without popping
      boardEntries.sort((a, b) => a.level.y - b.level.y);

      // Calculate max alpha of levels above the active level (for fading marble/orbs)
      // Skip levels where the marble is in the hole - it's visible through the hole
      const activeLevelIndex = activeLevel?.index ?? 0;
      const maxAlphaAbove = boardEntries
        .filter(e => e.level.index < activeLevelIndex)
        .filter(e => !isPointInHole(e.level, marble.pos.x, marble.pos.z))
        .reduce((max, e) => Math.max(max, e.alpha), 0);

      for (const entry of boardEntries) {
        const { level, matrix, mask } = entry;
        const palette = boardColors[level.index] || boardColors[0];
        const allowDepthWrite = entry.alpha > 0.001;
        gl.depthMask(allowDepthWrite);
        drawMesh(meshes.floor, matrix, palette.floor, [0.04,0.06,0.1], entry.alpha, level.hasHole ? mask : null);
        const wallColor = palette.wall;
        for(const w of meshes.walls) drawMesh(w, matrix, wallColor, [0.04,0.05,0.09], entry.alpha);
        // Draw inner square walls on level 4 (final level)
        if (level.index === 4) {
          for(const w of meshes.innerWalls) drawMesh(w, matrix, wallColor, [0.04,0.05,0.09], entry.alpha);
        }
        const pedestals = pedestalsForLevel(level);
        const isWild = isWildPedestal(level.index);
        for(const { pos, idx } of pedestals){
          const height = pedestalHeightForIndex(idx, level);
          const pedCollapse = collapseProgressFor(level.index, idx);
          const pedMesh = pedCollapse > 0 ? meshes.pedestalHole : meshes.pedestal;
          const pedAlpha = pedCollapse > 0 ? entry.alpha * pedestalCollapseAlpha(pedCollapse) : entry.alpha;
          if (pedAlpha <= 0.001) continue;
          let pedM = matrix;
          pedM = mat4Translate(pedM, [pos.x, 0, pos.z]);
          pedM = mat4Scale(pedM, [1, height / pedestal.height, 1]);
          let pedColor = pedCollapse > 0
            ? palette.pedestal.map((c, i) => c + (palette.pedestalHole[i] - c) * pedCollapse)
            : palette.pedestal;
          // Wild pedestals cycle through rainbow colors like wild orbs
          if (isWild) {
            const t = orbAnimTime * 0.8 + idx * 0.5; // offset by pedestal index
            const wave = (Math.sin(t * Math.PI * 2) + 1) * 0.5;
            // Blend from original green to rainbow (blue-magenta cycle)
            const wildColor = [wave * 0.7, 0.3, 0.6 + wave * 0.3];
            pedColor = pedColor.map((c, i) => c * 0.4 + wildColor[i] * 0.6);
          }
          if (pedCollapse > 0) gl.depthMask(false); // let the hole reveal the level below while fading
          drawMesh(pedMesh, pedM, pedColor, [0.05,0.06,0.1], pedAlpha);
          if (pedCollapse > 0) gl.depthMask(allowDepthWrite);
        }
        // Draw level orbs with depth so lower levels stay occluded by boards
        drawOrbs(matrix, orbAnimTime, level.index, entry.alpha, { includeFollowing: false });
      }
      gl.depthMask(true);

      const activeLevelY = activeLevel?.y || 0;
      const boardTiltM = boardTransform(activeLevelY);
      const marbleTiltM = marbleTiltScale >= 0.999 ? boardTiltM : boardTransform(activeLevelY, marbleTiltScale);
      // Fade marble/orbs as level above fades in
      const marbleOrbAlpha = 1 - maxAlphaAbove;
      gl.depthMask(false);
      gl.disable(gl.DEPTH_TEST);
      drawMarbleEffects(boardTiltM);
      gl.depthMask(true);
      gl.enable(gl.DEPTH_TEST);
      gl.clear(gl.DEPTH_BUFFER_BIT); // Clear depth so marble/orbs render on top, alpha handles fade
      let marbleM = marbleTiltM;
      marbleM = mat4Translate(marbleM, [marble.pos.x, marble.y - activeLevelY, marble.pos.z]);
      drawMesh(meshes.marble, marbleM, [0.7,0.7,0.7], [0.1,0.1,0.1], marbleOrbAlpha);

      // Draw current-level orbs over the marble for a brighter, on-top glow
      const activeEntry = boardEntries.find(e => e.level.index === activeLevel?.index);
      if (activeEntry) {
        drawOrbs(activeEntry.matrix, orbAnimTime, activeEntry.level.index, activeEntry.alpha * marbleOrbAlpha, { includeFollowing: false });
      }
      const followingLevels = new Set();
      for (const orb of orbs) {
        if (!orb.following) continue;
        if (orb.collected && orb.dissolve >= 1) continue;
        const idx = orb.renderLevel ?? activeLevel?.index ?? orb.level;
        if (!Number.isFinite(idx)) continue;
        followingLevels.add(idx);
      }
      for (const idx of followingLevels) {
        const lvl = levels[idx] || levels[0];
        const flatBoard = boardTransform(lvl?.y || 0, 0);
        const tiltedBoard = boardTransform(lvl?.y || 0);
        const flatInv = mat4Invert(flatBoard);
        const liftOffset = (orb, _renderLevelIndex, followEase=1) => {
          const pos = [orb.pos.x, orb.pos.y, orb.pos.z, 1];
          const tilted = mat4TransformVec4(tiltedBoard, pos);
          const flat = mat4TransformVec4(flatBoard, pos);
          const tiltLift = tilted[1] - flat[1];
          return tiltLift + followingOrbLift * followEase;
        };
        drawOrbs(flatBoard, orbAnimTime, idx, marbleOrbAlpha, { followingOnly: true, liftOffset, transitionBoards: { flat: flatBoard, tilted: tiltedBoard, invFlat: flatInv } });
      }

      // Re-draw floors of levels above the marble to properly occlude it (holes still discard)
      for (const entry of boardEntries) {
        if (entry.level.y <= marble.y) continue; // Only floors above the marble
        if (entry.alpha <= 0.001) continue;
        const { level, matrix, mask } = entry;
        const palette = boardColors[level.index] || boardColors[0];
        gl.depthMask(true);
        drawMesh(meshes.floor, matrix, palette.floor, [0.04,0.06,0.1], entry.alpha, level.hasHole ? mask : null);
      }

      if (!paused) rafId = requestAnimationFrame(frame);
    }

    function setupInput() {
      window.addEventListener('keydown', (e) => {
        if (!e.repeat && (e.code === 'Digit0' || e.code === 'Numpad0')) {
          skipNextOrbBatch();
          return;
        }
        if (!e.repeat && e.code === 'Escape') {
          togglePause();
          return;
        }
        keys.add(e.code);
      });
      window.addEventListener('keyup', (e) => keys.delete(e.code));
      function setAttractorFromEvent(e) {
        const target = screenToBoardXZ(e.clientX, e.clientY);
        if (!target) return false;
        mouseAttractor.active = true;
        mouseAttractor.target.x = target.x;
        mouseAttractor.target.z = target.z;
        return true;
      }
      canvas.addEventListener('pointerdown', (e) => {
        if (setAttractorFromEvent(e) && canvas.setPointerCapture) {
          canvas.setPointerCapture(e.pointerId);
        }
      });
      canvas.addEventListener('pointermove', (e) => {
        if (!mouseAttractor.active) return;
        setAttractorFromEvent(e);
      });
      function stopAttractor(e) {
        mouseAttractor.active = false;
        if (e && canvas.releasePointerCapture) canvas.releasePointerCapture(e.pointerId);
      }
      canvas.addEventListener('pointerup', stopAttractor);
      canvas.addEventListener('pointercancel', stopAttractor);
      canvas.addEventListener('pointerleave', () => { mouseAttractor.active = false; });
    }

    marble.y = levelHeightAt(levels[0], marble.pos.x, marble.pos.z) + marble.r;
    refreshSupport();
    spawnOrbsForLevel(0);
    spawnOrbsForLevel(1);
    spawnOrbsForLevel(2);
    spawnOrbsForLevel(3);
    pushHistory();
    setupInput();
    resumeLoop();
  </script>
</body>
</html>
