<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Marbl (WebGL)</title>
  <style>
    :root {
      --bg: #050915;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      display: grid;
      place-items: center;
      position: relative;
      overflow: hidden;
      background: radial-gradient(circle at 30% 20%, #0c1224 0%, var(--bg) 55%);
      color: #e5ecff;
      font-family: "Inter", system-ui, -apple-system, sans-serif;
      height: 100vh;
    }
    #stars {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      display: block;
      pointer-events: none;
      z-index: 0;
    }
    #c {
      width: 1024px;
      height: 1024px;
      background: transparent;
      display: block;
      position: relative;
      z-index: 1;
    }
    .hud {
      position: absolute;
      top: 16px;
      left: 50%;
      transform: translateX(-50%);
      letter-spacing: 0.08em;
      font-size: 12px;
      text-transform: uppercase;
      color: rgba(229, 236, 255, 0.6);
      pointer-events: none;
      text-shadow: 0 1px 8px rgba(0,0,0,0.35);
      z-index: 2;
    }
  </style>
</head>
<body>
  <canvas id="stars"></canvas>
  <div class="hud">WASD to tilt the plane</div>
  <canvas id="c" width="1024" height="1024"></canvas>
  <script>
    const starCanvas = document.getElementById('stars');
    const canvas = document.getElementById('c');
    const starCtx = starCanvas.getContext('2d');
    const gl = canvas.getContext('webgl2', { antialias: true, alpha: true });
    if (!gl) {
      alert('WebGL2 not supported');
      throw new Error('WebGL2 not supported');
    }

    const starConfig = {
      density: 0.00014,
      minSpeed: 8,
      maxSpeed: 18,
      minSize: 0.6,
      maxSize: 1.6,
      margin: 32
    };
    const stars = [];
    let starTargetCount = 0;
    let starAreaWidth = 0;
    let starAreaHeight = 0;

    function resetStar(star, anywhere=false) {
      const w = starAreaWidth || window.innerWidth;
      const h = starAreaHeight || window.innerHeight;
      const margin = starConfig.margin;
      const speed = starConfig.minSpeed + Math.random() * (starConfig.maxSpeed - starConfig.minSpeed);
      star.size = starConfig.minSize + Math.random() * (starConfig.maxSize - starConfig.minSize);
      star.alpha = 0.25 + Math.random() * 0.45;
      let angle = Math.random() * Math.PI * 2;
      if (!anywhere) {
        const side = Math.floor(Math.random() * 4);
        const spread = Math.PI / 3;
        switch (side) {
          case 0: star.x = -margin; star.y = Math.random() * h; angle = 0; break;
          case 1: star.x = w + margin; star.y = Math.random() * h; angle = Math.PI; break;
          case 2: star.x = Math.random() * w; star.y = -margin; angle = Math.PI / 2; break;
          default: star.x = Math.random() * w; star.y = h + margin; angle = -Math.PI / 2; break;
        }
        angle += (Math.random() - 0.5) * spread;
      } else {
        star.x = Math.random() * w;
        star.y = Math.random() * h;
      }
      star.vx = Math.cos(angle) * speed;
      star.vy = Math.sin(angle) * speed;
    }

    function makeStar(fillArea=false) {
      const s = { x: 0, y: 0, vx: 0, vy: 0, size: 1, alpha: 1 };
      resetStar(s, fillArea);
      return s;
    }

    function adjustStarCount(fillArea=false) {
      if (stars.length > starTargetCount) {
        stars.length = starTargetCount;
      } else {
        while (stars.length < starTargetCount) stars.push(makeStar(fillArea));
      }
    }

    function resizeStars() {
      const dpr = window.devicePixelRatio || 1;
      starAreaWidth = window.innerWidth;
      starAreaHeight = window.innerHeight;
      starCanvas.style.width = `${starAreaWidth}px`;
      starCanvas.style.height = `${starAreaHeight}px`;
      starCanvas.width = Math.round(starAreaWidth * dpr);
      starCanvas.height = Math.round(starAreaHeight * dpr);
      starCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
      starTargetCount = Math.max(80, Math.floor(starAreaWidth * starAreaHeight * starConfig.density));
      adjustStarCount(true);
    }

    function updateStars(dt) {
      const w = starAreaWidth;
      const h = starAreaHeight;
      const margin = starConfig.margin;
      for (const s of stars) {
        s.x += s.vx * dt;
        s.y += s.vy * dt;
        if (s.x < -margin || s.x > w + margin || s.y < -margin || s.y > h + margin) {
          resetStar(s);
        }
      }
    }

    function drawStars() {
      starCtx.clearRect(0, 0, starAreaWidth, starAreaHeight);
      starCtx.fillStyle = '#d7e1ff';
      for (const s of stars) {
        starCtx.globalAlpha = s.alpha;
        starCtx.beginPath();
        starCtx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
        starCtx.fill();
      }
      starCtx.globalAlpha = 1;
    }

    // HiDPI handling
    function resize() {
      const dpr = window.devicePixelRatio || 1;
      const displayW = 1024;
      const displayH = 1024;
      canvas.style.width = `${displayW}px`;
      canvas.style.height = `${displayH}px`;
      canvas.width = displayW * dpr;
      canvas.height = displayH * dpr;
      gl.viewport(0, 0, canvas.width, canvas.height);
      resizeStars();
    }
    resize();
    window.addEventListener('resize', resize);

    // Math helpers
    function normalize3(v) {
      const len = Math.hypot(v.x, v.y, v.z || 0) || 1;
      return { x: v.x / len, y: v.y / len, z: (v.z || 0) / len };
    }
    function mat4Identity() {
      const out = new Float32Array(16);
      out[0]=1; out[5]=1; out[10]=1; out[15]=1;
      return out;
    }
    function mat4Multiply(a,b){
      const out=new Float32Array(16);
      const a00=a[0], a01=a[1], a02=a[2], a03=a[3];
      const a10=a[4], a11=a[5], a12=a[6], a13=a[7];
      const a20=a[8], a21=a[9], a22=a[10],a23=a[11];
      const a30=a[12],a31=a[13],a32=a[14],a33=a[15];

      const b00=b[0], b01=b[1], b02=b[2], b03=b[3];
      const b10=b[4], b11=b[5], b12=b[6], b13=b[7];
      const b20=b[8], b21=b[9], b22=b[10],b23=b[11];
      const b30=b[12],b31=b[13],b32=b[14],b33=b[15];

      out[0]=a00*b00 + a10*b01 + a20*b02 + a30*b03;
      out[1]=a01*b00 + a11*b01 + a21*b02 + a31*b03;
      out[2]=a02*b00 + a12*b01 + a22*b02 + a32*b03;
      out[3]=a03*b00 + a13*b01 + a23*b02 + a33*b03;

      out[4]=a00*b10 + a10*b11 + a20*b12 + a30*b13;
      out[5]=a01*b10 + a11*b11 + a21*b12 + a31*b13;
      out[6]=a02*b10 + a12*b11 + a22*b12 + a32*b13;
      out[7]=a03*b10 + a13*b11 + a23*b12 + a33*b13;

      out[8]=a00*b20 + a10*b21 + a20*b22 + a30*b23;
      out[9]=a01*b20 + a11*b21 + a21*b22 + a31*b23;
      out[10]=a02*b20 + a12*b21 + a22*b22 + a32*b23;
      out[11]=a03*b20 + a13*b21 + a23*b22 + a33*b23;

      out[12]=a00*b30 + a10*b31 + a20*b32 + a30*b33;
      out[13]=a01*b30 + a11*b31 + a21*b32 + a31*b33;
      out[14]=a02*b30 + a12*b31 + a22*b32 + a32*b33;
      out[15]=a03*b30 + a13*b31 + a23*b32 + a33*b33;
      return out;
    }
    function mat4Translate(m,[x,y,z]){
      const out = mat4Identity();
      out[12]=x; out[13]=y; out[14]=z;
      return mat4Multiply(m,out);
    }
    function mat4Scale(m,[x,y,z]){
      const out = mat4Identity();
      out[0]=x; out[5]=y; out[10]=z;
      return mat4Multiply(m,out);
    }
    function mat4RotateX(m,rad){
      const c=Math.cos(rad),s=Math.sin(rad);
      const r=mat4Identity();
      r[5]=c; r[9]=-s; r[6]=s; r[10]=c;
      return mat4Multiply(m,r);
    }
    function mat4RotateZ(m,rad){
      const c=Math.cos(rad),s=Math.sin(rad);
      const r=mat4Identity();
      r[0]=c; r[4]=-s; r[1]=s; r[5]=c;
      return mat4Multiply(m,r);
    }
    function rotateAroundAxis(v, axis, angle){
      const {x:ax,y:ay,z:az}=normalize3(axis);
      const cos=Math.cos(angle), sin=Math.sin(angle);
      return {
        x: v.x*cos + (ay*v.z - az*v.y)*sin + ax*(ax*v.x + ay*v.y + az*v.z)*(1-cos),
        y: v.y*cos + (az*v.x - ax*v.z)*sin + ay*(ax*v.x + ay*v.y + az*v.z)*(1-cos),
        z: v.z*cos + (ax*v.y - ay*v.x)*sin + az*(ax*v.x + ay*v.y + az*v.z)*(1-cos)
      };
    }
    function mat4Perspective(fov,aspect,near,far){
      const f=1/Math.tan(fov/2);
      const nf=1/(near-far);
      const out=new Float32Array(16);
      out[0]=f/aspect;
      out[5]=f;
      out[10]=(far+near)*nf;
      out[11]=-1;
      out[14]=(2*far*near)*nf;
      out[15]=0;
      out[1]=out[2]=out[3]=out[4]=out[6]=out[7]=out[8]=out[9]=out[12]=out[13]=0;
      return out;
    }
    function mat4FromNormal(n){
      // Build a basis where Y aligns with the surface normal
      let tangent = { x: n.z, y: 0, z: -n.x };
      let len = Math.hypot(tangent.x, tangent.y, tangent.z);
      if (len < 1e-3) tangent = { x: 1, y: 0, z: 0 };
      else tangent = { x: tangent.x/len, y: tangent.y/len, z: tangent.z/len };
      const bitangent = normalize3({
        x: n.y * tangent.z - n.z * tangent.y,
        y: n.z * tangent.x - n.x * tangent.z,
        z: n.x * tangent.y - n.y * tangent.x
      });
      const out = mat4Identity();
      out[0]=tangent.x; out[1]=tangent.y; out[2]=tangent.z;
      out[4]=n.x; out[5]=n.y; out[6]=n.z;
      out[8]=bitangent.x; out[9]=bitangent.y; out[10]=bitangent.z;
      return out;
    }
    function mat4LookAt(eye, target, up){
      // Forward from eye toward target (camera look direction)
      let zx=eye.x-target.x, zy=eye.y-target.y, zz=eye.z-target.z;
      let len=Math.hypot(zx,zy,zz);
      if(len===0){zz=1; len=1;}
      zx/=len; zy/=len; zz/=len;
      // Right = forward x up
      let xx=up.y*zz-up.z*zy;
      let xy=up.z*zx-up.x*zz;
      let xz=up.x*zy-up.y*zx;
      len=Math.hypot(xx,xy,xz)||1;
      xx/=len; xy/=len; xz/=len;
      // Recomputed up = right x forward
      const yx=zy*xz-zz*xy;
      const yy=zz*xx-zx*xz;
      const yz=zx*xy-zy*xx;
      const out=mat4Identity();
      out[0]=xx; out[1]=xy; out[2]=xz;
      out[4]=yx; out[5]=yy; out[6]=yz;
      out[8]=zx; out[9]=zy; out[10]=zz;
      out[12]=-(xx*eye.x + xy*eye.y + xz*eye.z);
      out[13]=-(yx*eye.x + yy*eye.y + yz*eye.z);
      out[14]=-(zx*eye.x + zy*eye.y + zz*eye.z);
      return out;
    }
    function mat4Invert(a){
      const out=new Float32Array(16);
      const a00=a[0], a01=a[1], a02=a[2], a03=a[3];
      const a10=a[4], a11=a[5], a12=a[6], a13=a[7];
      const a20=a[8], a21=a[9], a22=a[10], a23=a[11];
      const a30=a[12],a31=a[13],a32=a[14],a33=a[15];

      const b00 = a00 * a11 - a01 * a10;
      const b01 = a00 * a12 - a02 * a10;
      const b02 = a00 * a13 - a03 * a10;
      const b03 = a01 * a12 - a02 * a11;
      const b04 = a01 * a13 - a03 * a11;
      const b05 = a02 * a13 - a03 * a12;
      const b06 = a20 * a31 - a21 * a30;
      const b07 = a20 * a32 - a22 * a30;
      const b08 = a20 * a33 - a23 * a30;
      const b09 = a21 * a32 - a22 * a31;
      const b10 = a21 * a33 - a23 * a31;
      const b11 = a22 * a33 - a23 * a32;

      let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
      if (!det) return mat4Identity();
      det = 1.0 / det;

      out[0]  = ( a11 * b11 - a12 * b10 + a13 * b09) * det;
      out[1]  = (-a01 * b11 + a02 * b10 - a03 * b09) * det;
      out[2]  = ( a31 * b05 - a32 * b04 + a33 * b03) * det;
      out[3]  = (-a21 * b05 + a22 * b04 - a23 * b03) * det;
      out[4]  = (-a10 * b11 + a12 * b08 - a13 * b07) * det;
      out[5]  = ( a00 * b11 - a02 * b08 + a03 * b07) * det;
      out[6]  = (-a30 * b05 + a32 * b02 - a33 * b01) * det;
      out[7]  = ( a20 * b05 - a22 * b02 + a23 * b01) * det;
      out[8]  = ( a10 * b10 - a11 * b08 + a13 * b06) * det;
      out[9]  = (-a00 * b10 + a01 * b08 - a03 * b06) * det;
      out[10] = ( a30 * b04 - a31 * b02 + a33 * b00) * det;
      out[11] = (-a20 * b04 + a21 * b02 - a23 * b00) * det;
      out[12] = (-a10 * b09 + a11 * b07 - a12 * b06) * det;
      out[13] = ( a00 * b09 - a01 * b07 + a02 * b06) * det;
      out[14] = (-a30 * b03 + a31 * b01 - a32 * b00) * det;
      out[15] = ( a20 * b03 - a21 * b01 + a22 * b00) * det;
      return out;
    }
    function mat4Invert(a){
      const out=new Float32Array(16);
      const a00=a[0], a01=a[1], a02=a[2], a03=a[3];
      const a10=a[4], a11=a[5], a12=a[6], a13=a[7];
      const a20=a[8], a21=a[9], a22=a[10], a23=a[11];
      const a30=a[12], a31=a[13], a32=a[14], a33=a[15];

      const b00 = a00 * a11 - a01 * a10;
      const b01 = a00 * a12 - a02 * a10;
      const b02 = a00 * a13 - a03 * a10;
      const b03 = a01 * a12 - a02 * a11;
      const b04 = a01 * a13 - a03 * a11;
      const b05 = a02 * a13 - a03 * a12;
      const b06 = a20 * a31 - a21 * a30;
      const b07 = a20 * a32 - a22 * a30;
      const b08 = a20 * a33 - a23 * a30;
      const b09 = a21 * a32 - a22 * a31;
      const b10 = a21 * a33 - a23 * a31;
      const b11 = a22 * a33 - a23 * a32;

      let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
      if (!det) return mat4Identity();
      det = 1.0 / det;

      out[0] = ( a11 * b11 - a12 * b10 + a13 * b09) * det;
      out[1] = (-a01 * b11 + a02 * b10 - a03 * b09) * det;
      out[2] = ( a31 * b05 - a32 * b04 + a33 * b03) * det;
      out[3] = (-a21 * b05 + a22 * b04 - a23 * b03) * det;
      out[4] = (-a10 * b11 + a12 * b08 - a13 * b07) * det;
      out[5] = ( a00 * b11 - a02 * b08 + a03 * b07) * det;
      out[6] = (-a30 * b05 + a32 * b02 - a33 * b01) * det;
      out[7] = ( a20 * b05 - a22 * b02 + a23 * b01) * det;
      out[8] = ( a10 * b10 - a11 * b08 + a13 * b06) * det;
      out[9] = (-a00 * b10 + a01 * b08 - a03 * b06) * det;
      out[10]= ( a30 * b04 - a31 * b02 + a33 * b00) * det;
      out[11]= (-a20 * b04 + a21 * b02 - a23 * b00) * det;
      out[12]= (-a10 * b09 + a11 * b07 - a12 * b06) * det;
      out[13]= ( a00 * b09 - a01 * b07 + a02 * b06) * det;
      out[14]= (-a30 * b03 + a31 * b01 - a32 * b00) * det;
      out[15]= ( a20 * b03 - a21 * b01 + a22 * b00) * det;
      return out;
    }
    function mat4Transpose(m){
      const out=new Float32Array(16);
      out[0]=m[0]; out[1]=m[4]; out[2]=m[8]; out[3]=m[12];
      out[4]=m[1]; out[5]=m[5]; out[6]=m[9]; out[7]=m[13];
      out[8]=m[2]; out[9]=m[6]; out[10]=m[10]; out[11]=m[14];
      out[12]=m[3]; out[13]=m[7]; out[14]=m[11]; out[15]=m[15];
      return out;
    }

    // Geometry
    function createBox(minX,maxX,minY,maxY,minZ,maxZ){
      const positions=[
        minX,minY,maxZ,  maxX,minY,maxZ,  maxX,maxY,maxZ,  minX,maxY,maxZ, // front
        maxX,minY,minZ,  minX,minY,minZ,  minX,maxY,minZ,  maxX,maxY,minZ, // back
        minX,minY,minZ,  minX,minY,maxZ,  minX,maxY,maxZ,  minX,maxY,minZ, // left
        maxX,minY,maxZ,  maxX,minY,minZ,  maxX,maxY,minZ,  maxX,maxY,maxZ, // right
        minX,maxY,maxZ,  maxX,maxY,maxZ,  maxX,maxY,minZ,  minX,maxY,minZ, // top
        minX,minY,minZ,  maxX,minY,minZ,  maxX,minY,maxZ,  minX,minY,maxZ  // bottom
      ];
      const normals=[
        0,0,1,0,0,1,0,0,1,0,0,1,
        0,0,-1,0,0,-1,0,0,-1,0,0,-1,
        -1,0,0,-1,0,0,-1,0,0,-1,0,0,
        1,0,0,1,0,0,1,0,0,1,0,0,
        0,1,0,0,1,0,0,1,0,0,1,0,
        0,-1,0,0,-1,0,0,-1,0,0,-1,0
      ];
      const indices=[];
      for(let i=0;i<6;i++){
        const o=i*4;
        indices.push(o,o+1,o+2, o,o+2,o+3);
      }
      return {positions,normals,indices};
    }

    function createFrustum(base, top, height, includeBottom=true){
      const hb=base/2, ht=top/2;
      const y0=0, y1=height;
      const positions=[
        -hb,y0,hb,  hb,y0,hb,  ht,y1,ht,  -ht,y1,ht, // front
        hb,y0,hb,  hb,y0,-hb,  ht,y1,-ht,  ht,y1,ht, // right
        hb,y0,-hb, -hb,y0,-hb, -ht,y1,-ht, ht,y1,-ht, // back
        -hb,y0,-hb, -hb,y0,hb, -ht,y1,ht, -ht,y1,-ht, // left
        -ht,y1,ht,  ht,y1,ht,  ht,y1,-ht, -ht,y1,-ht, // top
        -hb,y0,-hb, hb,y0,-hb, hb,y0,hb, -hb,y0,hb    // bottom
      ];
      const normals=[];
      const faceNormals=[
        normalize3({x:0,y:0.6,z:1}),
        normalize3({x:1,y:0.6,z:0}),
        normalize3({x:0,y:0.6,z:-1}),
        normalize3({x:-1,y:0.6,z:0}),
        {x:0,y:1,z:0},
        {x:0,y:-1,z:0}
      ];
      for(const n of faceNormals){
        for(let i=0;i<4;i++) normals.push(n.x,n.y,n.z);
      }
      const indices=[];
      const faceCount = includeBottom ? 6 : 5;
      for(let i=0;i<faceCount;i++){
        const o=i*4;
        indices.push(o,o+1,o+2, o,o+2,o+3);
      }
      return {positions,normals,indices};
    }

    function createSphere(radius, latBands=18, lonBands=18){
      const positions=[], normals=[], indices=[];
      for(let lat=0;lat<=latBands;lat++){
        const theta=lat*Math.PI/latBands;
        const sinT=Math.sin(theta), cosT=Math.cos(theta);
        for(let lon=0;lon<=lonBands;lon++){
          const phi=lon*2*Math.PI/lonBands;
          const sinP=Math.sin(phi), cosP=Math.cos(phi);
          const x=cosP*sinT, y=cosT, z=sinP*sinT;
          positions.push(radius*x, radius*y, radius*z);
          normals.push(x,y,z);
        }
      }
      for(let lat=0;lat<latBands;lat++){
        for(let lon=0;lon<lonBands;lon++){
          const first=lat*(lonBands+1)+lon;
          const second=first+lonBands+1;
          indices.push(first,second,first+1, second,second+1,first+1);
        }
      }
      return {positions,normals,indices};
    }

    // Shaders
    const vsSource=`
    attribute vec3 aPosition;
    attribute vec3 aNormal;
    uniform mat4 uMVP;
    uniform mat4 uModel;
    uniform mat4 uNormalMatrix;
    varying vec3 vNormal;
    varying vec3 vWorldPos;
    void main(){
      vNormal = mat3(uNormalMatrix) * aNormal;
      vWorldPos = (uModel * vec4(aPosition,1.0)).xyz;
      gl_Position = uMVP * vec4(aPosition,1.0);
    }`;
    const fsSource=`
    precision mediump float;
    varying vec3 vNormal;
    varying vec3 vWorldPos;
    uniform vec3 uLightDir;
    uniform vec3 uColor;
    uniform vec3 uAmbient;
    uniform float uAlpha;
    uniform vec3 uHoleCenter;
    uniform float uHoleRadius;
    uniform float uHoleSoftness;
    const int MAX_POINTS = 4;
    uniform int uPointCount;
    uniform vec3 uPointPos[MAX_POINTS];
    uniform float uPointIntensity[MAX_POINTS];
    void main(){
      vec3 n = normalize(vNormal);
      float diff = max(dot(n, normalize(uLightDir)), 0.0);
      vec3 color = uAmbient + uColor * diff;
      if (uHoleRadius > 0.0) {
        vec2 d = abs(vWorldPos.xz - uHoleCenter.xz);
        float dist = max(d.x, d.y);
        float feather = max(uHoleSoftness, 0.0001);
        float mask = smoothstep(uHoleRadius - feather, uHoleRadius, dist);
        if (dist < uHoleRadius) discard;
        color *= mask;
      }
      // Point lights from orbs
      vec3 warm = vec3(1.1, 0.95, 0.5);
      for (int i=0; i<MAX_POINTS; ++i) {
        if (i >= uPointCount) break;
        vec3 L = uPointPos[i] - vWorldPos;
        float dist = length(L) + 1e-4;
        vec3 ld = L / dist;
        float diffP = max(dot(n, ld), 0.0);
        float atten = uPointIntensity[i] / (1.0 + dist * dist * 0.001);
        color += warm * diffP * atten;
      }
      color = clamp(color, 0.0, 2.5);
      gl_FragColor = vec4(color, uAlpha);
    }`;

    function createShader(type, source){
      const s=gl.createShader(type);
      gl.shaderSource(s, source);
      gl.compileShader(s);
      if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){
        console.error(gl.getShaderInfoLog(s));
      }
      return s;
    }
    const vs=createShader(gl.VERTEX_SHADER, vsSource);
    const fs=createShader(gl.FRAGMENT_SHADER, fsSource);
    const program=gl.createProgram();
    gl.attachShader(program, vs);
    gl.attachShader(program, fs);
    gl.linkProgram(program);
    if(!gl.getProgramParameter(program, gl.LINK_STATUS)){
      console.error(gl.getProgramInfoLog(program));
    }
    gl.useProgram(program);
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

    const attribs={
      position: gl.getAttribLocation(program, 'aPosition'),
      normal: gl.getAttribLocation(program, 'aNormal')
    };
    const uniforms={
      mvp: gl.getUniformLocation(program, 'uMVP'),
      model: gl.getUniformLocation(program, 'uModel'),
      normalMatrix: gl.getUniformLocation(program, 'uNormalMatrix'),
      lightDir: gl.getUniformLocation(program, 'uLightDir'),
      color: gl.getUniformLocation(program, 'uColor'),
      ambient: gl.getUniformLocation(program, 'uAmbient'),
      alpha: gl.getUniformLocation(program, 'uAlpha'),
      pointCount: gl.getUniformLocation(program, 'uPointCount'),
      pointPos: gl.getUniformLocation(program, 'uPointPos'),
      pointIntensity: gl.getUniformLocation(program, 'uPointIntensity'),
      holeCenter: gl.getUniformLocation(program, 'uHoleCenter'),
      holeRadius: gl.getUniformLocation(program, 'uHoleRadius'),
      holeSoftness: gl.getUniformLocation(program, 'uHoleSoftness')
    };

    function createMesh(geo){
      const vao=gl.createVertexArray();
      gl.bindVertexArray(vao);

      const pos=gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, pos);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(geo.positions), gl.STATIC_DRAW);
      gl.enableVertexAttribArray(attribs.position);
      gl.vertexAttribPointer(attribs.position,3,gl.FLOAT,false,0,0);

      const nor=gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, nor);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(geo.normals), gl.STATIC_DRAW);
      gl.enableVertexAttribArray(attribs.normal);
      gl.vertexAttribPointer(attribs.normal,3,gl.FLOAT,false,0,0);

      const idx=gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, idx);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(geo.indices), gl.STATIC_DRAW);

      return {vao, count: geo.indices.length};
    }

    // Scene params
    const plane = {
      w: 920,
      h: 920,
      tilt: { x: 0, y: 0 },
      targetTilt: { x: 0, y: 0 },
      maxTilt: 0.8,
      wallHeight: 35,
      wallThickness: 14
    };
    const marble = {
      r: 25,
      pos: { x: 0, z: 0 },
      vel: { x: 0, z: 0 },
      y: 0,
      vy: 0
    };
    const pedestal = {
      topSize: marble.r * (8 / 3),
      ramp: marble.r * (8 / 3),
      height: marble.r * (4 / 3),
      slopeGravity: 420
    };
    const pedestalFootprint = pedestal.topSize * 0.5 + pedestal.ramp;
    const pedestalGridCount = 3;
    const pedestalGridSpacing = (() => {
      const totalPedestalWidth = pedestalFootprint * 2 * pedestalGridCount;
      const gap = Math.max(0, (Math.min(plane.w, plane.h) - totalPedestalWidth) / (pedestalGridCount + 1));
      return pedestalFootprint * 2 + gap;
    })();
    const pedestalGrid = {
      count: pedestalGridCount,
      spacing: pedestalGridSpacing
    };
    const pedestalPositions = (() => {
      const arr=[];
      const offset = (pedestalGrid.count - 1) * 0.5;
      for(let i=0;i<pedestalGrid.count;i++){
        for(let j=0;j<pedestalGrid.count;j++){
          arr.push({
            x: (i - offset) * pedestalGrid.spacing,
            z: (j - offset) * pedestalGrid.spacing
          });
        }
      }
      return arr;
    })();
    const centralPedestalIndex = pedestalPositions.findIndex(p => Math.abs(p.x) < 1e-3 && Math.abs(p.z) < 1e-3);
    const centralPedestalPos = centralPedestalIndex >= 0 ? pedestalPositions[centralPedestalIndex] : { x: 0, z: 0 };
    const levelDrop = plane.w;
    const centralCollapse = {
      started: false,
      progress: 0,
      speed: 0.5,
      holeDepth: pedestal.height * 0.25
    };
    const centralHoleRadius = pedestalFootprint * 1.05;
    const centralHoleSoftness = pedestal.ramp * 0.35;
    const levels = [
      { y: 0, applyCollapse: true, hasHole: true },
      { y: -levelDrop, applyCollapse: false, hasHole: false }
    ];
    levels.forEach((lvl, i) => lvl.index = i);
    const orbConfig = { r: 12, count: 4, minCenterDistance: 220, touchRadius: 22 };
    const orbs = [];
    const keys = new Set();
    const history = [];
    const maxHistoryFrames = 900; // ~15s at 60fps
    let orbAnimTime = 0;
    let debugSkippedOrbBatches = 0;
    let currentSupport = null;

    function captureState() {
      return {
        marble: {
          pos: { x: marble.pos.x, z: marble.pos.z },
          vel: { x: marble.vel.x, z: marble.vel.z },
          y: marble.y,
          vy: marble.vy
        },
        plane: {
          tilt: { x: plane.tilt.x, y: plane.tilt.y },
          target: { x: plane.targetTilt.x, y: plane.targetTilt.y }
        },
        orbs: orbs.map(o => ({ level: o.level, collected: o.collected, dissolve: o.dissolve })),
        stars: stars.map(s => ({ x: s.x, y: s.y, vx: s.vx, vy: s.vy, size: s.size, alpha: s.alpha })),
        centralCollapse: { started: centralCollapse.started, progress: centralCollapse.progress },
        orbAnimTime
      };
    }

    function applyState(state) {
      marble.pos.x = state.marble.pos.x;
      marble.pos.z = state.marble.pos.z;
      marble.vel.x = state.marble.vel.x;
      marble.vel.z = state.marble.vel.z;
      marble.y = state.marble.y;
      marble.vy = state.marble.vy;
      plane.tilt.x = state.plane.tilt.x;
      plane.tilt.y = state.plane.tilt.y;
      plane.targetTilt.x = state.plane.target.x;
      plane.targetTilt.y = state.plane.target.y;
      orbAnimTime = state.orbAnimTime ?? orbAnimTime;
      state.orbs.forEach((o,i) => {
        if (orbs[i]) {
          orbs[i].collected = o.collected;
          orbs[i].dissolve = o.dissolve || 0;
          orbs[i].level = o.level ?? orbs[i].level;
        }
      });
      if (state.stars) {
        stars.length = state.stars.length;
        for (let i = 0; i < state.stars.length; i++) {
          const src = state.stars[i];
          let dst = stars[i];
          if (!dst) dst = stars[i] = { x: 0, y: 0, vx: 0, vy: 0, size: 1, alpha: 1 };
          dst.x = src.x;
          dst.y = src.y;
          dst.vx = src.vx;
          dst.vy = src.vy;
          dst.size = src.size;
          dst.alpha = src.alpha;
        }
      }
      if (state.centralCollapse) {
        centralCollapse.started = state.centralCollapse.started;
        centralCollapse.progress = state.centralCollapse.progress;
      }
    }

    function pushHistory() {
      history.push(captureState());
      if (history.length > maxHistoryFrames) history.shift();
    }

    function rewindStep() {
      if (history.length > 1) {
        history.pop(); // discard current
        applyState(history[history.length - 1]);
      }
    }

    function checkOrbCollisions() {
      const currentLevelIndex = currentSupport?.level?.index ?? 0;
      for (const orb of orbs) {
        if (orb.level !== currentLevelIndex) continue;
        if (orb.collected) continue;
        const dx = marble.pos.x - orb.pos.x;
        const dz = marble.pos.z - orb.pos.z;
        const dist = Math.hypot(dx, dz);
        const touch = orbConfig.touchRadius || orbConfig.r;
        if (dist <= marble.r + touch) {
          orb.collected = true;
          orb.dissolve = 0;
        }
      }
    }

    function updateOrbs(dt) {
      for (const orb of orbs) {
        if (orb.collected) {
          orb.dissolve = Math.min(1, (orb.dissolve || 0) + dt * 2.5);
        }
      }
    }

    function skipNextOrbBatch() {
      const batchSize = orbConfig.count;
      const start = debugSkippedOrbBatches * batchSize;
      if (start >= orbs.length) return;
      const end = Math.min(orbs.length, start + batchSize);
      for (let i = start; i < end; i++) {
        orbs[i].collected = true;
        orbs[i].dissolve = 1;
      }
      debugSkippedOrbBatches++;
      console.log(`Debug: skipped orb batch ${debugSkippedOrbBatches}`);
    }

    function centralCollapseEase() {
      const t = Math.min(1, Math.max(0, centralCollapse.progress));
      return t * t * (3 - 2 * t);
    }

    function currentCentralPedestalHeight() {
      const eased = centralCollapseEase();
      return pedestal.height * (1 - eased);
    }

    function pedestalHeightForIndex(idx, applyCollapse=true) {
      if (applyCollapse && idx === centralPedestalIndex && centralPedestalIndex !== -1) {
        return currentCentralPedestalHeight();
      }
      return pedestal.height;
    }

    function pedestalHeightAtLocal(x, z, height=pedestal.height) {
      const halfTop = pedestal.topSize / 2;
      const ramp = pedestal.ramp;
      const maxHalf = halfTop + ramp;
      const dx = Math.abs(x);
      const dz = Math.abs(z);
      if (dx > maxHalf || dz > maxHalf) return -Infinity;
      if (dx <= halfTop && dz <= halfTop) return height;
      const t = Math.max(dx - halfTop, dz - halfTop);
      const ratio = 1 - Math.min(1, t / ramp);
      return height * ratio;
    }
    function pedestalHeightAt(x, z, applyCollapse=true) {
      let maxH = -Infinity;
      for (let i=0;i<pedestalPositions.length;i++) {
        const p = pedestalPositions[i];
        const h = pedestalHeightAtLocal(x - p.x, z - p.z, pedestalHeightForIndex(i, applyCollapse));
        if (h > maxH) maxH = h;
      }
      return maxH === -Infinity ? 0 : maxH;
    }
    function pedestalNormalAt(x, z, applyCollapse=true) {
      const eps = 2;
      const h = pedestalHeightAt(x, z, applyCollapse);
      const hx = pedestalHeightAt(x + eps, z, applyCollapse) - pedestalHeightAt(x - eps, z, applyCollapse);
      const hz = pedestalHeightAt(x, z + eps, applyCollapse) - pedestalHeightAt(x, z - eps, applyCollapse);
      return normalize3({ x: -hx, y: eps * 2, z: -hz });
    }

    function currentHoleRadius() {
      return centralHoleRadius * centralCollapseEase();
    }

    function isPointInCentralHole(x, z) {
      if (!centralCollapse.started) return false;
      const radius = currentHoleRadius();
      const openRadius = radius - centralHoleSoftness * 0.35;
      if (openRadius <= 0) return false;
      const dx = Math.abs(x - centralPedestalPos.x);
      const dz = Math.abs(z - centralPedestalPos.z);
      const dist = Math.max(dx, dz);
      return dist < openRadius;
    }

    function levelHeightAt(level, x, z) {
      if (level.hasHole && isPointInCentralHole(x, z)) return -Infinity;
      const h = pedestalHeightAt(x, z, level.applyCollapse);
      return h + level.y;
    }

    function levelNormalAt(level, x, z) {
      const eps = 2;
      const h = levelHeightAt(level, x, z);
      if (!Number.isFinite(h)) return { x: 0, y: 1, z: 0 };
      const hx = levelHeightAt(level, x + eps, z) - levelHeightAt(level, x - eps, z);
      const hz = levelHeightAt(level, x, z + eps) - levelHeightAt(level, x, z - eps);
      return normalize3({ x: -hx, y: eps * 2, z: -hz });
    }

    function findSupportSurface(x, z, y) {
      let best = null;
      const maxRise = marble.r * 1.5;
      for (const level of levels) {
        const surface = levelHeightAt(level, x, z);
        if (!Number.isFinite(surface)) continue;
        if (surface > y + maxRise) continue; // ignore surfaces too far above current height
        if (!best || surface > best.height) {
          best = { level, height: surface };
        }
      }
      return best;
    }

    function calculateSupport(x, z, y) {
      const surface = findSupportSurface(x, z, y);
      const surfaceHeight = surface ? surface.height : -Infinity;
      const groundHeight = Number.isFinite(surfaceHeight) ? surfaceHeight + marble.r : -Infinity;
      const altitude = Number.isFinite(surfaceHeight) ? y - groundHeight : Infinity;
      const support = Number.isFinite(surfaceHeight) ? Math.max(0, Math.min(1, 1 - altitude / (marble.r * 1.5))) : 0;
      return {
        level: surface?.level || levels[0],
        surfaceHeight,
        groundHeight,
        altitude,
        support
      };
    }

    function refreshSupport() {
      currentSupport = calculateSupport(marble.pos.x, marble.pos.z, marble.y);
      return currentSupport;
    }

    function updateCentralCollapse(dt) {
      const topOrbs = orbs.filter(o => (o.level ?? 0) === 0);
      if (!centralCollapse.started && topOrbs.length >= orbConfig.count && topOrbs.every(o => o.collected)) {
        centralCollapse.started = true;
      }
      if (centralCollapse.started) {
        centralCollapse.progress = Math.min(1, centralCollapse.progress + dt * centralCollapse.speed);
      }
    }

    function updateLightsUniforms() {
      const positions = new Float32Array(12); // 4 * 3
      const intensities = new Float32Array(4);
      let count = 0;
      const currentLevelIndex = currentSupport?.level?.index ?? 0;
      for (const orb of orbs) {
        if (count >= 4) break;
        if (orb.level !== currentLevelIndex) continue;
        if (orb.collected && orb.dissolve >= 1) continue;
        const strength = orb.collected ? Math.max(0, 1 - orb.dissolve) * 0.8 : 1.0;
        positions[count*3+0] = orb.pos.x;
        positions[count*3+1] = orb.pos.y + (levels[orb.level]?.y || 0);
        positions[count*3+2] = orb.pos.z;
        intensities[count] = strength;
        count++;
      }
      gl.uniform1i(uniforms.pointCount, count);
      gl.uniform3fv(uniforms.pointPos, positions);
      gl.uniform1fv(uniforms.pointIntensity, intensities);
    }

    function spawnOrbsForLevel(levelIndex=0) {
      const level = levels[levelIndex] || levels[0];
      const margin = marble.r + orbConfig.r * 2 + 20;
      const centerGuard = orbConfig.minCenterDistance;
      function randomPos() {
        return {
          x: (Math.random() * 2 - 1) * (plane.w / 2 - margin),
          z: (Math.random() * 2 - 1) * (plane.h / 2 - margin)
        };
      }
      const countForLevel = () => orbs.filter(o => o.level === levelIndex).length;
      while (countForLevel() < orbConfig.count) {
        const p = randomPos();
        if (Math.hypot(p.x, p.z) < centerGuard) continue;
        let ok = true;
        for (const o of orbs) {
          const dx = o.pos.x - p.x;
          const dz = o.pos.z - p.z;
          if (Math.hypot(dx, dz) < (orbConfig.r * 2 + 30)) { ok = false; break; }
        }
        if (ok) {
          const yLocal = (levelHeightAt(level, p.x, p.z) - level.y) + orbConfig.r;
          const seed = Math.random() * Math.PI * 2;
          const sats=[];
          for(let k=0;k<4;k++){
            // random axis
            let ax=Math.random()*2-1, ay=Math.random()*2-1, az=Math.random()*2-1;
            const axisLen=Math.hypot(ax,ay,az)||1;
            ax/=axisLen; ay/=axisLen; az/=axisLen;
            // base direction orthogonal to axis
            let bx=ay, by=-ax, bz=0;
            if(Math.hypot(bx,by,bz)<1e-3){bx=0; by=az; bz=-ay;}
            const bl=Math.hypot(bx,by,bz)||1;
            bx/=bl; by/=bl; bz/=bl;
            const radius=orbConfig.r*(1.6+Math.random()*0.5);
            const speed=1.4+Math.random()*0.8;
            const phase=Math.random()*Math.PI*2;
            sats.push({axis:{x:ax,y:ay,z:az}, base:{x:bx*radius,y:by*radius,z:bz*radius}, speed, phase});
          }
          orbs.push({ level: levelIndex, pos: { x: p.x, y: yLocal, z: p.z }, collected: false, dissolve: 0, seed, sats });
        }
      }
    }

    // Geometry instances
    const meshes = {
      floor: createMesh(createBox(-plane.w/2, plane.w/2, -2, 0, -plane.h/2, plane.h/2)),
      walls: createWallMeshes(),
      pedestal: createMesh(createFrustum(pedestal.topSize + pedestal.ramp * 2, pedestal.topSize, pedestal.height)),
      pedestalHole: createMesh(createFrustum(pedestal.topSize + pedestal.ramp * 2, pedestal.topSize, pedestal.height, false)),
      marble: createMesh(createSphere(marble.r, 18, 18))
    };

    function createWallMeshes(){
      const t=plane.wallThickness;
      const h=plane.wallHeight;
      const w=plane.w;
      const hl=plane.h;
      const boxes=[
        createBox(-w/2-t, w/2+t, 0, h, hl/2, hl/2+t),    // back
        createBox(-w/2-t, w/2+t, 0, h, -hl/2-t, -hl/2),  // front
        createBox(-w/2-t, -w/2, 0, h, -hl/2, hl/2),      // left
        createBox(w/2, w/2+t, 0, h, -hl/2, hl/2)         // right
      ];
      return boxes.map(createMesh);
    }

    // Camera/light
    const lightDir = normalize3({ x: -0.4, y: 0.8, z: 0.3 });
    // Keep the camera directly overhead for a top-down view; nudge z to avoid colinearity with the up vector
    const camera = {
      pos: { x: 0, y: 1500, z: 1 },
      target: { x: 0, y: 0, z: 0 },
      baseHeight: 1500,
      followRatio: 0.9,
      smooth: 2.6
    };

    // Input and physics
    function updateInput(dt) {
      const target = plane.targetTilt;
      target.x = 0;
      target.y = 0;
      // Swap left/right so A tilts left, D tilts right
      if (keys.has('KeyA')) target.x -= 1;
      if (keys.has('KeyD')) target.x += 1;
      if (keys.has('KeyW')) target.y += 1;
      if (keys.has('KeyS')) target.y -= 1;
      if (keys.has('Space')) return; // Freeze input accumulation while rewinding
      const len = Math.hypot(target.x, target.y);
      if (len > 1) { target.x /= len; target.y /= len; }
      const smoothing = 12;
      plane.tilt.x += (target.x * plane.maxTilt - plane.tilt.x) * dt * smoothing;
      plane.tilt.y += (target.y * plane.maxTilt - plane.tilt.y) * dt * smoothing;
    }

    function updateCamera(dt) {
      const follow = camera.followRatio;
      const desiredPosY = camera.baseHeight + marble.y * follow;
      const desiredTargetY = marble.y * follow * 0.6;
      const smooth = camera.smooth;
      camera.pos.y += (desiredPosY - camera.pos.y) * dt * smooth;
      camera.target.y += (desiredTargetY - camera.target.y) * dt * smooth;
    }

    function updatePhysics(dt) {
      const tiltAccel = 240;
      const supportInfo = calculateSupport(marble.pos.x, marble.pos.z, marble.y);
      currentSupport = supportInfo;
      const support = supportInfo.support;
      const supportLevel = supportInfo.level;

      let ax = -tiltAccel * Math.sin(plane.tilt.x) * (0.35 + 0.65 * support);
      let az = tiltAccel * Math.sin(plane.tilt.y) * (0.35 + 0.65 * support);

      const eps = 2;
      const left = levelHeightAt(supportLevel, marble.pos.x - eps, marble.pos.z);
      const right = levelHeightAt(supportLevel, marble.pos.x + eps, marble.pos.z);
      const forward = levelHeightAt(supportLevel, marble.pos.x, marble.pos.z + eps);
      const back = levelHeightAt(supportLevel, marble.pos.x, marble.pos.z - eps);
      const dhdx = (Number.isFinite(right) && Number.isFinite(left)) ? (right - left) / (2 * eps) : 0;
      const dhdz = (Number.isFinite(forward) && Number.isFinite(back)) ? (forward - back) / (2 * eps) : 0;
      const slopeScale = pedestal.slopeGravity * support;
      ax += -slopeScale * dhdx;
      az += -slopeScale * dhdz;

      marble.vel.x += ax * dt;
      marble.vel.z += az * dt;

      const frictionGround = 0.9975;
      const frictionAir = 0.999;
      const friction = support > 0.5 ? frictionGround : frictionAir;
      marble.vel.x *= friction;
      marble.vel.z *= friction;

      marble.pos.x += marble.vel.x * dt;
      marble.pos.z += marble.vel.z * dt;

      const gravityY = 900;
      marble.vy -= gravityY * dt;
      marble.y += marble.vy * dt;

      let landingSupport = refreshSupport();
      const newGround = landingSupport.groundHeight;
      if (Number.isFinite(newGround) && marble.y <= newGround) {
        marble.y = newGround;
        if (marble.vy < 0) marble.vy = 0;
        landingSupport = refreshSupport();
      }

      const { w, h } = plane;
      const minX = -w / 2 + marble.r;
      const maxX = w / 2 - marble.r;
      const minZ = -h / 2 + marble.r;
      const maxZ = h / 2 - marble.r;

      if (marble.pos.x < minX) { marble.pos.x = minX; marble.vel.x *= -0.6; }
      if (marble.pos.x > maxX) { marble.pos.x = maxX; marble.vel.x *= -0.6; }
      if (marble.pos.z < minZ) { marble.pos.z = minZ; marble.vel.z *= -0.6; }
      if (marble.pos.z > maxZ) { marble.pos.z = maxZ; marble.vel.z *= -0.6; }

      checkOrbCollisions();
      updateOrbs(dt);
      updateCentralCollapse(dt);
      refreshSupport();
    }

    // Render helpers
    function setMatrices(model) {
      const aspect = canvas.width / canvas.height;
      const proj = mat4Perspective(Math.PI / 4, aspect, 10, 5000);
      const view = mat4LookAt(camera.pos, camera.target, { x: 0, y: 0, z: 1 });
      const vp = mat4Multiply(proj, view);
      const mvp = mat4Multiply(vp, model);
      const normalMatrix = mat4Transpose(mat4Invert(model));
      gl.uniformMatrix4fv(uniforms.mvp, false, mvp);
      gl.uniformMatrix4fv(uniforms.model, false, model);
      gl.uniformMatrix4fv(uniforms.normalMatrix, false, normalMatrix);
    }

    function drawMesh(mesh, model, color, ambient=[0.05,0.08,0.12], alpha=1.0, holeMask=null) {
      gl.bindVertexArray(mesh.vao);
      setMatrices(model);
      gl.uniform3fv(uniforms.lightDir, new Float32Array([lightDir.x, lightDir.y, lightDir.z]));
      gl.uniform3fv(uniforms.color, new Float32Array(color));
      gl.uniform3fv(uniforms.ambient, new Float32Array(ambient));
      gl.uniform1f(uniforms.alpha, alpha);
      if (holeMask) {
        const progress = Math.max(0, Math.min(1, holeMask.progress ?? 1));
        const radius = (holeMask.radius || 0) * progress;
        const center = holeMask.center || { x: 0, y: 0, z: 0 };
        gl.uniform3fv(uniforms.holeCenter, new Float32Array([center.x, center.y, center.z]));
        gl.uniform1f(uniforms.holeRadius, radius);
        gl.uniform1f(uniforms.holeSoftness, holeMask.softness ?? 0);
      } else {
        gl.uniform1f(uniforms.holeRadius, 0);
        gl.uniform1f(uniforms.holeSoftness, 0);
      }
      gl.drawElements(gl.TRIANGLES, mesh.count, gl.UNSIGNED_SHORT, 0);
    }

    function boardTransform(offsetY=0) {
      let m = mat4Identity();
      m = mat4Translate(m, [0, offsetY, 0]);
      m = mat4RotateX(m, plane.tilt.y * 0.35);
      m = mat4RotateZ(m, plane.tilt.x * 0.35);
      return m;
    }

    function drawMarbleEffects(boardM) {
      const supportLevel = currentSupport?.level || levels[0];
      const levelY = supportLevel.y || 0;
      const surfaceY = Number.isFinite(currentSupport?.surfaceHeight) ? currentSupport.surfaceHeight : levelHeightAt(supportLevel, marble.pos.x, marble.pos.z);
      const planeY = Number.isFinite(surfaceY) ? surfaceY : (marble.y - marble.r);
      const normal = levelNormalAt(supportLevel, marble.pos.x, marble.pos.z);
      const orient = mat4FromNormal(normal);
      // Soft blob shadow aligned to surface
      const shadowOffset = 1.2;
      const altitude = Number.isFinite(currentSupport?.altitude) ? currentSupport.altitude : (Number.isFinite(surfaceY) ? marble.y - (surfaceY + marble.r) : Infinity);
      const shadowStrength = Number.isFinite(altitude) ? Math.max(0, Math.min(1, 1 - Math.max(0, altitude) / (marble.r * 2.5))) : 0;
      let shadowM = boardM;
      shadowM = mat4Translate(shadowM, [marble.pos.x, planeY - levelY + shadowOffset, marble.pos.z]);
      shadowM = mat4Multiply(shadowM, orient);
      shadowM = mat4Scale(shadowM, [1.08, 0.08, 1.08]);
      drawMesh(meshes.marble, shadowM, [0,0,0], [0,0,0], 0.38 * shadowStrength);
      // Reflection (mirror across the local surface plane)
      const distanceAbove = marble.y - planeY;
      const reflectionY = planeY - distanceAbove + 1.2;
      let reflectionM = boardM;
      reflectionM = mat4Translate(reflectionM, [marble.pos.x, reflectionY - levelY, marble.pos.z]);
      reflectionM = mat4Multiply(reflectionM, orient);
      reflectionM = mat4Scale(reflectionM, [1, -1, 1]);
      drawMesh(meshes.marble, reflectionM, [0.65,0.7,0.8], [0.05,0.05,0.08], 0.22 * Math.max(0, shadowStrength * 0.58));
    }

    function drawOrbs(boardM, orbTime, levelIndex=0, alpha=1) {
      for (const orb of orbs) {
        if (orb.level !== levelIndex) continue;
        const dissolve = orb.collected ? orb.dissolve : 0;
        if (dissolve >= 1) continue;
        // Halo (outer transparent sphere)
        gl.depthMask(false);
        gl.disable(gl.DEPTH_TEST);
        let haloM = boardM;
        const haloScale = 1.8 + 0.08 * Math.sin(orbTime * 4 + orb.seed);
        haloM = mat4Translate(haloM, [orb.pos.x, orb.pos.y, orb.pos.z]);
        haloM = mat4Scale(haloM, [haloScale * (1 - dissolve*0.6), haloScale * (1 - dissolve*0.6), haloScale * (1 - dissolve*0.6)]);
        drawMesh(meshes.marble, haloM, [1.0,0.85,0.3], [0.22,0.18,0.1], alpha * 0.35 * (1 - dissolve));

        // Four orbiting suns (additive-ish)
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
        for (let i=0;i<orb.sats.length;i++){
          const sat = orb.sats[i];
          const angle = orbTime * sat.speed + sat.phase;
          const dir = rotateAroundAxis(sat.base, sat.axis, angle);
          const sy = dir.y * 0.3 + 2 * Math.sin(orbTime * 3 + i);
          let sM = boardM;
          sM = mat4Translate(sM, [orb.pos.x + dir.x, orb.pos.y + sy, orb.pos.z + dir.z]);
          const sScale = 0.35 * (1 - dissolve);
          sM = mat4Scale(sM, [sScale, sScale, sScale]);
          drawMesh(meshes.marble, sM, [1.3,1.05,0.6], [0.25,0.2,0.1], alpha * 0.65 * (1 - dissolve));
        }
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        gl.depthMask(true);
        gl.enable(gl.DEPTH_TEST);
      }
    }

    function frame(time) {
      const now = time * 0.001;
      const delta = now - (frame.last || now);
      const dt = Math.min(0.033, delta);
      frame.last = now;

      const rewinding = keys.has('Space');
      if (rewinding) {
        rewindStep();
        refreshSupport();
      } else {
        updateInput(dt);
        updatePhysics(dt);
        updateStars(dt);
        orbAnimTime += delta;
        pushHistory();
      }
      updateCamera(dt);
      drawStars();
      updateLightsUniforms();

      gl.enable(gl.DEPTH_TEST);
      gl.clearColor(0, 0, 0, 0);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

      const collapseProgress = centralCollapseEase();
      const onLowerLevel = (currentSupport?.level?.index ?? 0) > 0 || marble.y < -levelDrop * 0.35;
      const topFadeBase = centralCollapse.started ? Math.max(0, Math.min(1, 1 + marble.y / (levelDrop * 0.85))) : 1;
      const topFade = onLowerLevel ? 0 : topFadeBase;
      const holeMask = {
        center: { x: centralPedestalPos.x, y: 0, z: centralPedestalPos.z },
        radius: centralHoleRadius,
        softness: centralHoleSoftness,
        progress: collapseProgress
      };

      const boardEntries = [];
      if (centralCollapse.started) {
        boardEntries.push({ level: levels[1], matrix: boardTransform(levels[1].y), mask: null, alpha: 1 });
      }
      if (topFade > 0.001) {
        boardEntries.push({ level: levels[0], matrix: boardTransform(levels[0].y), mask: holeMask, alpha: topFade });
      }
      if (centralCollapse.started) {
        if (!boardEntries.some(b => b.level.index === 1)) {
          boardEntries.push({ level: levels[1], matrix: boardTransform(levels[1].y), mask: null, alpha: 1 });
        }
      }

      const wallColorTop=[0.08,0.22,0.6];
      const wallColorBottom=[0.06,0.18,0.5];
      for (const entry of boardEntries) {
        const { level, matrix, mask } = entry;
        const floorColor = level === levels[0] ? [0.07, 0.28, 0.7] : [0.06, 0.24, 0.62];
        gl.depthMask(entry.alpha >= 0.999);
        drawMesh(meshes.floor, matrix, floorColor, [0.04,0.06,0.1], entry.alpha, level.hasHole ? mask : null);
        const wallColor = level === levels[0] ? wallColorTop : wallColorBottom;
        for(const w of meshes.walls) drawMesh(w, matrix, wallColor, [0.04,0.05,0.09], entry.alpha);
        for(let i=0;i<pedestalPositions.length;i++){
          const p = pedestalPositions[i];
          const height = pedestalHeightForIndex(i, level.applyCollapse);
          const isCentral = level.applyCollapse && i === centralPedestalIndex;
          const pedMesh = (isCentral && collapseProgress > 0) ? meshes.pedestalHole : meshes.pedestal;
          let pedM = matrix;
          pedM = mat4Translate(pedM, [p.x, 0, p.z]);
          pedM = mat4Scale(pedM, [1, height / pedestal.height, 1]);
          const pedColor = (isCentral && collapseProgress > 0) ? [0.05,0.18,0.5] : [0.1,0.35,0.8];
          drawMesh(pedMesh, pedM, pedColor, [0.05,0.06,0.1], entry.alpha);
        }
        drawOrbs(matrix, orbAnimTime, level.index, entry.alpha);
      }
      gl.depthMask(true);

      const activeLevelY = currentSupport?.level?.y || 0;
      const tiltM = boardTransform(activeLevelY);
      gl.depthMask(false);
      gl.disable(gl.DEPTH_TEST);
      drawMarbleEffects(tiltM);
      gl.depthMask(true);
      gl.enable(gl.DEPTH_TEST);
      let marbleM = tiltM;
      marbleM = mat4Translate(marbleM, [marble.pos.x, marble.y - activeLevelY, marble.pos.z]);
      drawMesh(meshes.marble, marbleM, [0.7,0.7,0.7], [0.1,0.1,0.1]);

      requestAnimationFrame(frame);
    }

    function setupInput() {
      window.addEventListener('keydown', (e) => {
        if (!e.repeat && (e.code === 'Digit0' || e.code === 'Numpad0')) {
          skipNextOrbBatch();
          return;
        }
        keys.add(e.code);
      });
      window.addEventListener('keyup', (e) => keys.delete(e.code));
    }

    marble.y = levelHeightAt(levels[0], marble.pos.x, marble.pos.z) + marble.r;
    refreshSupport();
    spawnOrbsForLevel(0);
    spawnOrbsForLevel(1);
    pushHistory();
    setupInput();
    requestAnimationFrame(frame);
  </script>
</body>
</html>
